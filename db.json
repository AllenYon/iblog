{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-icarus/source/about/index.md","path":"about/index.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","path":"libs/justified-gallery/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/justifiedGallery.min.css","path":"libs/justified-gallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/styles.css","path":"libs/open-sans/styles.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/styles.css","path":"libs/source-code-pro/styles.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.css","path":"libs/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.min.css","path":"libs/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","path":"libs/lightgallery/css/lg-fb-comment-box.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","path":"libs/lightgallery/css/lg-fb-comment-box.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","path":"libs/lightgallery/css/lg-fb-comment-box.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css","path":"libs/lightgallery/css/lg-transitions.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css.map","path":"libs/lightgallery/css/lg-transitions.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.min.css","path":"libs/lightgallery/css/lg-transitions.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css","path":"libs/lightgallery/css/lightgallery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css.map","path":"libs/lightgallery/css/lightgallery.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.min.css","path":"libs/lightgallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/loading.gif","path":"libs/lightgallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/video-play.png","path":"libs/lightgallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/vimeo-play.png","path":"libs/lightgallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/youtube-play.png","path":"libs/lightgallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.js","path":"libs/lightgallery/js/lg-autoplay.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.min.js","path":"libs/lightgallery/js/lg-autoplay.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.js","path":"libs/lightgallery/js/lg-fullscreen.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","path":"libs/lightgallery/js/lg-fullscreen.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.js","path":"libs/lightgallery/js/lg-hash.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.min.js","path":"libs/lightgallery/js/lg-hash.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.js","path":"libs/lightgallery/js/lg-pager.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.min.js","path":"libs/lightgallery/js/lg-pager.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.js","path":"libs/lightgallery/js/lg-share.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.min.js","path":"libs/lightgallery/js/lg-share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.js","path":"libs/lightgallery/js/lg-thumbnail.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","path":"libs/lightgallery/js/lg-thumbnail.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.js","path":"libs/lightgallery/js/lg-video.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.min.js","path":"libs/lightgallery/js/lg-video.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.js","path":"libs/lightgallery/js/lg-zoom.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.min.js","path":"libs/lightgallery/js/lg-zoom.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.js","path":"libs/lightgallery/js/lightgallery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.min.js","path":"libs/lightgallery/js/lightgallery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.eot","path":"libs/lightgallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.svg","path":"libs/lightgallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.ttf","path":"libs/lightgallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.woff","path":"libs/lightgallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","path":"libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/FontAwesome.otf","path":"libs/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","path":"libs/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","path":"libs/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","path":"libs/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/jquery/2.1.3/jquery.min.js","path":"libs/jquery/2.1.3/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","path":"libs/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","path":"libs/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/2013-04-04-SoftInputMethod.md","hash":"2780ab974e29202a3dfbe7e987c974ec0b986bc4","modified":1518644174829},{"_id":"source/_posts/2013-05-10-Detecting-Common-Gestures.md","hash":"c9a3a599c0e899797301171cd8ef0ad603fc32f7","modified":1518644174829},{"_id":"source/_posts/2013-05-10-action_mask.md","hash":"b47e085d0fed2726572760ea4fb768a3ed7ce17a","modified":1518644174830},{"_id":"source/_posts/2013-05-10-intercept-touchevent.md","hash":"08bea90d55e97252cf23291169c6b4617e44181c","modified":1518644174830},{"_id":"source/_posts/2013-05-10-movement.md","hash":"be34e33db9fddca1a499d7e953fe771d4bbfd198","modified":1518644174830},{"_id":"source/_posts/2013-05-11-custom-adapterview.md","hash":"4004db1bf48f64c2bee44950623d29548d32fe06","modified":1518644174831},{"_id":"source/_posts/2013-05-13-android-universal-image-loader.md","hash":"9ae0b2e0d71303524b14bb2101b1a4087e171d52","modified":1518644174831},{"_id":"source/_posts/2013-05-14-countdownlatch.md","hash":"150975dd74aaf465559770a64e5f12dcfe0c2cf4","modified":1518644174831},{"_id":"source/_posts/2013-05-14-lazylistview.md","hash":"c111bf2f7174f310bfd8dd961f15e5e929368533","modified":1518644174831},{"_id":"source/_posts/2013-05-14-lifealgorithm.md","hash":"d498fcea4c9d186e23a875c0959d10526f55f149","modified":1518644174832},{"_id":"source/_posts/2013-05-15-app-widget.md","hash":"4655aebed54b8ad7046932e45bccb1b9b6be4700","modified":1518644174832},{"_id":"source/_posts/2013-05-17-about-activeandroid.md","hash":"fae8b49f49bbdd9450e6b98ff7cf4623c80a7576","modified":1518644174833},{"_id":"source/_posts/2013-05-22-parallaxscrollview.md","hash":"9033b85e3a891c26d84fc5a452294e877aa8d093","modified":1518644174833},{"_id":"source/_posts/2013-05-31-cyclicbarrier.md","hash":"be3fdc76b1482fe9ad247b243a84e54bcb8dd227","modified":1518644174833},{"_id":"source/_posts/2013-05-31-exceptioncenter.md","hash":"b133a3e20c4934642239d69204a4076c43a4aea2","modified":1518644174834},{"_id":"source/_posts/2013-06-03-android-screen.md","hash":"5b71291f5f4f6a4af8983747ae25ac42e75ce716","modified":1518644174834},{"_id":"source/_posts/2013-06-07-fragmenttab.md","hash":"dc2dab3cb024a63d85effbe02e04863fb0c51a3d","modified":1518644174835},{"_id":"source/_posts/2013-06-10-programmer-competency-matrix.md","hash":"14ea214afc1afb2e8233a67c23ca6285caf3aa42","modified":1518644174835},{"_id":"source/_posts/2013-06-13-animation-interpolator.md","hash":"ab7febc5cc188bd31bcf5a9703e2b3228fb961c0","modified":1518644174835},{"_id":"source/_posts/2013-06-14-breath.md","hash":"5617a8270606f54219cb3cab74a3c55b0cbd708a","modified":1518644174836},{"_id":"source/_posts/2013-06-19-animating-scroll-gesture.md","hash":"76328209610dc0ca2648ebb6ebf651cc01e217c3","modified":1518644174837},{"_id":"source/_posts/2013-06-19-viewpage-intercept.md","hash":"62447b5c39c2e24dc34e006f8f181349e2650d7d","modified":1518644174837},{"_id":"source/_posts/2013-08-01-dynamic_load.md","hash":"67d6c0e9e7fe21895f72250cc65fe87558761f86","modified":1518644174838},{"_id":"source/_posts/2013-10-30-display-gif.md","hash":"ed4fe4736566c895ca6a7ba11a753f12ca688296","modified":1518644174838},{"_id":"source/_posts/2013-11-28-picasso.md","hash":"1bca9067d04c598a65681331de72db40b41a3f1b","modified":1518644174838},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1518641379472},{"_id":"source/_posts/2017年年终总结.md","hash":"4f659b9bb9dcc3a655a6734441d88eb2bd8a667f","modified":1518646810166},{"_id":"themes/hexo-theme-icarus/.gitignore","hash":"542aaea07afe90211c6a45c90b7d6879a4503043","modified":1518643412410},{"_id":"themes/hexo-theme-icarus/LICENSE","hash":"df00918fa95de563927fd92b26f14c7affdc3052","modified":1518643412411},{"_id":"themes/hexo-theme-icarus/README.md","hash":"acd2d5d12820b065345d68f88bfc3a739f8d8ae2","modified":1518643412411},{"_id":"themes/hexo-theme-icarus/_config.yml","hash":"bc2f8468083de2b1acfcc906574235a030877d7f","modified":1518645112004},{"_id":"themes/hexo-theme-icarus/package-lock.json","hash":"009f3a8f9e448a03e345fa16e8ffd2a1a20ca348","modified":1518644041087},{"_id":"themes/hexo-theme-icarus/package.json","hash":"1bc52ef10a33df23e56bd73c927f605019c87d41","modified":1518643412430},{"_id":"themes/hexo-theme-icarus/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1518643412404},{"_id":"themes/hexo-theme-icarus/.git/config","hash":"965ef2ab67fe8b8aa4fb072307ee50d7cf6b31fe","modified":1518643412405},{"_id":"themes/hexo-theme-icarus/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1518643397284},{"_id":"themes/hexo-theme-icarus/.git/index","hash":"68d42bae346c6909e24e5409b53dbf11f9bc9e78","modified":1518644036419},{"_id":"themes/hexo-theme-icarus/.git/packed-refs","hash":"9aba972945bd38696eb833224c10b8d449567035","modified":1518643412402},{"_id":"themes/hexo-theme-icarus/.github/ISSUE_TEMPLATE.md","hash":"9393fd3dbc943f1544facb66af7fd8b7a5b9ddbb","modified":1518643412410},{"_id":"themes/hexo-theme-icarus/languages/en.yml","hash":"ade241498b85503a8953a1deca963222f47067a7","modified":1518643412412},{"_id":"themes/hexo-theme-icarus/languages/es.yml","hash":"d7432219be5bee4cb569331378ade61b749688e0","modified":1518643412412},{"_id":"themes/hexo-theme-icarus/languages/fr.yml","hash":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1518643412412},{"_id":"themes/hexo-theme-icarus/languages/id.yml","hash":"e4961da507f66c8f7c37f85653a9437cb2056bf6","modified":1518643412412},{"_id":"themes/hexo-theme-icarus/languages/ja.yml","hash":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1518643412413},{"_id":"themes/hexo-theme-icarus/languages/ko.yml","hash":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1518643412413},{"_id":"themes/hexo-theme-icarus/languages/pt-BR.yml","hash":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1518643412413},{"_id":"themes/hexo-theme-icarus/languages/ru.yml","hash":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1518643412413},{"_id":"themes/hexo-theme-icarus/languages/tr.yml","hash":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1518643412414},{"_id":"themes/hexo-theme-icarus/languages/zh-CN.yml","hash":"3dc8ec524805afd090438be717908750da439204","modified":1518643412414},{"_id":"themes/hexo-theme-icarus/languages/zh-TW.yml","hash":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1518643412414},{"_id":"themes/hexo-theme-icarus/layout/archive.ejs","hash":"c1ecf667f40f34d61ab33eed46bab143eb1af36d","modified":1518643412414},{"_id":"themes/hexo-theme-icarus/layout/categories.ejs","hash":"aa95629b770cff8cca9d663aeb6b17928f070de5","modified":1518643412415},{"_id":"themes/hexo-theme-icarus/layout/category.ejs","hash":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1518643412415},{"_id":"themes/hexo-theme-icarus/layout/index.ejs","hash":"43e971ebc35657b18e08a049559790348a16666f","modified":1518643412423},{"_id":"themes/hexo-theme-icarus/layout/layout.ejs","hash":"6f01b3d46d184a820297f9542497808b152bb09e","modified":1518643412423},{"_id":"themes/hexo-theme-icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1518643412423},{"_id":"themes/hexo-theme-icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1518643412425},{"_id":"themes/hexo-theme-icarus/layout/tag.ejs","hash":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1518643412428},{"_id":"themes/hexo-theme-icarus/layout/tags.ejs","hash":"b0fcea68d7c11e5899bf0375d80997685111653f","modified":1518643412428},{"_id":"themes/hexo-theme-icarus/scripts/meta.js","hash":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1518643412431},{"_id":"themes/hexo-theme-icarus/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1518643412431},{"_id":"themes/hexo-theme-icarus/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1518643397286},{"_id":"themes/hexo-theme-icarus/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1518643397285},{"_id":"themes/hexo-theme-icarus/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1518643397287},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1518643397287},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1518643397286},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1518643397287},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1518643397285},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1518643397286},{"_id":"themes/hexo-theme-icarus/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1518643397286},{"_id":"themes/hexo-theme-icarus/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1518643397287},{"_id":"themes/hexo-theme-icarus/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1518643397283},{"_id":"themes/hexo-theme-icarus/.git/logs/HEAD","hash":"06b5b6a44891244ec5c7f401ae1ceec829aeb2f4","modified":1518643412404},{"_id":"themes/hexo-theme-icarus/_source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1518643412411},{"_id":"themes/hexo-theme-icarus/_source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1518643412412},{"_id":"themes/hexo-theme-icarus/_source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1518643412412},{"_id":"themes/hexo-theme-icarus/layout/common/article.ejs","hash":"9c260a551596f71e93177f2289b5cb1c4bc7d96c","modified":1518643412418},{"_id":"themes/hexo-theme-icarus/layout/common/footer.ejs","hash":"cbfe560fcab445d42ceeb5d1beba5957d5be5eaa","modified":1518643412418},{"_id":"themes/hexo-theme-icarus/layout/common/head.ejs","hash":"44f30945882afd27c89da2173da501fb1b531488","modified":1518643412418},{"_id":"themes/hexo-theme-icarus/layout/common/header.ejs","hash":"738c6a923b2a6de6a81c4892c8a47e03d8b34f88","modified":1518643412419},{"_id":"themes/hexo-theme-icarus/layout/common/profile.ejs","hash":"0d5a9622d490652599e3ba3e4077a7d6bb2eb38e","modified":1518643412421},{"_id":"themes/hexo-theme-icarus/layout/common/scripts.ejs","hash":"c0a1a9e53f89440c42c325d5bd8c7234652c8937","modified":1518643412422},{"_id":"themes/hexo-theme-icarus/layout/common/sidebar.ejs","hash":"1ee2384f98c8ccaa7a5b00f14ad2a9a67022c143","modified":1518643412422},{"_id":"themes/hexo-theme-icarus/layout/common/thumbnail.ejs","hash":"1b70f8a98cd8650b159bda858dbee38dbdb7f0c5","modified":1518643412422},{"_id":"themes/hexo-theme-icarus/layout/common/timeline.ejs","hash":"6420e34e0332c9b6670011519f341340db989343","modified":1518643412423},{"_id":"themes/hexo-theme-icarus/layout/comment/changyan.ejs","hash":"b4bd2e641af59e06becaa8f2dc97867f023b8dcf","modified":1518643412415},{"_id":"themes/hexo-theme-icarus/layout/comment/counter.ejs","hash":"57c194d0fa268ce2f3e9c755b3154b8a0709f613","modified":1518643412415},{"_id":"themes/hexo-theme-icarus/layout/comment/disqus.ejs","hash":"1b32a90f400dc580f4b8298de75b94429ca6de68","modified":1518643412416},{"_id":"themes/hexo-theme-icarus/layout/comment/duoshuo.ejs","hash":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1518643412416},{"_id":"themes/hexo-theme-icarus/layout/comment/facebook.ejs","hash":"5ee16430a4435c2fead0275ff83fc98092d73d4c","modified":1518643412416},{"_id":"themes/hexo-theme-icarus/layout/comment/gitment.ejs","hash":"c7998209b9a766eeba6976dd4bdffb1f87469358","modified":1518643412416},{"_id":"themes/hexo-theme-icarus/layout/comment/index.ejs","hash":"0bce9ca0767b49d2a9fc026a6004a8526a20624b","modified":1518643412416},{"_id":"themes/hexo-theme-icarus/layout/comment/isso.ejs","hash":"4f8b81ff5bb418ec11ce080d515f247bfe436014","modified":1518643412417},{"_id":"themes/hexo-theme-icarus/layout/comment/livere.ejs","hash":"792e4f0e93b2bdc5abd85d447d804a5c608a9c5c","modified":1518643412417},{"_id":"themes/hexo-theme-icarus/layout/comment/scripts.ejs","hash":"d45f652268671de96c86d8ca50b9deaf011274f0","modified":1518643412417},{"_id":"themes/hexo-theme-icarus/layout/comment/valine.ejs","hash":"0ea90a606f0d386a5ae0da83c0501cbb25319fde","modified":1518643412417},{"_id":"themes/hexo-theme-icarus/layout/comment/youyan.ejs","hash":"6fe807992832939caf6c3e7651d052df9520d88e","modified":1518643412418},{"_id":"themes/hexo-theme-icarus/layout/plugin/baidu-analytics.ejs","hash":"6a7bee18e666e627e62541a5e30906f87ba1bfe8","modified":1518643412424},{"_id":"themes/hexo-theme-icarus/layout/plugin/google-analytics.ejs","hash":"349f08b6521a16e79046b1f94f04317ac74f556e","modified":1518643412424},{"_id":"themes/hexo-theme-icarus/layout/plugin/scripts.ejs","hash":"e22f99652a220d926103801a3cad55ea9c450e05","modified":1518643412424},{"_id":"themes/hexo-theme-icarus/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1518643412425},{"_id":"themes/hexo-theme-icarus/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1518643412425},{"_id":"themes/hexo-theme-icarus/layout/search/index.ejs","hash":"24935e32e61d4706454b174ea3bed0726ae7fb34","modified":1518643412426},{"_id":"themes/hexo-theme-icarus/layout/search/insight.ejs","hash":"130fe3d33ac71da0b50f7fee6a87979f30938a1b","modified":1518643412426},{"_id":"themes/hexo-theme-icarus/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1518643412426},{"_id":"themes/hexo-theme-icarus/layout/share/addtoany.ejs","hash":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1518643412427},{"_id":"themes/hexo-theme-icarus/layout/share/bdshare.ejs","hash":"a1e772c5a6f174d585b0c1e574058f75dc8e2898","modified":1518643412427},{"_id":"themes/hexo-theme-icarus/layout/share/default.ejs","hash":"ebfb919dc525b3ed61a6a5ee05ee71410eedc541","modified":1518643412427},{"_id":"themes/hexo-theme-icarus/layout/share/index.ejs","hash":"2a2c0095b95b11e5692bd8ad6a2337aa644189a2","modified":1518643412428},{"_id":"themes/hexo-theme-icarus/layout/share/jiathis.ejs","hash":"21ebaa51e828cba2cefbeeaccb01514643565755","modified":1518643412428},{"_id":"themes/hexo-theme-icarus/layout/widget/archive.ejs","hash":"d9ebbb7f6ce2f25df5ae25e4a1fef3c08f7054b9","modified":1518643412429},{"_id":"themes/hexo-theme-icarus/layout/widget/category.ejs","hash":"583bda80cf15b3ef11fefbd1b502897dfff40100","modified":1518643412429},{"_id":"themes/hexo-theme-icarus/layout/widget/links.ejs","hash":"aad118699718b62c0d3f3cfd6f17a181139a76af","modified":1518643412429},{"_id":"themes/hexo-theme-icarus/layout/widget/recent_posts.ejs","hash":"2ca923465275fb38a7ac7d67211d6e94a977e957","modified":1518643412430},{"_id":"themes/hexo-theme-icarus/layout/widget/tag.ejs","hash":"3b8ae5953990436893da9d68f910ebe592005659","modified":1518643412430},{"_id":"themes/hexo-theme-icarus/layout/widget/tagcloud.ejs","hash":"ca8c7bf555fb6ce4904f2c59160548405c2c8a82","modified":1518643412430},{"_id":"themes/hexo-theme-icarus/source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1518644829562},{"_id":"themes/hexo-theme-icarus/source/css/_extend.styl","hash":"539e02107f35e8b3bdb9bf160dc212a433a7b60e","modified":1518643412432},{"_id":"themes/hexo-theme-icarus/source/css/_variables.styl","hash":"d62af931be6612ec8c3a917836379a8cd92fbce1","modified":1518643412460},{"_id":"themes/hexo-theme-icarus/source/css/style.styl","hash":"1716b199dba80b26086f325d69c36fa682465106","modified":1518643412461},{"_id":"themes/hexo-theme-icarus/source/js/insight.js","hash":"c1bafa7f87e9f25fca1e033fc6d1e0c82712ac99","modified":1518643412462},{"_id":"themes/hexo-theme-icarus/source/js/main.js","hash":"23b373067df0dbac27622bc7537bb4fda243a9c8","modified":1518643412462},{"_id":"themes/hexo-theme-icarus/.git/objects/pack/pack-d611b37c0bcd4551d83280da27dfe6b037cb9080.idx","hash":"d5f1880cc5e2a0af3346488f0fde44cbd75a0fa4","modified":1518643412387},{"_id":"themes/hexo-theme-icarus/.git/refs/heads/master","hash":"93cadec7110d74453ec94cf59c8dc39d1e7e6459","modified":1518643412404},{"_id":"themes/hexo-theme-icarus/layout/common/post/banner.ejs","hash":"47ced3f03525698c79c6b1c07b48383fb6c496b2","modified":1518643412419},{"_id":"themes/hexo-theme-icarus/layout/common/post/category.ejs","hash":"75c9dda2e7ec041943855ca163a6b1c4c8b4f260","modified":1518643412419},{"_id":"themes/hexo-theme-icarus/layout/common/post/date.ejs","hash":"45cb0bcad461036cdd1fe2e3fbb5f2f19940025c","modified":1518643412420},{"_id":"themes/hexo-theme-icarus/layout/common/post/gallery.ejs","hash":"659f019761116313169148ec61773e7b84abb739","modified":1518643412420},{"_id":"themes/hexo-theme-icarus/layout/common/post/nav.ejs","hash":"d7cd611e642327f33dff3963ef869c2b46824a11","modified":1518643412420},{"_id":"themes/hexo-theme-icarus/layout/common/post/tag.ejs","hash":"2e966216256321aa0c76fe1b9be689601c76ef31","modified":1518643412421},{"_id":"themes/hexo-theme-icarus/layout/common/post/title.ejs","hash":"669ddb46fefa100856588351a7a2d30ad996b755","modified":1518643412421},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1518643412432},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1518643412432},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1518643412433},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1518643412433},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1518643412433},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1518643412434},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1518643412434},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1518643412434},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1518643412435},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1518643412435},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1518643412435},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1518643412436},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1518643412436},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1518643412436},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1518643412436},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1518643412437},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1518643412437},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1518643412437},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1518643412438},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1518643412438},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1518643412438},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1518643412438},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1518643412438},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1518643412439},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1518643412439},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1518643412439},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1518643412440},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1518643412440},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1518643412440},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1518643412440},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1518643412441},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1518643412441},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1518643412441},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1518643412442},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1518643412442},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1518643412442},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1518643412442},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1518643412443},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1518643412443},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1518643412444},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1518643412444},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1518643412444},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1518643412445},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1518643412445},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1518643412446},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1518643412447},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1518643412447},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1518643412447},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1518643412448},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1518643412448},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1518643412448},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1518643412449},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1518643412449},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1518643412449},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1518643412450},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1518643412450},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1518643412450},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1518643412451},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1518643412451},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1518643412451},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1518643412451},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1518643412452},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1518643412452},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1518643412453},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1518643412453},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1518643412453},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1518643412454},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1518643412455},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1518643412455},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1518643412455},{"_id":"themes/hexo-theme-icarus/source/css/_util/grid.styl","hash":"93fb6f1e2f40cd7d88ad0d56dd73d3f9a7bc853e","modified":1518643412459},{"_id":"themes/hexo-theme-icarus/source/css/_util/mixin.styl","hash":"c8e1ddfc0fe9108bab592c7a73b73ce9344991fd","modified":1518643412459},{"_id":"themes/hexo-theme-icarus/source/css/_partial/archive.styl","hash":"d35088c83ddd7a197d6d94e16a2ce3a7e29fa1dc","modified":1518643412456},{"_id":"themes/hexo-theme-icarus/source/css/_partial/article.styl","hash":"77c4ae7fe3dc16c569bb45d365cc3c147c2e9498","modified":1518643412456},{"_id":"themes/hexo-theme-icarus/source/css/_partial/comment.styl","hash":"784646796184d4f27918c22395288a2fafbf9554","modified":1518643412456},{"_id":"themes/hexo-theme-icarus/source/css/_partial/footer.styl","hash":"484776654e4c1691dc844e6e93786a08855c1c99","modified":1518643412457},{"_id":"themes/hexo-theme-icarus/source/css/_partial/header.styl","hash":"1e351f741144135871a3373fe7e969dc961b65e7","modified":1518643412457},{"_id":"themes/hexo-theme-icarus/source/css/_partial/insight.styl","hash":"19833cd127f26ad90b06c115f8a96a30e0c0e53b","modified":1518643412457},{"_id":"themes/hexo-theme-icarus/source/css/_partial/profile.styl","hash":"fb0170075dc2a41e01dd11bbfdbccbed544c479a","modified":1518643412458},{"_id":"themes/hexo-theme-icarus/source/css/_partial/sidebar.styl","hash":"f528ca7064d9fcecd737b9b71c9c54601365d7d3","modified":1518643412458},{"_id":"themes/hexo-theme-icarus/source/css/_partial/timeline.styl","hash":"c813b98f4fc45b64d2e07e5d944745a654c8c943","modified":1518643412458},{"_id":"themes/hexo-theme-icarus/source/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1518643412460},{"_id":"themes/hexo-theme-icarus/source/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1518643412461},{"_id":"themes/hexo-theme-icarus/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1518643412461},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1518643412476},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1518643412477},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1518643412497},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1518643412498},{"_id":"themes/hexo-theme-icarus/.git/logs/refs/heads/master","hash":"06b5b6a44891244ec5c7f401ae1ceec829aeb2f4","modified":1518643412405},{"_id":"themes/hexo-theme-icarus/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1518643412403},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1518643412463},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1518643412464},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1518643412477},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1518643412478},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1518643412478},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1518643412478},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1518643412479},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1518643412479},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1518643412480},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1518643412480},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1518643412481},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1518643412482},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1518643412482},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1518643412483},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1518643412483},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1518643412483},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1518643412484},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1518643412484},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1518643412484},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1518643412485},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1518643412485},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1518643412485},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1518643412486},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1518643412486},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1518643412486},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1518643412487},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1518643412487},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1518643412487},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1518643412488},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1518643412488},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1518643412488},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1518643412489},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1518643412490},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1518643412481},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1518643412481},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1518643412482},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1518643412482},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1518643412498},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1518643412498},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1518643412490},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1518643412491},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1518643412491},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1518643412491},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1518643412491},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1518643412492},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1518643412492},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1518643412492},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1518643412493},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1518643412493},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1518643412493},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1518643412494},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1518643412494},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1518643412495},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1518643412495},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1518643412495},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1518643412496},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1518643412496},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1518643412496},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1518643412497},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1518643412497},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1518643412466},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1518643412467},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1518643412474},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1518643412474},{"_id":"themes/hexo-theme-icarus/source/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1518643412476},{"_id":"themes/hexo-theme-icarus/.git/logs/refs/remotes/origin/HEAD","hash":"06b5b6a44891244ec5c7f401ae1ceec829aeb2f4","modified":1518643412403},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1518643412473},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1518643412471},{"_id":"themes/hexo-theme-icarus/.git/objects/pack/pack-d611b37c0bcd4551d83280da27dfe6b037cb9080.pack","hash":"e23244db5daa5b1caddcae6cfe0140b878c30145","modified":1518643412387},{"_id":"public/content.json","hash":"40529e4c73864dbbb1b0b59ebf6caab9c06a9d8e","modified":1518646820816},{"_id":"public/archives/2013/04/index.html","hash":"7e9cca03807ca60047eaa66489142d505cd5d2ff","modified":1518646821121},{"_id":"public/archives/2013/08/index.html","hash":"ba2afcdd7627a474f5fddd9db7edfc6c5e070f7c","modified":1518646821121},{"_id":"public/archives/2013/10/index.html","hash":"6975fd88808c22c9f3fe171c9ed4399522d3a35f","modified":1518646821121},{"_id":"public/archives/2013/11/index.html","hash":"59f00bc75aee0f418ada06fc5a7f7ca0aedadcb2","modified":1518646821122},{"_id":"public/2018/02/15/hello-world/index.html","hash":"1a1acc01df752c2a53a5a0e4474695b74d6a984f","modified":1518646821122},{"_id":"public/2013/11/28/2013-11-28-picasso/index.html","hash":"2e3ff775c5f710d41f3f8ca42c507a5c61be6968","modified":1518646821122},{"_id":"public/2013/10/30/2013-10-30-display-gif/index.html","hash":"db68bfd7f7357d4ebf900041a01d414bafe1a220","modified":1518646821122},{"_id":"public/2013/08/01/2013-08-01-dynamic_load/index.html","hash":"63412fdd280d36c5a991db0cf35c2c8ddbf13cc6","modified":1518646821122},{"_id":"public/2013/06/19/2013-06-19-viewpage-intercept/index.html","hash":"65902e531ff1f8f08af0f522edb4aba03cacfa3c","modified":1518646821122},{"_id":"public/2013/06/19/2013-06-19-animating-scroll-gesture/index.html","hash":"7a934efa0051fbe124f16340832c5eefc25ebad2","modified":1518646821122},{"_id":"public/2013/06/14/2013-06-14-breath/index.html","hash":"c3b99dfffb46a1f4ff0792182cf6ba7f1eb0cdb3","modified":1518646821122},{"_id":"public/2013/06/13/2013-06-13-animation-interpolator/index.html","hash":"cacf8be557de53ef1dbb8c94d205c1d4e280c522","modified":1518646821122},{"_id":"public/2013/06/10/2013-06-10-programmer-competency-matrix/index.html","hash":"3cade516b6c273b1bd9244afa21e84204634176d","modified":1518646821122},{"_id":"public/2013/06/07/2013-06-07-fragmenttab/index.html","hash":"de2760c28d17af5cc5f7290bbbba9f245dda711d","modified":1518646821122},{"_id":"public/2013/06/03/2013-06-03-android-screen/index.html","hash":"fa25f06f70bbdff809ec137e36ae4f3e31e45ea1","modified":1518646821122},{"_id":"public/2013/05/31/2013-05-31-cyclicbarrier/index.html","hash":"3b428797ec366cf8d5c6238ccec497d8690d4701","modified":1518646821122},{"_id":"public/2013/05/31/2013-05-31-exceptioncenter/index.html","hash":"38a861138c288e3fda7d8252de713964c45d689b","modified":1518646821122},{"_id":"public/2013/05/22/2013-05-22-parallaxscrollview/index.html","hash":"4815029687bfeb5bf6886aff98af2e8480823479","modified":1518646821122},{"_id":"public/2013/05/17/2013-05-17-about-activeandroid/index.html","hash":"a911738389a3cbda55b89e46e1d11647d9c1325c","modified":1518646821123},{"_id":"public/2013/05/15/2013-05-15-app-widget/index.html","hash":"dd11ec6eeb53c38a94f645543e0b2b369613ccb8","modified":1518646821123},{"_id":"public/2013/05/14/2013-05-14-countdownlatch/index.html","hash":"0691ef27b079fffbb6ee63f37fded30dd6d76552","modified":1518646821123},{"_id":"public/2013/05/14/2013-05-14-lazylistview/index.html","hash":"7363c399614375873cfcfe538d62db8aa4cf16c9","modified":1518646821123},{"_id":"public/2013/05/14/2013-05-14-lifealgorithm/index.html","hash":"ed26afe4b0b41cec93fe3cb97f7c9be44712c5fb","modified":1518646821123},{"_id":"public/2013/05/13/2013-05-13-android-universal-image-loader/index.html","hash":"10a6ede2ee88724e04d34ea175b7e7a4afe46ecb","modified":1518646821123},{"_id":"public/2013/05/11/2013-05-11-custom-adapterview/index.html","hash":"ccfa1a4132c1440a5c9a6784749678cb69744b1c","modified":1518646821123},{"_id":"public/2013/05/10/2013-05-10-Detecting-Common-Gestures/index.html","hash":"6066bbff6a20cf086ba3ed9f56167160244ea278","modified":1518646821123},{"_id":"public/2013/05/10/2013-05-10-movement/index.html","hash":"a492950b0141b101a11bebfbddbc47b9c14a7247","modified":1518646821123},{"_id":"public/2013/05/10/2013-05-10-intercept-touchevent/index.html","hash":"225b8ccd70f591aef5bfdba96f7b7351f854577f","modified":1518646821123},{"_id":"public/2013/05/10/2013-05-10-action_mask/index.html","hash":"e3e6728938bd3ef6679475616797793191ab4bb9","modified":1518646821123},{"_id":"public/2013/04/04/2013-04-04-SoftInputMethod/index.html","hash":"14e732daaf7a633df0b3e9168323e3829b94acc2","modified":1518646821123},{"_id":"public/archives/index.html","hash":"fc9544da31a015c6ec1a2fc92e2e3c6bfca4ed93","modified":1518646821124},{"_id":"public/archives/page/2/index.html","hash":"2da717185b4198cd8ac09e5fc66c8d18dabce721","modified":1518646821124},{"_id":"public/archives/page/3/index.html","hash":"f2476ea7f0e89cd26212e2a273ec885e6acfd785","modified":1518646821124},{"_id":"public/archives/2013/index.html","hash":"df3c1c53b52d668f280938e371dd00814e847ac7","modified":1518646821124},{"_id":"public/archives/2013/page/2/index.html","hash":"285954e8a07d9a97117188d923a422f4e21b1b04","modified":1518646821124},{"_id":"public/archives/2013/page/3/index.html","hash":"bd9759f87f276f67f79a581406a6949916cc6b1b","modified":1518646821124},{"_id":"public/archives/2013/05/index.html","hash":"e1a53da0b913fbeabb882f87b612748a1b5ea0d2","modified":1518646821124},{"_id":"public/archives/2013/05/page/2/index.html","hash":"5fb794ec6f444a793ca4d69cadf0c6594d3136ba","modified":1518646821124},{"_id":"public/archives/2013/06/index.html","hash":"8ee13f37bdbacedc6ccc901953a9c4ce4ac0dfb3","modified":1518646821124},{"_id":"public/archives/2018/index.html","hash":"26bc8f9337ed8d929cd85700bd776f7001dff181","modified":1518646821124},{"_id":"public/archives/2018/02/index.html","hash":"0a565be3c8f523483daac363580c34fcf38b23ea","modified":1518646821124},{"_id":"public/categories/Android/index.html","hash":"7048f8c5716ed4dbceeea1e29f98b15f3bcb3902","modified":1518646821124},{"_id":"public/categories/Android/page/2/index.html","hash":"bc25fa8f85c086c5e89a1bfa35009161001ca246","modified":1518646821124},{"_id":"public/categories/Android/page/3/index.html","hash":"82af38afc16659730804c6feda42f6a86bcf0db1","modified":1518646821125},{"_id":"public/index.html","hash":"0a627aa2bbc018b150c228d158646639b85e5ddd","modified":1518646821125},{"_id":"public/page/2/index.html","hash":"02a3e0c48aa1f52b9c6085db3cab6b4f34efb035","modified":1518646821125},{"_id":"public/page/3/index.html","hash":"e98ae9143b3d6405d2529363aff309e4564315e9","modified":1518646821125},{"_id":"public/tags/work/index.html","hash":"80b010f102dd3fceec77da6ebce1aa9f748ad6d0","modified":1518646821193},{"_id":"public/2018/02/15/2017年年终总结/index.html","hash":"07fa191a823e3e0c1ff4b8df82ae11f23c339e09","modified":1518646821193},{"_id":"public/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1518646821193},{"_id":"public/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1518646821193},{"_id":"public/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1518646821194},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1518646821194},{"_id":"public/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1518646821194},{"_id":"public/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1518646821194},{"_id":"public/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1518646821194},{"_id":"public/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1518646821194},{"_id":"public/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1518646821194},{"_id":"public/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1518646821194},{"_id":"public/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1518646821194},{"_id":"public/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1518646821194},{"_id":"public/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1518646821194},{"_id":"public/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1518646821195},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1518646821195},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1518646821195},{"_id":"public/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1518646821196},{"_id":"public/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1518646821196},{"_id":"public/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1518646821196},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1518646821196},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1518646821196},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1518646821196},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1518646821196},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1518646821196},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1518646821196},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1518646821197},{"_id":"public/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1518646821197},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1518646821779},{"_id":"public/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1518646821783},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1518646821784},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1518646821784},{"_id":"public/about/index.html","hash":"e3288fe78143a4cd91fd49af119f298888c55bcb","modified":1518646821795},{"_id":"public/js/insight.js","hash":"c1bafa7f87e9f25fca1e033fc6d1e0c82712ac99","modified":1518646821795},{"_id":"public/js/main.js","hash":"23b373067df0dbac27622bc7537bb4fda243a9c8","modified":1518646821795},{"_id":"public/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1518646821795},{"_id":"public/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1518646821795},{"_id":"public/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1518646821795},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1518646821795},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1518646821795},{"_id":"public/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1518646821795},{"_id":"public/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1518646821796},{"_id":"public/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1518646821796},{"_id":"public/css/style.css","hash":"f48d9ebb230859086fa29957616afd3d1b962cb1","modified":1518646821796},{"_id":"public/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1518646821796},{"_id":"public/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1518646821796},{"_id":"public/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1518646821797},{"_id":"public/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1518646821797},{"_id":"public/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1518646821797},{"_id":"public/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1518646821797},{"_id":"public/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1518646821797},{"_id":"public/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1518646821797},{"_id":"public/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1518646821797},{"_id":"public/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1518646821797},{"_id":"public/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1518646821797},{"_id":"public/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1518646821797},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1518646821797},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1518646821805}],"Category":[{"name":"Android","_id":"cjdnn3tkc0002rpfybrh70zzf"}],"Data":[],"Page":[],"Post":[{"date":"2013-04-03T16:00:00.000Z","layout":"post","title":"显示隐藏软键盘--InputMethodManager源码","_content":"\nInputMethodManager主要是用来管理IME的相关操作的，如显示,隐藏,开关等,我们常会用到这么三个方法\n\n- public void toggleSoftInputFromWindow(android.os.IBinder windowToken, int showFlags, int hideFlags)\n- public boolean hideSoftInputFromWindow(android.os.IBinder windowToken, int flags)\n- public void showSoftInputFromInputMethod(android.os.IBinder token, int flags)   \n\nshowFlags,hideFlags是我们可以传入的参数常量，让我们看看文档里对它们的定义:\n\n    /**\n     * Flag for {@link #showSoftInput} to indicate that this is an implicit\n     * request to show the input window, not as the result of a direct request\n     * by the user.  The window may not be shown in this case.\n     */\n    public static final int SHOW_IMPLICIT = 0x0001;\n\n    /**\n     * Flag for {@link #showSoftInput} to indicate that the user has forced\n     * the input method open (such as by long-pressing menu) so it should\n     * not be closed until they explicitly do so.\n     */\n    public static final int SHOW_FORCED = 0x0002;\n\n\n    /**\n     * Flag for {@link #hideSoftInputFromWindow} to indicate that the soft\n     * input window should only be hidden if it was not explicitly shown\n     * by the user.\n     */\n    public static final int HIDE_IMPLICIT_ONLY = 0x0001;\n\n    /**\n     * Flag for {@link #hideSoftInputFromWindow} to indicate that the soft\n     * input window should normally be hidden, unless it was originally\n     * shown with {@link #SHOW_FORCED}.\n     */\n    public static final int HIDE_NOT_ALWAYS = 0x0002;\n\n可以看出SHOW_IMPLICIT(隐形显示)和HIDE_IMPLICIT_ONLY(隐形隐藏)是相对应的，\n\n1. 假如用户显示时设置flag为SHOW_FORCED(强制显示)，那么当隐藏是设置HIDE_IMPLICIT_ONLY时，软键盘并不会隐藏。\n","source":"_posts/2013-04-04-SoftInputMethod.md","raw":"---\ncategory: Android\ndate: 2013-04-04\nlayout: post\ntitle: 显示隐藏软键盘--InputMethodManager源码\n---\n\nInputMethodManager主要是用来管理IME的相关操作的，如显示,隐藏,开关等,我们常会用到这么三个方法\n\n- public void toggleSoftInputFromWindow(android.os.IBinder windowToken, int showFlags, int hideFlags)\n- public boolean hideSoftInputFromWindow(android.os.IBinder windowToken, int flags)\n- public void showSoftInputFromInputMethod(android.os.IBinder token, int flags)   \n\nshowFlags,hideFlags是我们可以传入的参数常量，让我们看看文档里对它们的定义:\n\n    /**\n     * Flag for {@link #showSoftInput} to indicate that this is an implicit\n     * request to show the input window, not as the result of a direct request\n     * by the user.  The window may not be shown in this case.\n     */\n    public static final int SHOW_IMPLICIT = 0x0001;\n\n    /**\n     * Flag for {@link #showSoftInput} to indicate that the user has forced\n     * the input method open (such as by long-pressing menu) so it should\n     * not be closed until they explicitly do so.\n     */\n    public static final int SHOW_FORCED = 0x0002;\n\n\n    /**\n     * Flag for {@link #hideSoftInputFromWindow} to indicate that the soft\n     * input window should only be hidden if it was not explicitly shown\n     * by the user.\n     */\n    public static final int HIDE_IMPLICIT_ONLY = 0x0001;\n\n    /**\n     * Flag for {@link #hideSoftInputFromWindow} to indicate that the soft\n     * input window should normally be hidden, unless it was originally\n     * shown with {@link #SHOW_FORCED}.\n     */\n    public static final int HIDE_NOT_ALWAYS = 0x0002;\n\n可以看出SHOW_IMPLICIT(隐形显示)和HIDE_IMPLICIT_ONLY(隐形隐藏)是相对应的，\n\n1. 假如用户显示时设置flag为SHOW_FORCED(强制显示)，那么当隐藏是设置HIDE_IMPLICIT_ONLY时，软键盘并不会隐藏。\n","slug":"2013-04-04-SoftInputMethod","published":1,"updated":"2018-02-14T21:36:14.829Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tk60000rpfyqw3ou5ew","content":"<p>InputMethodManager主要是用来管理IME的相关操作的，如显示,隐藏,开关等,我们常会用到这么三个方法</p>\n<ul>\n<li>public void toggleSoftInputFromWindow(android.os.IBinder windowToken, int showFlags, int hideFlags)</li>\n<li>public boolean hideSoftInputFromWindow(android.os.IBinder windowToken, int flags)</li>\n<li>public void showSoftInputFromInputMethod(android.os.IBinder token, int flags)   </li>\n</ul>\n<p>showFlags,hideFlags是我们可以传入的参数常量，让我们看看文档里对它们的定义:</p>\n<pre><code>/**\n * Flag for {@link #showSoftInput} to indicate that this is an implicit\n * request to show the input window, not as the result of a direct request\n * by the user.  The window may not be shown in this case.\n */\npublic static final int SHOW_IMPLICIT = 0x0001;\n\n/**\n * Flag for {@link #showSoftInput} to indicate that the user has forced\n * the input method open (such as by long-pressing menu) so it should\n * not be closed until they explicitly do so.\n */\npublic static final int SHOW_FORCED = 0x0002;\n\n\n/**\n * Flag for {@link #hideSoftInputFromWindow} to indicate that the soft\n * input window should only be hidden if it was not explicitly shown\n * by the user.\n */\npublic static final int HIDE_IMPLICIT_ONLY = 0x0001;\n\n/**\n * Flag for {@link #hideSoftInputFromWindow} to indicate that the soft\n * input window should normally be hidden, unless it was originally\n * shown with {@link #SHOW_FORCED}.\n */\npublic static final int HIDE_NOT_ALWAYS = 0x0002;\n</code></pre><p>可以看出SHOW_IMPLICIT(隐形显示)和HIDE_IMPLICIT_ONLY(隐形隐藏)是相对应的，</p>\n<ol>\n<li>假如用户显示时设置flag为SHOW_FORCED(强制显示)，那么当隐藏是设置HIDE_IMPLICIT_ONLY时，软键盘并不会隐藏。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>InputMethodManager主要是用来管理IME的相关操作的，如显示,隐藏,开关等,我们常会用到这么三个方法</p>\n<ul>\n<li>public void toggleSoftInputFromWindow(android.os.IBinder windowToken, int showFlags, int hideFlags)</li>\n<li>public boolean hideSoftInputFromWindow(android.os.IBinder windowToken, int flags)</li>\n<li>public void showSoftInputFromInputMethod(android.os.IBinder token, int flags)   </li>\n</ul>\n<p>showFlags,hideFlags是我们可以传入的参数常量，让我们看看文档里对它们的定义:</p>\n<pre><code>/**\n * Flag for {@link #showSoftInput} to indicate that this is an implicit\n * request to show the input window, not as the result of a direct request\n * by the user.  The window may not be shown in this case.\n */\npublic static final int SHOW_IMPLICIT = 0x0001;\n\n/**\n * Flag for {@link #showSoftInput} to indicate that the user has forced\n * the input method open (such as by long-pressing menu) so it should\n * not be closed until they explicitly do so.\n */\npublic static final int SHOW_FORCED = 0x0002;\n\n\n/**\n * Flag for {@link #hideSoftInputFromWindow} to indicate that the soft\n * input window should only be hidden if it was not explicitly shown\n * by the user.\n */\npublic static final int HIDE_IMPLICIT_ONLY = 0x0001;\n\n/**\n * Flag for {@link #hideSoftInputFromWindow} to indicate that the soft\n * input window should normally be hidden, unless it was originally\n * shown with {@link #SHOW_FORCED}.\n */\npublic static final int HIDE_NOT_ALWAYS = 0x0002;\n</code></pre><p>可以看出SHOW_IMPLICIT(隐形显示)和HIDE_IMPLICIT_ONLY(隐形隐藏)是相对应的，</p>\n<ol>\n<li>假如用户显示时设置flag为SHOW_FORCED(强制显示)，那么当隐藏是设置HIDE_IMPLICIT_ONLY时，软键盘并不会隐藏。</li>\n</ol>\n"},{"date":"2013-05-09T16:00:00.000Z","layout":"post","title":"检测常见的手势 （译文）","_content":"\n一个触摸手势发生在一个用户将一个或多个手指放在触摸屏上，然后你的应用将这些触摸事件(pattern)翻译为一个具体的手势。有两个相应的阶段去作手势检测:\n\n- 收集关于触摸事件的数据.\n- 解释(interperting)这些数据，看它是否符合你的应用程序所支持的手势的标准(criteria).\n\n### 支持包/类\n\n本课程中的示例使用了GestureDetectorCompat 和MotionEventCompat 类.这些类在支持包中.当可能需要在Android 1.6或者更高的系统中使用时，你应该使用支持包。注意，MotionEventCompat <em>不是</em> MotionEvent类的替代版。相反，它提供了多种静态方法 ，为了接收已经结合事件的期望动作，传递你的MotionEvent对象。\n\n### 收集数据\n\n当用户将一个或多个手指放在屏幕上，在可接收触摸事件的视图上触发回调函数 onTouchEvent().对于每个触摸事件序列(位置，压力，大小，另一个手指的添加等),最终确定为一个手势，onTouchEvent()会多次调用(fired)\n\n当用户第一次接触屏幕时，手势开始，系统追踪用户手指的位置，手势也跟着继续，直到捕获用户的手指离开屏幕时结束。始终相互作用，传递(delivered)到onTouchEvent()的MotionEvent提供了每个交互的细节。你的应用可以使用这些提供了MotionEvent的数据去决定是否一个手势动作发生了值得去关注。\n\n### 在Activity或者View中捕获触摸事件\n\n重载onTouchEvent()回调函数，以拦截触摸事件在Activity或者View\n\n以下片段使用了getActionMasked()去提取用户从eventParameter执行的动作。它提供给你原始数据，由你决定是否一个手势是你关心发生的。\n\n```\npublic class MainActivity extends Activity {\n// This example shows an Activity, but you would use the same approach if\n// you were subclassing a View.\n@Override\npublic boolean onTouchEvent(MotionEvent event){\n    int action = MotionEventCompat.getActionMasked(event);\n    switch(action) {\n        case (MotionEvent.ACTION_DOWN) :\n            Log.d(DEBUG_TAG,\"Action was DOWN\");\n            return true;\n        case (MotionEvent.ACTION_MOVE) :\n            Log.d(DEBUG_TAG,\"Action was MOVE\");\n            return true;\n        case (MotionEvent.ACTION_UP) :\n            Log.d(DEBUG_TAG,\"Action was UP\");\n            return true;\n        case (MotionEvent.ACTION_CANCEL) :\n            Log.d(DEBUG_TAG,\"Action was CANCEL\");\n            return true;\n        case (MotionEvent.ACTION_OUTSIDE) :\n            Log.d(DEBUG_TAG,\"Movement occurred outside bounds \" +\n                    \"of current screen element\");\n            return true;      \n        default :\n            return super.onTouchEvent(event);\n    }      \n}\n```\n\n然后你可以做你自己的处理在这些事件上，去决定一个手势是否发生。当你需要做一个定制的手势时，这是必须要做的过程。然而，如果你的应用使用常用的手势如双击，长按，扫等等，你可以使用GestureDetector类的优势。GestureDetector将事情简化，它不需要你自己处理个别的触摸时间就可以检测常见的手势.见讨论[Detect Gestures](http://developer.android.com/training/gestures/detector.html#detect)\n\n###在单个View中捕获触摸事件###\n\n作为OnTouchEvent()的代替，你可以使用setOnTouchListener()方法将一个View.OnTouchListener依附(attach)到任何View对象上去。它使得我们无需子类化一个已经存在的View，而可以去监听触摸事件。例如：\n\n\n```\nView myView = findViewById(R.id.my_view);\nmyView.setOnTouchListener(new OnTouchListener() {\n    public boolean onTouch(View v, MotionEvent event) {\n        // ... Respond to touch events      \n        return true;\n    }\n});\n```\n\n如果你创建了一个监听器，在处理ACTION_DOWN事件后返回 false ，你需要注意了。如果你这么做了，这个监听器将接收不到随后的ACTION_MOVE和ACTION_UP 事件（String of events)。这是因为ACTION_DOWN是所有触摸事件的触发点。\n\n如果你创建了一个定制View，你可以重载onTouchEvent()，如以上讨论的。\n\n###检测手势###\n\n\nAndroid提供了GestureDetector类来检测通用手势，它支持了一些手势在onDown(),onLongPress(),onFling()等方法中。你可以结合OnTouchEvent()使用GestureDetector，如刚才讨论的。\n\n###检测所有支持的手势###\n\n当你实例化一个GestureDetectorCompat对象时，其中一个参数需要实现GestureDetector.OnGestureListener接口。GestureDetector.OnGestureListener通知用户何时一个特定的触摸事件发生。为了使你的GestureDetector对象可以接收事件，你需要重载View或者Activity的OnTouchEvent()方法，然后沿着所有被观察的事件传递到检测实例。\n\n\n接下来的片段中，一个返回true的特定on&lt;TouchEvent&gt;意味着你已经处理了触摸时间。返回false则通过视图栈向下传递事件，直到触摸被成功处理。\n\n执行下面的代码，感受下当你与屏幕互动(interact)时，动作是如何被触发的，以及每个触摸事件中MotionEvent的内容。你将会了解即使是单个交互动作有多少数据生产。\n\n```\npublic class MainActivity extends Activity implements\n        GestureDetector.OnGestureListener,\n        GestureDetector.OnDoubleTapListener{\n    private static final String DEBUG_TAG = \"Gestures\";\n    private GestureDetectorCompat mDetector;\n    // Called when the activity is first created.\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // Instantiate the gesture detector with the\n        // application context and an implementation of\n        // GestureDetector.OnGestureListener\n        mDetector = new GestureDetectorCompat(this,this);\n        // Set the gesture detector as the double tap\n        // listener.\n        mDetector.setOnDoubleTapListener(this);\n    }\n    @Override\n    public boolean onTouchEvent(MotionEvent event){\n        this.mDetector.onTouchEvent(event);\n        // Be sure to call the superclass implementation\n        return super.onTouchEvent(event);\n    }\n    @Override\n    public boolean onDown(MotionEvent event) {\n        Log.d(DEBUG_TAG,\"onDown: \" + event.toString());\n        return true;\n    }\n    @Override\n    public boolean onFling(MotionEvent event1, MotionEvent event2,\n            float velocityX, float velocityY) {\n        Log.d(DEBUG_TAG, \"onFling: \" + event1.toString()+event2.toString());\n        return true;\n    }\n    @Override\n    public void onLongPress(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onLongPress: \" + event.toString());\n    }\n    @Override\n    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,\n            float distanceY) {\n        Log.d(DEBUG_TAG, \"onScroll: \" + e1.toString()+e2.toString());\n        return true;\n    }\n    @Override\n    public void onShowPress(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onShowPress: \" + event.toString());\n    }\n    @Override\n    public boolean onSingleTapUp(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onSingleTapUp: \" + event.toString());\n        return true;\n    }\n    @Override\n    public boolean onDoubleTap(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onDoubleTap: \" + event.toString());\n        return true;\n    }\n    @Override\n    public boolean onDoubleTapEvent(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onDoubleTapEvent: \" + event.toString());\n        return true;\n    }\n    @Override\n    public boolean onSingleTapConfirmed(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onSingleTapConfirmed: \" + event.toString());\n        return true;\n    }\n}\n```\n\n### 检测一个被支持手势的子集\n\n\n如果你只是想要处理小部分的手势，你可以继承GestureDetector.SimpleOnGestureListener ，而不是GestureDetector.OnGestureListener接口。\n\n\nGestureDetector.SimpleOnGestureListener 提供所有On&lt;TouchEvent&gt;方法返回false的实现.因此你可以只重载你所关心的方法。例如，接下来的片段创建了一个继承GestureDetector.SimpleOnGestureListener类，重载了OnFling()和OnDown();\n\n\n无论你是否使用GestureDetector.OnGestureListener，这是一个最佳实践(best practice)去实现一个返回true的 onDown()方法。因为所有的手势开始与一个onDown()信息。如果你在onDown()返回false，GestureDetector.SimpleOnGestureListener只做默认动作，系统假定你要忽视手势的剩余部分(rest)，然后GestureDetector.OnGestureListener的其他方法将永远不会被调用。这可能是在你应用中的一个潜在异常(potential)。除非你真的是要忽略手势，你才应该返回false.\n\n```\npublic class MainActivity extends Activity {\n    private GestureDetectorCompat mDetector;\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mDetector = new GestureDetectorCompat(this, new MyGestureListener());\n    }\n    @Override\n    public boolean onTouchEvent(MotionEvent event){\n        this.mDetector.onTouchEvent(event);\n        return super.onTouchEvent(event);\n    }\n    class MyGestureListener extends GestureDetector.SimpleOnGestureListener {\n        private static final String DEBUG_TAG = \"Gestures\";\n        @Override\n        public boolean onDown(MotionEvent event) {\n            Log.d(DEBUG_TAG,\"onDown: \" + event.toString());\n            return true;\n        }\n        @Override\n        public boolean onFling(MotionEvent event1, MotionEvent event2,\n                float velocityX, float velocityY) {\n            Log.d(DEBUG_TAG, \"onFling: \" + event1.toString()+event2.toString());\n            return true;\n        }\n    }\n}\n```\n","source":"_posts/2013-05-10-Detecting-Common-Gestures.md","raw":"---\ncategory: Android\ndate: 2013-05-10\nlayout: post\ntitle: \"检测常见的手势 （译文）\"\n---\n\n一个触摸手势发生在一个用户将一个或多个手指放在触摸屏上，然后你的应用将这些触摸事件(pattern)翻译为一个具体的手势。有两个相应的阶段去作手势检测:\n\n- 收集关于触摸事件的数据.\n- 解释(interperting)这些数据，看它是否符合你的应用程序所支持的手势的标准(criteria).\n\n### 支持包/类\n\n本课程中的示例使用了GestureDetectorCompat 和MotionEventCompat 类.这些类在支持包中.当可能需要在Android 1.6或者更高的系统中使用时，你应该使用支持包。注意，MotionEventCompat <em>不是</em> MotionEvent类的替代版。相反，它提供了多种静态方法 ，为了接收已经结合事件的期望动作，传递你的MotionEvent对象。\n\n### 收集数据\n\n当用户将一个或多个手指放在屏幕上，在可接收触摸事件的视图上触发回调函数 onTouchEvent().对于每个触摸事件序列(位置，压力，大小，另一个手指的添加等),最终确定为一个手势，onTouchEvent()会多次调用(fired)\n\n当用户第一次接触屏幕时，手势开始，系统追踪用户手指的位置，手势也跟着继续，直到捕获用户的手指离开屏幕时结束。始终相互作用，传递(delivered)到onTouchEvent()的MotionEvent提供了每个交互的细节。你的应用可以使用这些提供了MotionEvent的数据去决定是否一个手势动作发生了值得去关注。\n\n### 在Activity或者View中捕获触摸事件\n\n重载onTouchEvent()回调函数，以拦截触摸事件在Activity或者View\n\n以下片段使用了getActionMasked()去提取用户从eventParameter执行的动作。它提供给你原始数据，由你决定是否一个手势是你关心发生的。\n\n```\npublic class MainActivity extends Activity {\n// This example shows an Activity, but you would use the same approach if\n// you were subclassing a View.\n@Override\npublic boolean onTouchEvent(MotionEvent event){\n    int action = MotionEventCompat.getActionMasked(event);\n    switch(action) {\n        case (MotionEvent.ACTION_DOWN) :\n            Log.d(DEBUG_TAG,\"Action was DOWN\");\n            return true;\n        case (MotionEvent.ACTION_MOVE) :\n            Log.d(DEBUG_TAG,\"Action was MOVE\");\n            return true;\n        case (MotionEvent.ACTION_UP) :\n            Log.d(DEBUG_TAG,\"Action was UP\");\n            return true;\n        case (MotionEvent.ACTION_CANCEL) :\n            Log.d(DEBUG_TAG,\"Action was CANCEL\");\n            return true;\n        case (MotionEvent.ACTION_OUTSIDE) :\n            Log.d(DEBUG_TAG,\"Movement occurred outside bounds \" +\n                    \"of current screen element\");\n            return true;      \n        default :\n            return super.onTouchEvent(event);\n    }      \n}\n```\n\n然后你可以做你自己的处理在这些事件上，去决定一个手势是否发生。当你需要做一个定制的手势时，这是必须要做的过程。然而，如果你的应用使用常用的手势如双击，长按，扫等等，你可以使用GestureDetector类的优势。GestureDetector将事情简化，它不需要你自己处理个别的触摸时间就可以检测常见的手势.见讨论[Detect Gestures](http://developer.android.com/training/gestures/detector.html#detect)\n\n###在单个View中捕获触摸事件###\n\n作为OnTouchEvent()的代替，你可以使用setOnTouchListener()方法将一个View.OnTouchListener依附(attach)到任何View对象上去。它使得我们无需子类化一个已经存在的View，而可以去监听触摸事件。例如：\n\n\n```\nView myView = findViewById(R.id.my_view);\nmyView.setOnTouchListener(new OnTouchListener() {\n    public boolean onTouch(View v, MotionEvent event) {\n        // ... Respond to touch events      \n        return true;\n    }\n});\n```\n\n如果你创建了一个监听器，在处理ACTION_DOWN事件后返回 false ，你需要注意了。如果你这么做了，这个监听器将接收不到随后的ACTION_MOVE和ACTION_UP 事件（String of events)。这是因为ACTION_DOWN是所有触摸事件的触发点。\n\n如果你创建了一个定制View，你可以重载onTouchEvent()，如以上讨论的。\n\n###检测手势###\n\n\nAndroid提供了GestureDetector类来检测通用手势，它支持了一些手势在onDown(),onLongPress(),onFling()等方法中。你可以结合OnTouchEvent()使用GestureDetector，如刚才讨论的。\n\n###检测所有支持的手势###\n\n当你实例化一个GestureDetectorCompat对象时，其中一个参数需要实现GestureDetector.OnGestureListener接口。GestureDetector.OnGestureListener通知用户何时一个特定的触摸事件发生。为了使你的GestureDetector对象可以接收事件，你需要重载View或者Activity的OnTouchEvent()方法，然后沿着所有被观察的事件传递到检测实例。\n\n\n接下来的片段中，一个返回true的特定on&lt;TouchEvent&gt;意味着你已经处理了触摸时间。返回false则通过视图栈向下传递事件，直到触摸被成功处理。\n\n执行下面的代码，感受下当你与屏幕互动(interact)时，动作是如何被触发的，以及每个触摸事件中MotionEvent的内容。你将会了解即使是单个交互动作有多少数据生产。\n\n```\npublic class MainActivity extends Activity implements\n        GestureDetector.OnGestureListener,\n        GestureDetector.OnDoubleTapListener{\n    private static final String DEBUG_TAG = \"Gestures\";\n    private GestureDetectorCompat mDetector;\n    // Called when the activity is first created.\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // Instantiate the gesture detector with the\n        // application context and an implementation of\n        // GestureDetector.OnGestureListener\n        mDetector = new GestureDetectorCompat(this,this);\n        // Set the gesture detector as the double tap\n        // listener.\n        mDetector.setOnDoubleTapListener(this);\n    }\n    @Override\n    public boolean onTouchEvent(MotionEvent event){\n        this.mDetector.onTouchEvent(event);\n        // Be sure to call the superclass implementation\n        return super.onTouchEvent(event);\n    }\n    @Override\n    public boolean onDown(MotionEvent event) {\n        Log.d(DEBUG_TAG,\"onDown: \" + event.toString());\n        return true;\n    }\n    @Override\n    public boolean onFling(MotionEvent event1, MotionEvent event2,\n            float velocityX, float velocityY) {\n        Log.d(DEBUG_TAG, \"onFling: \" + event1.toString()+event2.toString());\n        return true;\n    }\n    @Override\n    public void onLongPress(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onLongPress: \" + event.toString());\n    }\n    @Override\n    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,\n            float distanceY) {\n        Log.d(DEBUG_TAG, \"onScroll: \" + e1.toString()+e2.toString());\n        return true;\n    }\n    @Override\n    public void onShowPress(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onShowPress: \" + event.toString());\n    }\n    @Override\n    public boolean onSingleTapUp(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onSingleTapUp: \" + event.toString());\n        return true;\n    }\n    @Override\n    public boolean onDoubleTap(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onDoubleTap: \" + event.toString());\n        return true;\n    }\n    @Override\n    public boolean onDoubleTapEvent(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onDoubleTapEvent: \" + event.toString());\n        return true;\n    }\n    @Override\n    public boolean onSingleTapConfirmed(MotionEvent event) {\n        Log.d(DEBUG_TAG, \"onSingleTapConfirmed: \" + event.toString());\n        return true;\n    }\n}\n```\n\n### 检测一个被支持手势的子集\n\n\n如果你只是想要处理小部分的手势，你可以继承GestureDetector.SimpleOnGestureListener ，而不是GestureDetector.OnGestureListener接口。\n\n\nGestureDetector.SimpleOnGestureListener 提供所有On&lt;TouchEvent&gt;方法返回false的实现.因此你可以只重载你所关心的方法。例如，接下来的片段创建了一个继承GestureDetector.SimpleOnGestureListener类，重载了OnFling()和OnDown();\n\n\n无论你是否使用GestureDetector.OnGestureListener，这是一个最佳实践(best practice)去实现一个返回true的 onDown()方法。因为所有的手势开始与一个onDown()信息。如果你在onDown()返回false，GestureDetector.SimpleOnGestureListener只做默认动作，系统假定你要忽视手势的剩余部分(rest)，然后GestureDetector.OnGestureListener的其他方法将永远不会被调用。这可能是在你应用中的一个潜在异常(potential)。除非你真的是要忽略手势，你才应该返回false.\n\n```\npublic class MainActivity extends Activity {\n    private GestureDetectorCompat mDetector;\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mDetector = new GestureDetectorCompat(this, new MyGestureListener());\n    }\n    @Override\n    public boolean onTouchEvent(MotionEvent event){\n        this.mDetector.onTouchEvent(event);\n        return super.onTouchEvent(event);\n    }\n    class MyGestureListener extends GestureDetector.SimpleOnGestureListener {\n        private static final String DEBUG_TAG = \"Gestures\";\n        @Override\n        public boolean onDown(MotionEvent event) {\n            Log.d(DEBUG_TAG,\"onDown: \" + event.toString());\n            return true;\n        }\n        @Override\n        public boolean onFling(MotionEvent event1, MotionEvent event2,\n                float velocityX, float velocityY) {\n            Log.d(DEBUG_TAG, \"onFling: \" + event1.toString()+event2.toString());\n            return true;\n        }\n    }\n}\n```\n","slug":"2013-05-10-Detecting-Common-Gestures","published":1,"updated":"2018-02-14T21:36:14.829Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tka0001rpfy1id25rs4","content":"<p>一个触摸手势发生在一个用户将一个或多个手指放在触摸屏上，然后你的应用将这些触摸事件(pattern)翻译为一个具体的手势。有两个相应的阶段去作手势检测:</p>\n<ul>\n<li>收集关于触摸事件的数据.</li>\n<li>解释(interperting)这些数据，看它是否符合你的应用程序所支持的手势的标准(criteria).</li>\n</ul>\n<h3 id=\"支持包-类\"><a href=\"#支持包-类\" class=\"headerlink\" title=\"支持包/类\"></a>支持包/类</h3><p>本课程中的示例使用了GestureDetectorCompat 和MotionEventCompat 类.这些类在支持包中.当可能需要在Android 1.6或者更高的系统中使用时，你应该使用支持包。注意，MotionEventCompat <em>不是</em> MotionEvent类的替代版。相反，它提供了多种静态方法 ，为了接收已经结合事件的期望动作，传递你的MotionEvent对象。</p>\n<h3 id=\"收集数据\"><a href=\"#收集数据\" class=\"headerlink\" title=\"收集数据\"></a>收集数据</h3><p>当用户将一个或多个手指放在屏幕上，在可接收触摸事件的视图上触发回调函数 onTouchEvent().对于每个触摸事件序列(位置，压力，大小，另一个手指的添加等),最终确定为一个手势，onTouchEvent()会多次调用(fired)</p>\n<p>当用户第一次接触屏幕时，手势开始，系统追踪用户手指的位置，手势也跟着继续，直到捕获用户的手指离开屏幕时结束。始终相互作用，传递(delivered)到onTouchEvent()的MotionEvent提供了每个交互的细节。你的应用可以使用这些提供了MotionEvent的数据去决定是否一个手势动作发生了值得去关注。</p>\n<h3 id=\"在Activity或者View中捕获触摸事件\"><a href=\"#在Activity或者View中捕获触摸事件\" class=\"headerlink\" title=\"在Activity或者View中捕获触摸事件\"></a>在Activity或者View中捕获触摸事件</h3><p>重载onTouchEvent()回调函数，以拦截触摸事件在Activity或者View</p>\n<p>以下片段使用了getActionMasked()去提取用户从eventParameter执行的动作。它提供给你原始数据，由你决定是否一个手势是你关心发生的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\">// This example shows an Activity, but you would use the same approach if</span><br><span class=\"line\">// you were subclassing a View.</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent event)&#123;</span><br><span class=\"line\">    int action = MotionEventCompat.getActionMasked(event);</span><br><span class=\"line\">    switch(action) &#123;</span><br><span class=\"line\">        case (MotionEvent.ACTION_DOWN) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Action was DOWN&quot;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        case (MotionEvent.ACTION_MOVE) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Action was MOVE&quot;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        case (MotionEvent.ACTION_UP) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Action was UP&quot;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        case (MotionEvent.ACTION_CANCEL) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Action was CANCEL&quot;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        case (MotionEvent.ACTION_OUTSIDE) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Movement occurred outside bounds &quot; +</span><br><span class=\"line\">                    &quot;of current screen element&quot;);</span><br><span class=\"line\">            return true;      </span><br><span class=\"line\">        default :</span><br><span class=\"line\">            return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后你可以做你自己的处理在这些事件上，去决定一个手势是否发生。当你需要做一个定制的手势时，这是必须要做的过程。然而，如果你的应用使用常用的手势如双击，长按，扫等等，你可以使用GestureDetector类的优势。GestureDetector将事情简化，它不需要你自己处理个别的触摸时间就可以检测常见的手势.见讨论<a href=\"http://developer.android.com/training/gestures/detector.html#detect\" target=\"_blank\" rel=\"noopener\">Detect Gestures</a></p>\n<p>###在单个View中捕获触摸事件###</p>\n<p>作为OnTouchEvent()的代替，你可以使用setOnTouchListener()方法将一个View.OnTouchListener依附(attach)到任何View对象上去。它使得我们无需子类化一个已经存在的View，而可以去监听触摸事件。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View myView = findViewById(R.id.my_view);</span><br><span class=\"line\">myView.setOnTouchListener(new OnTouchListener() &#123;</span><br><span class=\"line\">    public boolean onTouch(View v, MotionEvent event) &#123;</span><br><span class=\"line\">        // ... Respond to touch events      </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你创建了一个监听器，在处理ACTION_DOWN事件后返回 false ，你需要注意了。如果你这么做了，这个监听器将接收不到随后的ACTION_MOVE和ACTION_UP 事件（String of events)。这是因为ACTION_DOWN是所有触摸事件的触发点。</p>\n<p>如果你创建了一个定制View，你可以重载onTouchEvent()，如以上讨论的。</p>\n<p>###检测手势###</p>\n<p>Android提供了GestureDetector类来检测通用手势，它支持了一些手势在onDown(),onLongPress(),onFling()等方法中。你可以结合OnTouchEvent()使用GestureDetector，如刚才讨论的。</p>\n<p>###检测所有支持的手势###</p>\n<p>当你实例化一个GestureDetectorCompat对象时，其中一个参数需要实现GestureDetector.OnGestureListener接口。GestureDetector.OnGestureListener通知用户何时一个特定的触摸事件发生。为了使你的GestureDetector对象可以接收事件，你需要重载View或者Activity的OnTouchEvent()方法，然后沿着所有被观察的事件传递到检测实例。</p>\n<p>接下来的片段中，一个返回true的特定on&lt;TouchEvent&gt;意味着你已经处理了触摸时间。返回false则通过视图栈向下传递事件，直到触摸被成功处理。</p>\n<p>执行下面的代码，感受下当你与屏幕互动(interact)时，动作是如何被触发的，以及每个触摸事件中MotionEvent的内容。你将会了解即使是单个交互动作有多少数据生产。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity implements</span><br><span class=\"line\">        GestureDetector.OnGestureListener,</span><br><span class=\"line\">        GestureDetector.OnDoubleTapListener&#123;</span><br><span class=\"line\">    private static final String DEBUG_TAG = &quot;Gestures&quot;;</span><br><span class=\"line\">    private GestureDetectorCompat mDetector;</span><br><span class=\"line\">    // Called when the activity is first created.</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        // Instantiate the gesture detector with the</span><br><span class=\"line\">        // application context and an implementation of</span><br><span class=\"line\">        // GestureDetector.OnGestureListener</span><br><span class=\"line\">        mDetector = new GestureDetectorCompat(this,this);</span><br><span class=\"line\">        // Set the gesture detector as the double tap</span><br><span class=\"line\">        // listener.</span><br><span class=\"line\">        mDetector.setOnDoubleTapListener(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event)&#123;</span><br><span class=\"line\">        this.mDetector.onTouchEvent(event);</span><br><span class=\"line\">        // Be sure to call the superclass implementation</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onDown(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG,&quot;onDown: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onFling(MotionEvent event1, MotionEvent event2,</span><br><span class=\"line\">            float velocityX, float velocityY) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onFling: &quot; + event1.toString()+event2.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLongPress(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onLongPress: &quot; + event.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,</span><br><span class=\"line\">            float distanceY) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onScroll: &quot; + e1.toString()+e2.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onShowPress(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onShowPress: &quot; + event.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onSingleTapUp(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onSingleTapUp: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onDoubleTap(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onDoubleTap: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onDoubleTapEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onDoubleTapEvent: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onSingleTapConfirmed(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onSingleTapConfirmed: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"检测一个被支持手势的子集\"><a href=\"#检测一个被支持手势的子集\" class=\"headerlink\" title=\"检测一个被支持手势的子集\"></a>检测一个被支持手势的子集</h3><p>如果你只是想要处理小部分的手势，你可以继承GestureDetector.SimpleOnGestureListener ，而不是GestureDetector.OnGestureListener接口。</p>\n<p>GestureDetector.SimpleOnGestureListener 提供所有On&lt;TouchEvent&gt;方法返回false的实现.因此你可以只重载你所关心的方法。例如，接下来的片段创建了一个继承GestureDetector.SimpleOnGestureListener类，重载了OnFling()和OnDown();</p>\n<p>无论你是否使用GestureDetector.OnGestureListener，这是一个最佳实践(best practice)去实现一个返回true的 onDown()方法。因为所有的手势开始与一个onDown()信息。如果你在onDown()返回false，GestureDetector.SimpleOnGestureListener只做默认动作，系统假定你要忽视手势的剩余部分(rest)，然后GestureDetector.OnGestureListener的其他方法将永远不会被调用。这可能是在你应用中的一个潜在异常(potential)。除非你真的是要忽略手势，你才应该返回false.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\">    private GestureDetectorCompat mDetector;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        mDetector = new GestureDetectorCompat(this, new MyGestureListener());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event)&#123;</span><br><span class=\"line\">        this.mDetector.onTouchEvent(event);</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    class MyGestureListener extends GestureDetector.SimpleOnGestureListener &#123;</span><br><span class=\"line\">        private static final String DEBUG_TAG = &quot;Gestures&quot;;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public boolean onDown(MotionEvent event) &#123;</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;onDown: &quot; + event.toString());</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public boolean onFling(MotionEvent event1, MotionEvent event2,</span><br><span class=\"line\">                float velocityX, float velocityY) &#123;</span><br><span class=\"line\">            Log.d(DEBUG_TAG, &quot;onFling: &quot; + event1.toString()+event2.toString());</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>一个触摸手势发生在一个用户将一个或多个手指放在触摸屏上，然后你的应用将这些触摸事件(pattern)翻译为一个具体的手势。有两个相应的阶段去作手势检测:</p>\n<ul>\n<li>收集关于触摸事件的数据.</li>\n<li>解释(interperting)这些数据，看它是否符合你的应用程序所支持的手势的标准(criteria).</li>\n</ul>\n<h3 id=\"支持包-类\"><a href=\"#支持包-类\" class=\"headerlink\" title=\"支持包/类\"></a>支持包/类</h3><p>本课程中的示例使用了GestureDetectorCompat 和MotionEventCompat 类.这些类在支持包中.当可能需要在Android 1.6或者更高的系统中使用时，你应该使用支持包。注意，MotionEventCompat <em>不是</em> MotionEvent类的替代版。相反，它提供了多种静态方法 ，为了接收已经结合事件的期望动作，传递你的MotionEvent对象。</p>\n<h3 id=\"收集数据\"><a href=\"#收集数据\" class=\"headerlink\" title=\"收集数据\"></a>收集数据</h3><p>当用户将一个或多个手指放在屏幕上，在可接收触摸事件的视图上触发回调函数 onTouchEvent().对于每个触摸事件序列(位置，压力，大小，另一个手指的添加等),最终确定为一个手势，onTouchEvent()会多次调用(fired)</p>\n<p>当用户第一次接触屏幕时，手势开始，系统追踪用户手指的位置，手势也跟着继续，直到捕获用户的手指离开屏幕时结束。始终相互作用，传递(delivered)到onTouchEvent()的MotionEvent提供了每个交互的细节。你的应用可以使用这些提供了MotionEvent的数据去决定是否一个手势动作发生了值得去关注。</p>\n<h3 id=\"在Activity或者View中捕获触摸事件\"><a href=\"#在Activity或者View中捕获触摸事件\" class=\"headerlink\" title=\"在Activity或者View中捕获触摸事件\"></a>在Activity或者View中捕获触摸事件</h3><p>重载onTouchEvent()回调函数，以拦截触摸事件在Activity或者View</p>\n<p>以下片段使用了getActionMasked()去提取用户从eventParameter执行的动作。它提供给你原始数据，由你决定是否一个手势是你关心发生的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\">// This example shows an Activity, but you would use the same approach if</span><br><span class=\"line\">// you were subclassing a View.</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent event)&#123;</span><br><span class=\"line\">    int action = MotionEventCompat.getActionMasked(event);</span><br><span class=\"line\">    switch(action) &#123;</span><br><span class=\"line\">        case (MotionEvent.ACTION_DOWN) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Action was DOWN&quot;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        case (MotionEvent.ACTION_MOVE) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Action was MOVE&quot;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        case (MotionEvent.ACTION_UP) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Action was UP&quot;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        case (MotionEvent.ACTION_CANCEL) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Action was CANCEL&quot;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        case (MotionEvent.ACTION_OUTSIDE) :</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;Movement occurred outside bounds &quot; +</span><br><span class=\"line\">                    &quot;of current screen element&quot;);</span><br><span class=\"line\">            return true;      </span><br><span class=\"line\">        default :</span><br><span class=\"line\">            return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后你可以做你自己的处理在这些事件上，去决定一个手势是否发生。当你需要做一个定制的手势时，这是必须要做的过程。然而，如果你的应用使用常用的手势如双击，长按，扫等等，你可以使用GestureDetector类的优势。GestureDetector将事情简化，它不需要你自己处理个别的触摸时间就可以检测常见的手势.见讨论<a href=\"http://developer.android.com/training/gestures/detector.html#detect\" target=\"_blank\" rel=\"noopener\">Detect Gestures</a></p>\n<p>###在单个View中捕获触摸事件###</p>\n<p>作为OnTouchEvent()的代替，你可以使用setOnTouchListener()方法将一个View.OnTouchListener依附(attach)到任何View对象上去。它使得我们无需子类化一个已经存在的View，而可以去监听触摸事件。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View myView = findViewById(R.id.my_view);</span><br><span class=\"line\">myView.setOnTouchListener(new OnTouchListener() &#123;</span><br><span class=\"line\">    public boolean onTouch(View v, MotionEvent event) &#123;</span><br><span class=\"line\">        // ... Respond to touch events      </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你创建了一个监听器，在处理ACTION_DOWN事件后返回 false ，你需要注意了。如果你这么做了，这个监听器将接收不到随后的ACTION_MOVE和ACTION_UP 事件（String of events)。这是因为ACTION_DOWN是所有触摸事件的触发点。</p>\n<p>如果你创建了一个定制View，你可以重载onTouchEvent()，如以上讨论的。</p>\n<p>###检测手势###</p>\n<p>Android提供了GestureDetector类来检测通用手势，它支持了一些手势在onDown(),onLongPress(),onFling()等方法中。你可以结合OnTouchEvent()使用GestureDetector，如刚才讨论的。</p>\n<p>###检测所有支持的手势###</p>\n<p>当你实例化一个GestureDetectorCompat对象时，其中一个参数需要实现GestureDetector.OnGestureListener接口。GestureDetector.OnGestureListener通知用户何时一个特定的触摸事件发生。为了使你的GestureDetector对象可以接收事件，你需要重载View或者Activity的OnTouchEvent()方法，然后沿着所有被观察的事件传递到检测实例。</p>\n<p>接下来的片段中，一个返回true的特定on&lt;TouchEvent&gt;意味着你已经处理了触摸时间。返回false则通过视图栈向下传递事件，直到触摸被成功处理。</p>\n<p>执行下面的代码，感受下当你与屏幕互动(interact)时，动作是如何被触发的，以及每个触摸事件中MotionEvent的内容。你将会了解即使是单个交互动作有多少数据生产。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity implements</span><br><span class=\"line\">        GestureDetector.OnGestureListener,</span><br><span class=\"line\">        GestureDetector.OnDoubleTapListener&#123;</span><br><span class=\"line\">    private static final String DEBUG_TAG = &quot;Gestures&quot;;</span><br><span class=\"line\">    private GestureDetectorCompat mDetector;</span><br><span class=\"line\">    // Called when the activity is first created.</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        // Instantiate the gesture detector with the</span><br><span class=\"line\">        // application context and an implementation of</span><br><span class=\"line\">        // GestureDetector.OnGestureListener</span><br><span class=\"line\">        mDetector = new GestureDetectorCompat(this,this);</span><br><span class=\"line\">        // Set the gesture detector as the double tap</span><br><span class=\"line\">        // listener.</span><br><span class=\"line\">        mDetector.setOnDoubleTapListener(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event)&#123;</span><br><span class=\"line\">        this.mDetector.onTouchEvent(event);</span><br><span class=\"line\">        // Be sure to call the superclass implementation</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onDown(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG,&quot;onDown: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onFling(MotionEvent event1, MotionEvent event2,</span><br><span class=\"line\">            float velocityX, float velocityY) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onFling: &quot; + event1.toString()+event2.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLongPress(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onLongPress: &quot; + event.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,</span><br><span class=\"line\">            float distanceY) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onScroll: &quot; + e1.toString()+e2.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onShowPress(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onShowPress: &quot; + event.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onSingleTapUp(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onSingleTapUp: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onDoubleTap(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onDoubleTap: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onDoubleTapEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onDoubleTapEvent: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onSingleTapConfirmed(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.d(DEBUG_TAG, &quot;onSingleTapConfirmed: &quot; + event.toString());</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"检测一个被支持手势的子集\"><a href=\"#检测一个被支持手势的子集\" class=\"headerlink\" title=\"检测一个被支持手势的子集\"></a>检测一个被支持手势的子集</h3><p>如果你只是想要处理小部分的手势，你可以继承GestureDetector.SimpleOnGestureListener ，而不是GestureDetector.OnGestureListener接口。</p>\n<p>GestureDetector.SimpleOnGestureListener 提供所有On&lt;TouchEvent&gt;方法返回false的实现.因此你可以只重载你所关心的方法。例如，接下来的片段创建了一个继承GestureDetector.SimpleOnGestureListener类，重载了OnFling()和OnDown();</p>\n<p>无论你是否使用GestureDetector.OnGestureListener，这是一个最佳实践(best practice)去实现一个返回true的 onDown()方法。因为所有的手势开始与一个onDown()信息。如果你在onDown()返回false，GestureDetector.SimpleOnGestureListener只做默认动作，系统假定你要忽视手势的剩余部分(rest)，然后GestureDetector.OnGestureListener的其他方法将永远不会被调用。这可能是在你应用中的一个潜在异常(potential)。除非你真的是要忽略手势，你才应该返回false.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\">    private GestureDetectorCompat mDetector;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        mDetector = new GestureDetectorCompat(this, new MyGestureListener());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event)&#123;</span><br><span class=\"line\">        this.mDetector.onTouchEvent(event);</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    class MyGestureListener extends GestureDetector.SimpleOnGestureListener &#123;</span><br><span class=\"line\">        private static final String DEBUG_TAG = &quot;Gestures&quot;;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public boolean onDown(MotionEvent event) &#123;</span><br><span class=\"line\">            Log.d(DEBUG_TAG,&quot;onDown: &quot; + event.toString());</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public boolean onFling(MotionEvent event1, MotionEvent event2,</span><br><span class=\"line\">                float velocityX, float velocityY) &#123;</span><br><span class=\"line\">            Log.d(DEBUG_TAG, &quot;onFling: &quot; + event1.toString()+event2.toString());</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"date":"2013-05-09T16:00:00.000Z","layout":"post","title":"ACTION_MASK 是用来干嘛的？","_content":"\n我们经常可以看到这样的代码\n\n```\nint action=event.getAction();\nswitch(action&MotionEvent.ACTION_MASK){\n    // balabala\n}\n```\n\n从字面上理解，即为动作与上动作掩码.看下这些常量的值\n\n```\nACTION_MASK             0x000000ff\nACTION_DOWN             0x00000000\nACTION_UP               0x00000001  \nACTION_MOVE             0x00000002\nACTION_POINTER_DOWN     0x00000005\nACTION_POINTER_UP       0x00000006\nACTION_POINTER_1_DOWN   0x00000005            \nACTION_POINTER_1_UP     0x00000006   \nACTION_POINTER_2_DOWN   0x00000105   \nACTION_POINTER_2_UP     0x00000106\nACTION_POINTER_3_DOWN   0x00000205           \nACTION_POINTER_3_UP     0x00000206\n```\n\n我们发现单指DOWN/UP分别为 0x005和0x006,\n而双值和三指DOWN/UP分别为 0x105和0x106,0x205和0x206\n\n假设当前触摸动作为ACTION_POINTER_2_DOWN时，\n\n```\nint action=0x105;\nint maskAction=0x0ff&0x105; //  maskAction=0x005;\n```\n\n如此，触摸动作含义改变为ACTION_POINTER_DOWN\n\n总结，Android在很多需要性能的地方都采用了这种传入int类型，再加掩码操作。如onMeasure。\n","source":"_posts/2013-05-10-action_mask.md","raw":"---\ncategory: Android\ndate: 2013-05-10\nlayout: post\ntitle: ACTION_MASK 是用来干嘛的？\n---\n\n我们经常可以看到这样的代码\n\n```\nint action=event.getAction();\nswitch(action&MotionEvent.ACTION_MASK){\n    // balabala\n}\n```\n\n从字面上理解，即为动作与上动作掩码.看下这些常量的值\n\n```\nACTION_MASK             0x000000ff\nACTION_DOWN             0x00000000\nACTION_UP               0x00000001  \nACTION_MOVE             0x00000002\nACTION_POINTER_DOWN     0x00000005\nACTION_POINTER_UP       0x00000006\nACTION_POINTER_1_DOWN   0x00000005            \nACTION_POINTER_1_UP     0x00000006   \nACTION_POINTER_2_DOWN   0x00000105   \nACTION_POINTER_2_UP     0x00000106\nACTION_POINTER_3_DOWN   0x00000205           \nACTION_POINTER_3_UP     0x00000206\n```\n\n我们发现单指DOWN/UP分别为 0x005和0x006,\n而双值和三指DOWN/UP分别为 0x105和0x106,0x205和0x206\n\n假设当前触摸动作为ACTION_POINTER_2_DOWN时，\n\n```\nint action=0x105;\nint maskAction=0x0ff&0x105; //  maskAction=0x005;\n```\n\n如此，触摸动作含义改变为ACTION_POINTER_DOWN\n\n总结，Android在很多需要性能的地方都采用了这种传入int类型，再加掩码操作。如onMeasure。\n","slug":"2013-05-10-action_mask","published":1,"updated":"2018-02-14T21:36:14.830Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tke0003rpfy18rlefda","content":"<p>我们经常可以看到这样的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int action=event.getAction();</span><br><span class=\"line\">switch(action&amp;MotionEvent.ACTION_MASK)&#123;</span><br><span class=\"line\">    // balabala</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从字面上理解，即为动作与上动作掩码.看下这些常量的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACTION_MASK             0x000000ff</span><br><span class=\"line\">ACTION_DOWN             0x00000000</span><br><span class=\"line\">ACTION_UP               0x00000001  </span><br><span class=\"line\">ACTION_MOVE             0x00000002</span><br><span class=\"line\">ACTION_POINTER_DOWN     0x00000005</span><br><span class=\"line\">ACTION_POINTER_UP       0x00000006</span><br><span class=\"line\">ACTION_POINTER_1_DOWN   0x00000005            </span><br><span class=\"line\">ACTION_POINTER_1_UP     0x00000006   </span><br><span class=\"line\">ACTION_POINTER_2_DOWN   0x00000105   </span><br><span class=\"line\">ACTION_POINTER_2_UP     0x00000106</span><br><span class=\"line\">ACTION_POINTER_3_DOWN   0x00000205           </span><br><span class=\"line\">ACTION_POINTER_3_UP     0x00000206</span><br></pre></td></tr></table></figure>\n<p>我们发现单指DOWN/UP分别为 0x005和0x006,<br>而双值和三指DOWN/UP分别为 0x105和0x106,0x205和0x206</p>\n<p>假设当前触摸动作为ACTION_POINTER_2_DOWN时，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int action=0x105;</span><br><span class=\"line\">int maskAction=0x0ff&amp;0x105; //  maskAction=0x005;</span><br></pre></td></tr></table></figure>\n<p>如此，触摸动作含义改变为ACTION_POINTER_DOWN</p>\n<p>总结，Android在很多需要性能的地方都采用了这种传入int类型，再加掩码操作。如onMeasure。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们经常可以看到这样的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int action=event.getAction();</span><br><span class=\"line\">switch(action&amp;MotionEvent.ACTION_MASK)&#123;</span><br><span class=\"line\">    // balabala</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从字面上理解，即为动作与上动作掩码.看下这些常量的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACTION_MASK             0x000000ff</span><br><span class=\"line\">ACTION_DOWN             0x00000000</span><br><span class=\"line\">ACTION_UP               0x00000001  </span><br><span class=\"line\">ACTION_MOVE             0x00000002</span><br><span class=\"line\">ACTION_POINTER_DOWN     0x00000005</span><br><span class=\"line\">ACTION_POINTER_UP       0x00000006</span><br><span class=\"line\">ACTION_POINTER_1_DOWN   0x00000005            </span><br><span class=\"line\">ACTION_POINTER_1_UP     0x00000006   </span><br><span class=\"line\">ACTION_POINTER_2_DOWN   0x00000105   </span><br><span class=\"line\">ACTION_POINTER_2_UP     0x00000106</span><br><span class=\"line\">ACTION_POINTER_3_DOWN   0x00000205           </span><br><span class=\"line\">ACTION_POINTER_3_UP     0x00000206</span><br></pre></td></tr></table></figure>\n<p>我们发现单指DOWN/UP分别为 0x005和0x006,<br>而双值和三指DOWN/UP分别为 0x105和0x106,0x205和0x206</p>\n<p>假设当前触摸动作为ACTION_POINTER_2_DOWN时，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int action=0x105;</span><br><span class=\"line\">int maskAction=0x0ff&amp;0x105; //  maskAction=0x005;</span><br></pre></td></tr></table></figure>\n<p>如此，触摸动作含义改变为ACTION_POINTER_DOWN</p>\n<p>总结，Android在很多需要性能的地方都采用了这种传入int类型，再加掩码操作。如onMeasure。</p>\n"},{"date":"2013-05-09T16:00:00.000Z","layout":"post","title":"当ViewPager嵌套在ScrollView/ListView里时，手势冲突如何处理？","_content":"\n有时我们需要将ViewPager嵌套在其他已经含有手势动作的ViewGroup里,如ScrollView,ListView时，会造成手势冲突，如表现为ViewPager向左划时，不小心向上移动了一点距离，ViewPager立刻回弹到原始位置。\n\n主要问题出在ScrollView/ListView作为ViewPager的ParentView，会先接受到触摸信息，而且他们对上下滑动是会做出拦截动作，并接管触摸信息的向下传递，导致ViewPager滑动异常。\n先看一种[解决方式](http://justwyy.iteye.com/blog/1567390):\n\n```\npublic class ScrollViewExtend extends ScrollView {  \n    private float xDistance, yDistance, xLast, yLast;  \n    public ScrollViewExtend(Context context, AttributeSet attrs) {  \n        super(context, attrs);  \n    }  \n    @Override  \n    public boolean onInterceptTouchEvent(MotionEvent ev) {  \n        switch (ev.getAction()) {  \n            case MotionEvent.ACTION_DOWN:  \n                xDistance = yDistance = 0f;  \n                xLast = ev.getX();  \n                yLast = ev.getY();  \n                break;  \n            case MotionEvent.ACTION_MOVE:  \n                final float curX = ev.getX();  \n                final float curY = ev.getY();             \n                xDistance += Math.abs(curX - xLast);  \n                yDistance += Math.abs(curY - yLast);  \n                xLast = curX;  \n                yLast = curY;  \n                if(xDistance > yDistance){  \n                    return false;  \n                }    \n        }  \n        return super.onInterceptTouchEvent(ev);  \n    }  \n}   \n```\n\n这种方式的确可以解决这个问题，但是其实Google已经提供了一个函数来解决ParentView与ChildView手势冲突的问题。\n\n```\npublic void requestDisallowInterceptTouchEvent(boolean disallowIntercept)\n```\n\n由ViewPager在OnTouch/onInterceptTouchEvent，dispatchTouchEvent中调用即可。\n","source":"_posts/2013-05-10-intercept-touchevent.md","raw":"---\ncategory: Android\ndate: 2013-05-10\nlayout: post\ntitle: 当ViewPager嵌套在ScrollView/ListView里时，手势冲突如何处理？\n---\n\n有时我们需要将ViewPager嵌套在其他已经含有手势动作的ViewGroup里,如ScrollView,ListView时，会造成手势冲突，如表现为ViewPager向左划时，不小心向上移动了一点距离，ViewPager立刻回弹到原始位置。\n\n主要问题出在ScrollView/ListView作为ViewPager的ParentView，会先接受到触摸信息，而且他们对上下滑动是会做出拦截动作，并接管触摸信息的向下传递，导致ViewPager滑动异常。\n先看一种[解决方式](http://justwyy.iteye.com/blog/1567390):\n\n```\npublic class ScrollViewExtend extends ScrollView {  \n    private float xDistance, yDistance, xLast, yLast;  \n    public ScrollViewExtend(Context context, AttributeSet attrs) {  \n        super(context, attrs);  \n    }  \n    @Override  \n    public boolean onInterceptTouchEvent(MotionEvent ev) {  \n        switch (ev.getAction()) {  \n            case MotionEvent.ACTION_DOWN:  \n                xDistance = yDistance = 0f;  \n                xLast = ev.getX();  \n                yLast = ev.getY();  \n                break;  \n            case MotionEvent.ACTION_MOVE:  \n                final float curX = ev.getX();  \n                final float curY = ev.getY();             \n                xDistance += Math.abs(curX - xLast);  \n                yDistance += Math.abs(curY - yLast);  \n                xLast = curX;  \n                yLast = curY;  \n                if(xDistance > yDistance){  \n                    return false;  \n                }    \n        }  \n        return super.onInterceptTouchEvent(ev);  \n    }  \n}   \n```\n\n这种方式的确可以解决这个问题，但是其实Google已经提供了一个函数来解决ParentView与ChildView手势冲突的问题。\n\n```\npublic void requestDisallowInterceptTouchEvent(boolean disallowIntercept)\n```\n\n由ViewPager在OnTouch/onInterceptTouchEvent，dispatchTouchEvent中调用即可。\n","slug":"2013-05-10-intercept-touchevent","published":1,"updated":"2018-02-14T21:36:14.830Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tkf0004rpfye0szkrdy","content":"<p>有时我们需要将ViewPager嵌套在其他已经含有手势动作的ViewGroup里,如ScrollView,ListView时，会造成手势冲突，如表现为ViewPager向左划时，不小心向上移动了一点距离，ViewPager立刻回弹到原始位置。</p>\n<p>主要问题出在ScrollView/ListView作为ViewPager的ParentView，会先接受到触摸信息，而且他们对上下滑动是会做出拦截动作，并接管触摸信息的向下传递，导致ViewPager滑动异常。<br>先看一种<a href=\"http://justwyy.iteye.com/blog/1567390\" target=\"_blank\" rel=\"noopener\">解决方式</a>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ScrollViewExtend extends ScrollView &#123;  </span><br><span class=\"line\">    private float xDistance, yDistance, xLast, yLast;  </span><br><span class=\"line\">    public ScrollViewExtend(Context context, AttributeSet attrs) &#123;  </span><br><span class=\"line\">        super(context, attrs);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;  </span><br><span class=\"line\">        switch (ev.getAction()) &#123;  </span><br><span class=\"line\">            case MotionEvent.ACTION_DOWN:  </span><br><span class=\"line\">                xDistance = yDistance = 0f;  </span><br><span class=\"line\">                xLast = ev.getX();  </span><br><span class=\"line\">                yLast = ev.getY();  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_MOVE:  </span><br><span class=\"line\">                final float curX = ev.getX();  </span><br><span class=\"line\">                final float curY = ev.getY();             </span><br><span class=\"line\">                xDistance += Math.abs(curX - xLast);  </span><br><span class=\"line\">                yDistance += Math.abs(curY - yLast);  </span><br><span class=\"line\">                xLast = curX;  </span><br><span class=\"line\">                yLast = curY;  </span><br><span class=\"line\">                if(xDistance &gt; yDistance)&#123;  </span><br><span class=\"line\">                    return false;  </span><br><span class=\"line\">                &#125;    </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        return super.onInterceptTouchEvent(ev);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式的确可以解决这个问题，但是其实Google已经提供了一个函数来解决ParentView与ChildView手势冲突的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)</span><br></pre></td></tr></table></figure>\n<p>由ViewPager在OnTouch/onInterceptTouchEvent，dispatchTouchEvent中调用即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>有时我们需要将ViewPager嵌套在其他已经含有手势动作的ViewGroup里,如ScrollView,ListView时，会造成手势冲突，如表现为ViewPager向左划时，不小心向上移动了一点距离，ViewPager立刻回弹到原始位置。</p>\n<p>主要问题出在ScrollView/ListView作为ViewPager的ParentView，会先接受到触摸信息，而且他们对上下滑动是会做出拦截动作，并接管触摸信息的向下传递，导致ViewPager滑动异常。<br>先看一种<a href=\"http://justwyy.iteye.com/blog/1567390\" target=\"_blank\" rel=\"noopener\">解决方式</a>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ScrollViewExtend extends ScrollView &#123;  </span><br><span class=\"line\">    private float xDistance, yDistance, xLast, yLast;  </span><br><span class=\"line\">    public ScrollViewExtend(Context context, AttributeSet attrs) &#123;  </span><br><span class=\"line\">        super(context, attrs);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;  </span><br><span class=\"line\">        switch (ev.getAction()) &#123;  </span><br><span class=\"line\">            case MotionEvent.ACTION_DOWN:  </span><br><span class=\"line\">                xDistance = yDistance = 0f;  </span><br><span class=\"line\">                xLast = ev.getX();  </span><br><span class=\"line\">                yLast = ev.getY();  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            case MotionEvent.ACTION_MOVE:  </span><br><span class=\"line\">                final float curX = ev.getX();  </span><br><span class=\"line\">                final float curY = ev.getY();             </span><br><span class=\"line\">                xDistance += Math.abs(curX - xLast);  </span><br><span class=\"line\">                yDistance += Math.abs(curY - yLast);  </span><br><span class=\"line\">                xLast = curX;  </span><br><span class=\"line\">                yLast = curY;  </span><br><span class=\"line\">                if(xDistance &gt; yDistance)&#123;  </span><br><span class=\"line\">                    return false;  </span><br><span class=\"line\">                &#125;    </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        return super.onInterceptTouchEvent(ev);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式的确可以解决这个问题，但是其实Google已经提供了一个函数来解决ParentView与ChildView手势冲突的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)</span><br></pre></td></tr></table></figure>\n<p>由ViewPager在OnTouch/onInterceptTouchEvent，dispatchTouchEvent中调用即可。</p>\n"},{"date":"2013-05-09T16:00:00.000Z","layout":"post","title":"追踪运动 (译文)","_content":"\n[源链接](http://developer.android.com/training/gestures/movement.html)\n\n本课程将讨论如何在触摸事件中追踪运动\n\n一个新的onTouchEvent()是被一个ACTION_MOVE事件触发的，无论何时当前触摸包含位置，压力，或者大小改变。如在Detecting Common Gestures中讨论的，所有的事件被记录在onTouchEvent()中的MotionEvent参数中.\n\n因为基于手指的触摸不总是精致的交互形式，检测触摸事件经常基于运动而不是单个触点。为了帮助应用区分(distingush)基于运动的手势（如 swipe）和非移动手势（如单击) ,Android包含了“touch slop”概念。Touch slop指的是在这个手势被解释为一个运动手势前， 用户触摸的像素距离。更多的这个主题的讨论，见 Managing Touch Events in a ViewGroup。\n\n有不同方式去追踪手势运动，取决与你的应用需要，如：\n\n- 一个目标的开始与结束（如，移动一个在屏幕上的物体，从点A到点B)\n- 目标点正运行的方向，通过x和y坐标的方向决定\n- History，你可以通过调用MotionEvent的getHistorySize()方法，找到一个手势的History信息。你可以通过MotionEvent的 getHistorical&lt;Value&gt;方法获得每个History事件的位置，大小，时间，压力。History信息对于渲染用户手指的路径(trail)十分有效，如为触摸绘画.参考更多细节MotionEvent。\n- 目标移过触摸屏幕的速度。\n\n\n###跟踪速度\n\n你可以获得一个简单的基于距离和(或)目标移动方向的运动手势，但是速度通常是在追踪手势特性甚至决定是否一个手势发生的决定性因素 。为了使计算速度更简单，Android提供了VelocityTracker类和VelocityTrackerCompat类在支持包中。VolocityTracker 帮助你追踪触摸事件的速度。对于某些将速度作为部分标准的手势，如扫，这是十分有用的。\n\n以下这个示例，说明了VelocityTrackerAPI中的方法目的。\n\n```\npublic class MainActivity extends Activity {\n    private static final String DEBUG_TAG = \"Velocity\";\n        ...\n    private VelocityTracker mVelocityTracker = null;\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        int index = event.getActionIndex();\n        int action = event.getActionMasked();\n        int pointerId = event.getPointerId(index);\n        switch(action) {\n            case MotionEvent.ACTION_DOWN:\n                if(mVelocityTracker == null) {\n                    // Retrieve a new VelocityTracker object to watch the velocity of a motion.\n                    mVelocityTracker = VelocityTracker.obtain();\n                }\n                else {\n                    // Reset the velocity tracker back to its initial state.\n                    mVelocityTracker.clear();\n                }\n                // Add a user's movement to the tracker.\n                mVelocityTracker.addMovement(event);\n                break;\n            case MotionEvent.ACTION_MOVE:\n                mVelocityTracker.addMovement(event);\n                // When you want to determine the velocity, call\n                // computeCurrentVelocity(). Then call getXVelocity()\n                // and getYVelocity() to retrieve the velocity for each pointer ID.\n                mVelocityTracker.computeCurrentVelocity(1000);\n                // Log velocity of pixels per second\n                // Best practice to use VelocityTrackerCompat where possible.\n                Log.d(\"\", \"X velocity: \" +\n                        VelocityTrackerCompat.getXVelocity(mVelocityTracker,\n                        pointerId));\n                Log.d(\"\", \"Y velocity: \" +\n                        VelocityTrackerCompat.getYVelocity(mVelocityTracker,\n                        pointerId));\n                break;\n            case MotionEvent.ACTION_UP:\n            case MotionEvent.ACTION_CANCEL:\n                // Return a VelocityTracker object back to be re-used by others.\n                mVelocityTracker.recycle();\n                break;\n        }\n        return true;\n    }\n}\n```\n\n**注意：**你需要在ACTION_MOVE事件后计算速度，而不是ACTION_UP.如果你ACTION_UP后计算，X和Y速度将是0\n","source":"_posts/2013-05-10-movement.md","raw":"---\ncategory: Android\ndate: 2013-05-10\nlayout: post\ntitle: 追踪运动 (译文)\n---\n\n[源链接](http://developer.android.com/training/gestures/movement.html)\n\n本课程将讨论如何在触摸事件中追踪运动\n\n一个新的onTouchEvent()是被一个ACTION_MOVE事件触发的，无论何时当前触摸包含位置，压力，或者大小改变。如在Detecting Common Gestures中讨论的，所有的事件被记录在onTouchEvent()中的MotionEvent参数中.\n\n因为基于手指的触摸不总是精致的交互形式，检测触摸事件经常基于运动而不是单个触点。为了帮助应用区分(distingush)基于运动的手势（如 swipe）和非移动手势（如单击) ,Android包含了“touch slop”概念。Touch slop指的是在这个手势被解释为一个运动手势前， 用户触摸的像素距离。更多的这个主题的讨论，见 Managing Touch Events in a ViewGroup。\n\n有不同方式去追踪手势运动，取决与你的应用需要，如：\n\n- 一个目标的开始与结束（如，移动一个在屏幕上的物体，从点A到点B)\n- 目标点正运行的方向，通过x和y坐标的方向决定\n- History，你可以通过调用MotionEvent的getHistorySize()方法，找到一个手势的History信息。你可以通过MotionEvent的 getHistorical&lt;Value&gt;方法获得每个History事件的位置，大小，时间，压力。History信息对于渲染用户手指的路径(trail)十分有效，如为触摸绘画.参考更多细节MotionEvent。\n- 目标移过触摸屏幕的速度。\n\n\n###跟踪速度\n\n你可以获得一个简单的基于距离和(或)目标移动方向的运动手势，但是速度通常是在追踪手势特性甚至决定是否一个手势发生的决定性因素 。为了使计算速度更简单，Android提供了VelocityTracker类和VelocityTrackerCompat类在支持包中。VolocityTracker 帮助你追踪触摸事件的速度。对于某些将速度作为部分标准的手势，如扫，这是十分有用的。\n\n以下这个示例，说明了VelocityTrackerAPI中的方法目的。\n\n```\npublic class MainActivity extends Activity {\n    private static final String DEBUG_TAG = \"Velocity\";\n        ...\n    private VelocityTracker mVelocityTracker = null;\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        int index = event.getActionIndex();\n        int action = event.getActionMasked();\n        int pointerId = event.getPointerId(index);\n        switch(action) {\n            case MotionEvent.ACTION_DOWN:\n                if(mVelocityTracker == null) {\n                    // Retrieve a new VelocityTracker object to watch the velocity of a motion.\n                    mVelocityTracker = VelocityTracker.obtain();\n                }\n                else {\n                    // Reset the velocity tracker back to its initial state.\n                    mVelocityTracker.clear();\n                }\n                // Add a user's movement to the tracker.\n                mVelocityTracker.addMovement(event);\n                break;\n            case MotionEvent.ACTION_MOVE:\n                mVelocityTracker.addMovement(event);\n                // When you want to determine the velocity, call\n                // computeCurrentVelocity(). Then call getXVelocity()\n                // and getYVelocity() to retrieve the velocity for each pointer ID.\n                mVelocityTracker.computeCurrentVelocity(1000);\n                // Log velocity of pixels per second\n                // Best practice to use VelocityTrackerCompat where possible.\n                Log.d(\"\", \"X velocity: \" +\n                        VelocityTrackerCompat.getXVelocity(mVelocityTracker,\n                        pointerId));\n                Log.d(\"\", \"Y velocity: \" +\n                        VelocityTrackerCompat.getYVelocity(mVelocityTracker,\n                        pointerId));\n                break;\n            case MotionEvent.ACTION_UP:\n            case MotionEvent.ACTION_CANCEL:\n                // Return a VelocityTracker object back to be re-used by others.\n                mVelocityTracker.recycle();\n                break;\n        }\n        return true;\n    }\n}\n```\n\n**注意：**你需要在ACTION_MOVE事件后计算速度，而不是ACTION_UP.如果你ACTION_UP后计算，X和Y速度将是0\n","slug":"2013-05-10-movement","published":1,"updated":"2018-02-14T21:36:14.830Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tkh0005rpfya34r51vj","content":"<p><a href=\"http://developer.android.com/training/gestures/movement.html\" target=\"_blank\" rel=\"noopener\">源链接</a></p>\n<p>本课程将讨论如何在触摸事件中追踪运动</p>\n<p>一个新的onTouchEvent()是被一个ACTION_MOVE事件触发的，无论何时当前触摸包含位置，压力，或者大小改变。如在Detecting Common Gestures中讨论的，所有的事件被记录在onTouchEvent()中的MotionEvent参数中.</p>\n<p>因为基于手指的触摸不总是精致的交互形式，检测触摸事件经常基于运动而不是单个触点。为了帮助应用区分(distingush)基于运动的手势（如 swipe）和非移动手势（如单击) ,Android包含了“touch slop”概念。Touch slop指的是在这个手势被解释为一个运动手势前， 用户触摸的像素距离。更多的这个主题的讨论，见 Managing Touch Events in a ViewGroup。</p>\n<p>有不同方式去追踪手势运动，取决与你的应用需要，如：</p>\n<ul>\n<li>一个目标的开始与结束（如，移动一个在屏幕上的物体，从点A到点B)</li>\n<li>目标点正运行的方向，通过x和y坐标的方向决定</li>\n<li>History，你可以通过调用MotionEvent的getHistorySize()方法，找到一个手势的History信息。你可以通过MotionEvent的 getHistorical&lt;Value&gt;方法获得每个History事件的位置，大小，时间，压力。History信息对于渲染用户手指的路径(trail)十分有效，如为触摸绘画.参考更多细节MotionEvent。</li>\n<li>目标移过触摸屏幕的速度。</li>\n</ul>\n<p>###跟踪速度</p>\n<p>你可以获得一个简单的基于距离和(或)目标移动方向的运动手势，但是速度通常是在追踪手势特性甚至决定是否一个手势发生的决定性因素 。为了使计算速度更简单，Android提供了VelocityTracker类和VelocityTrackerCompat类在支持包中。VolocityTracker 帮助你追踪触摸事件的速度。对于某些将速度作为部分标准的手势，如扫，这是十分有用的。</p>\n<p>以下这个示例，说明了VelocityTrackerAPI中的方法目的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\">    private static final String DEBUG_TAG = &quot;Velocity&quot;;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    private VelocityTracker mVelocityTracker = null;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        int index = event.getActionIndex();</span><br><span class=\"line\">        int action = event.getActionMasked();</span><br><span class=\"line\">        int pointerId = event.getPointerId(index);</span><br><span class=\"line\">        switch(action) &#123;</span><br><span class=\"line\">            case MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                if(mVelocityTracker == null) &#123;</span><br><span class=\"line\">                    // Retrieve a new VelocityTracker object to watch the velocity of a motion.</span><br><span class=\"line\">                    mVelocityTracker = VelocityTracker.obtain();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else &#123;</span><br><span class=\"line\">                    // Reset the velocity tracker back to its initial state.</span><br><span class=\"line\">                    mVelocityTracker.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // Add a user&apos;s movement to the tracker.</span><br><span class=\"line\">                mVelocityTracker.addMovement(event);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">                mVelocityTracker.addMovement(event);</span><br><span class=\"line\">                // When you want to determine the velocity, call</span><br><span class=\"line\">                // computeCurrentVelocity(). Then call getXVelocity()</span><br><span class=\"line\">                // and getYVelocity() to retrieve the velocity for each pointer ID.</span><br><span class=\"line\">                mVelocityTracker.computeCurrentVelocity(1000);</span><br><span class=\"line\">                // Log velocity of pixels per second</span><br><span class=\"line\">                // Best practice to use VelocityTrackerCompat where possible.</span><br><span class=\"line\">                Log.d(&quot;&quot;, &quot;X velocity: &quot; +</span><br><span class=\"line\">                        VelocityTrackerCompat.getXVelocity(mVelocityTracker,</span><br><span class=\"line\">                        pointerId));</span><br><span class=\"line\">                Log.d(&quot;&quot;, &quot;Y velocity: &quot; +</span><br><span class=\"line\">                        VelocityTrackerCompat.getYVelocity(mVelocityTracker,</span><br><span class=\"line\">                        pointerId));</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case MotionEvent.ACTION_UP:</span><br><span class=\"line\">            case MotionEvent.ACTION_CANCEL:</span><br><span class=\"line\">                // Return a VelocityTracker object back to be re-used by others.</span><br><span class=\"line\">                mVelocityTracker.recycle();</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong>你需要在ACTION_MOVE事件后计算速度，而不是ACTION_UP.如果你ACTION_UP后计算，X和Y速度将是0</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://developer.android.com/training/gestures/movement.html\" target=\"_blank\" rel=\"noopener\">源链接</a></p>\n<p>本课程将讨论如何在触摸事件中追踪运动</p>\n<p>一个新的onTouchEvent()是被一个ACTION_MOVE事件触发的，无论何时当前触摸包含位置，压力，或者大小改变。如在Detecting Common Gestures中讨论的，所有的事件被记录在onTouchEvent()中的MotionEvent参数中.</p>\n<p>因为基于手指的触摸不总是精致的交互形式，检测触摸事件经常基于运动而不是单个触点。为了帮助应用区分(distingush)基于运动的手势（如 swipe）和非移动手势（如单击) ,Android包含了“touch slop”概念。Touch slop指的是在这个手势被解释为一个运动手势前， 用户触摸的像素距离。更多的这个主题的讨论，见 Managing Touch Events in a ViewGroup。</p>\n<p>有不同方式去追踪手势运动，取决与你的应用需要，如：</p>\n<ul>\n<li>一个目标的开始与结束（如，移动一个在屏幕上的物体，从点A到点B)</li>\n<li>目标点正运行的方向，通过x和y坐标的方向决定</li>\n<li>History，你可以通过调用MotionEvent的getHistorySize()方法，找到一个手势的History信息。你可以通过MotionEvent的 getHistorical&lt;Value&gt;方法获得每个History事件的位置，大小，时间，压力。History信息对于渲染用户手指的路径(trail)十分有效，如为触摸绘画.参考更多细节MotionEvent。</li>\n<li>目标移过触摸屏幕的速度。</li>\n</ul>\n<p>###跟踪速度</p>\n<p>你可以获得一个简单的基于距离和(或)目标移动方向的运动手势，但是速度通常是在追踪手势特性甚至决定是否一个手势发生的决定性因素 。为了使计算速度更简单，Android提供了VelocityTracker类和VelocityTrackerCompat类在支持包中。VolocityTracker 帮助你追踪触摸事件的速度。对于某些将速度作为部分标准的手势，如扫，这是十分有用的。</p>\n<p>以下这个示例，说明了VelocityTrackerAPI中的方法目的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\">    private static final String DEBUG_TAG = &quot;Velocity&quot;;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    private VelocityTracker mVelocityTracker = null;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        int index = event.getActionIndex();</span><br><span class=\"line\">        int action = event.getActionMasked();</span><br><span class=\"line\">        int pointerId = event.getPointerId(index);</span><br><span class=\"line\">        switch(action) &#123;</span><br><span class=\"line\">            case MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                if(mVelocityTracker == null) &#123;</span><br><span class=\"line\">                    // Retrieve a new VelocityTracker object to watch the velocity of a motion.</span><br><span class=\"line\">                    mVelocityTracker = VelocityTracker.obtain();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else &#123;</span><br><span class=\"line\">                    // Reset the velocity tracker back to its initial state.</span><br><span class=\"line\">                    mVelocityTracker.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // Add a user&apos;s movement to the tracker.</span><br><span class=\"line\">                mVelocityTracker.addMovement(event);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">                mVelocityTracker.addMovement(event);</span><br><span class=\"line\">                // When you want to determine the velocity, call</span><br><span class=\"line\">                // computeCurrentVelocity(). Then call getXVelocity()</span><br><span class=\"line\">                // and getYVelocity() to retrieve the velocity for each pointer ID.</span><br><span class=\"line\">                mVelocityTracker.computeCurrentVelocity(1000);</span><br><span class=\"line\">                // Log velocity of pixels per second</span><br><span class=\"line\">                // Best practice to use VelocityTrackerCompat where possible.</span><br><span class=\"line\">                Log.d(&quot;&quot;, &quot;X velocity: &quot; +</span><br><span class=\"line\">                        VelocityTrackerCompat.getXVelocity(mVelocityTracker,</span><br><span class=\"line\">                        pointerId));</span><br><span class=\"line\">                Log.d(&quot;&quot;, &quot;Y velocity: &quot; +</span><br><span class=\"line\">                        VelocityTrackerCompat.getYVelocity(mVelocityTracker,</span><br><span class=\"line\">                        pointerId));</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case MotionEvent.ACTION_UP:</span><br><span class=\"line\">            case MotionEvent.ACTION_CANCEL:</span><br><span class=\"line\">                // Return a VelocityTracker object back to be re-used by others.</span><br><span class=\"line\">                mVelocityTracker.recycle();</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong>你需要在ACTION_MOVE事件后计算速度，而不是ACTION_UP.如果你ACTION_UP后计算，X和Y速度将是0</p>\n"},{"date":"2013-05-10T16:00:00.000Z","layout":"post","title":"创建属于你自己的3D ListView - Part 1(译)","_content":"原文连接 [Making your own 3D list - Part 1](http://developer.sonymobile.com/2010/05/20/android-tutorial-making-your-own-3d-list-part-1/)\n\n本文是教你如何在安卓应用中做出很酷效果的ListView的教材第一章，我叫Anders Ericson，主要从事UI工作，在Timescape应用中有个就是我做的，你可以在Xperia X10 mini 和 Xperia X10 mini pro中找到.当用户尝试使用一个App时，UI是他们第一个关注的东西,所以我决定做一个教材，使得其他任何安卓开发者可以创建属于他们自己的ListView,类似与在Timescape中的3D感觉和物理特性(dynamics).\n\n在教材的第一章，我们将创建一个很基础的list，然后在接下去的两章中，越来越多的功能和特性将添加进来。我同时也会教你如何使用list的基本构造，然后改变它使得无论如何工作的都使你的应用做到最好。下面那个链接是第一章的源码，已经为你准备好构建在如Eclipse这样的IDE中。同时不要忘了下载Sony Ericsson Tutorials 应用从Android Market中，你可以尝试使用同样的应用在教材的每一步。我很期待看到你的评论和问题。\n\nAndroid中标准的ListView已经支持了很多东西，并且包括了绝大多数的你可以想到的用户事件。但是listview看起来太平淡了，当你想继承它并且做很多事情时，都发现做不到，然后无疾而终。标准ListView的另一个缺点是缺乏好的物理特性（和改变它的能力）。因此，如果你要你的UI看起来不那么普通的话，你要做的仅仅是实现你自己的View.\n\n因为在一篇文章中写完会有太多的代码，所以我准备分为3部分。第一部分（就是这章）先创建一个基本的List，有太多的东西要去包括，但我想让我们更关注它们在后面几章.第二章，我们将看到listview的外貌改变和一些类3D图像算法。最后一章，我们将改变list的行为并且添加一些物理动力学进去，一些非常能提升外观和感觉的东西。\n\n虽然这里用到的技术和在X10 Mini上用到的一样，当这篇教材的目的不是仅仅拷贝一个看起来很特殊的list，而是教你实现自己的listview。我很确定你肯定有很多关于你的listview该看起来怎么样，它的行为和它用来干嘛的主意。\n\n### Hello AdapterView\n\n当我们瞄准一个list（能显示其他view）,我们需要继承ViewGroup,更合适的是AdapterView。（原因，或者更多的原因我们不从AbsListView继承，是因为它不允许我们在list上做有活力的效果）。那么，让我们从开始建立安卓项目并且创建一个继承自AdapterView<Adapter> 的 MyListView 开始吧，AdapterView有四个抽象函数我们需要去实现:\n\n- getAdapter()\n- setAdapter()\n- getSelectedView()\n- setSelection()\n\ngetAdapter()和setAdapter()直接实现，其他两个现在先仅仅抛出异常.\n\n```\npublic class MyListView extends AdapterView {\n    /** The adapter with all the data */\n    private Adapter mAdapter;\n    public MyListView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n    @Override\n    public void setAdapter(Adapter adapter) {\n        mAdapter = adapter;\n        removeAllViewsInLayout();\n        requestLayout();\n    }\n    @Override\n    public Adapter getAdapter() {\n        return mAdapter;\n    }\n    @Override\n    public void setSelection(int position) {\n        throw new UnsupportedOperationException(\"Not supported\");\n    }\n    @Override\n    public View getSelectedView() {\n        throw new UnsupportedOperationException(\"Not supported\");\n    }\n}\n```\n这里唯一值得注意的是setAdapter方法。当我们获得一个新的Adapter我们移除之前所有的视图，然后请求一个布局，并且按照adapter放置视图。如果我们现在创建一个activity和带有假数据的adapter，然后使用新视图，我们将得不到任何东西，在屏幕上。这是因为如果我们要在屏幕上得到一些东西，我们需要重写onLayout()方法。\n\n#### 显示我们的第一个视图\n\n在[onLayout( )](http://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int) )中，我们从adpater中获取视图，并且添加他们作为一个子视图。\n\n```\n@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    super.onLayout(changed, left, top, right, bottom);\n    // if we don't have an adapter, we don't need to do anything\n    if (mAdapter == null) {\n        return;\n    }\n    if (getChildCount() == 0) {\n        int position = 0;\n        int bottomEdge = 0;\n        while (bottomEdge &lt; getHeight() &amp;&amp; position &lt; mAdapter.getCount()) {\n            View newBottomChild = mAdapter.getView(position, null, this);\n            addAndMeasureChild(newBottomChild);\n            bottomEdge += newBottomChild.getMeasuredHeight();\n            position++;\n        }\n    }\n    positionItems();\n}\n```\nSo，What happends hers? 首先执行父调用和空值检查，然后开始真正有用的代码。如果我们还没有添加任何子节点，那么我们就开始那么做。这个while循环直到我们添加足够多的视图覆盖整个屏幕为止。当我们从adapter获得一个视图，我们就把它添加为一个子节点，然后我们需要测量(measure)它，为的是得到它的正确尺寸。当我们添加完所有的视图，我们把它们放置到正确的位置.\n\n\n```\n/**\n * Adds a view as a child view and takes care of measuring it\n *\n * @param child The view to add\n */\nprivate void addAndMeasureChild(View child) {\n    LayoutParams params = child.getLayoutParams();\n    if (params == null) {\n        params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);\n    }\n    addViewInLayout(child, -1, params, true);\n    int itemWidth = getWidth();\n    child.measure(MeasureSpec.EXACTLY | itemWidth, MeasureSpec.UNSPECIFIED);\n}\n/**\n * Positions the children at the &quot;correct&quot; positions\n */\nprivate void positionItems() {\n    int top = 0;\n    for (int index = 0; index < getChildCount(); index++) {\n        View child = getChildAt(index);\n        int width = child.getMeasuredWidth();\n        int height = child.getMeasuredHeight();\n        int left = (getWidth() - width) / 2;\n        child.layout(left, top, left + width, top + height);\n        top += height;\n    }\n}\n\n```\n这些代码比较简单，自解释，所以我不准备过多描述。虽然我在测量子视图时走了点捷径，但是这些代码在大部分情况下是工作良好的。positioItems()从top（0)开始，然后布局这些子视图，一个挨着一个，没有任何padding。值得注意的是，我们忽略了list可能有的padding.\n\n### 滑动\n如果现在运行这些代码，我们在屏幕上得到一些东西了。然而，这一点交互的感觉也没有（interactive）。当我们触摸屏幕时它不会滑动，我们也不能点击任何item.要让触摸生效，我们需要重写 onTouchEvent()。\n\n仅仅使其滑动的触摸逻辑是十分简单的，当我们得到一个按下事件，我们保存下按下事件的位置，和list的位置。我们将使用第一个item的top作为list的位置(position)，当我们获得一个移动事件，我们计算与按下事件的距离，然后根据开始位置和当前位置的距离重新安置list。\n\n```\n@Override\npublic boolean onTouchEvent(MotionEvent event) {\n    if (getChildCount() == 0) {\n        return false;\n    }\n    switch (event.getAction()) {\n        case MotionEvent.ACTION_DOWN:\n            mTouchStartY = (int)event.getY();\n            mListTopStart = getChildAt(0).getTop();\n            break;\n        case MotionEvent.ACTION_MOVE:\n            int scrolledDistance = (int)event.getY() - mTouchStartY;\n            mListTop = mListTopStart + scrolledDistance;\n            requestLayout();\n            break;\n        default:\n            break;\n    }\n    return true;\n}\n```\n现在list的位置已经由mListTop确定下来了，无论何时它改变了，我实际上只需要请求重新布局就好了。我们之前实现的positionItem()总是从0开始布局。现在我们需要改变它，以至于它能从mListTop开始。\n\n如果我们现在就去尝试滑动，它会表现的不错，但我们还是能发现一些明显的问题在我们的list中。首先，滑动没有限制，这样我们可以把所有的item滑出屏幕外。我们需要几种限制检查方式去阻止我们那样做。第二，如果我们往下滑，我们只能看到之前已经显示了的item。没有新的item显示出来，即使adapter包含了更多的item。我们现在就修复第二个问题，然后把第一个问题放到下一章再说。\n\n#### 处理所有的item\n之所以在我们滑动式没有新的item出现，原因在于onLayout()这段代码。这段代码只会在没有一个视图未被添加的时候才会添加视图。**(The code there only adds views if no views haven't already been added.)** list组件的必要条件之一就是无论它是有10个item还是10,000个item，它都应该工作正常。记住了这点，我们就不能简单地在开始的时候把所有的item从adapter拿出，然后全部添加为子视图，我们需要确定我们能高效地处理这些视图.为了做到高效，我们只需要持有list可见那部分的子视图。如果我们能维持一小块视图的缓存，最好不过了，我们能让adpater重用这些而不是反复的从xml中inflate。\n\n处理这些问题的地方在onLayout()。新版本的onLayout()看起来像是这样的：\n\n```\n@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    super.onLayout(changed, left, top, right, bottom);\n    // if we don't have an adapter, we don't need to do anything\n    if (mAdapter == null) {\n        return;\n    }\n    if (getChildCount() == 0) {\n        mLastItemPosition = -1;\n        fillListDown(mListTop);\n    } else {\n        int offset = mListTop + mListTopOffset - getChildTop(getChildAt(0));\n        removeNonVisibleViews(offset);\n        fillList(offset);\n    }\n    positionItems();\n    invalidate();\n}\n```\nfillListDown()和之前的while循环或多或少是同一个东西。也添加了一个方法做同样的事情，只是它从顶部开始添加，叫做fillListUp()。他们都叫做fillList()。removeNonVisibleViews()把超出可见范围（超出顶部和底部）的视图移除掉。有两个变量被添加进来，为了跟踪视图，确保与adpater连接时在正确的位置：mFirstItemPosition和mLastPosition。它们是当前可见视图的在adpater中第一个和最后一个位置。每当我们移除或者添加一个视图，它都会更新。当滑动中的list滑到第一个可见item的顶部时，我们也需要更新list的位置，每当我们在顶部添加一个新视图或者移除顶部视图时。\n\n为了弥补positionItems()将上下移动list的事实，我们需要让removeVisibleViews()和fillList()知道到底list移动了多少。这就是偏移变量(offset variable)。否则我们可能不会移除那些执行positionItems()时离开可见区域的items,或者我们可能忘了去添加将变为可见状态的items。当mListTop被定义为第一个item的顶部，即使它不可见，我们也需要跟踪当前第一个可见item到之前第一个item位置的距离。\n\n如果你之前有实现过一个adapter，你应该知道检测并且使用convertView参数，代替每次从xml中inflat一个新的视图，这种方式来提升性能。现在我们正实现它的另一面，那就是我们将调用getView()而不是实现它，然后我们需要确定我们让adapter重用views。我们需要的是可以重用视图的缓存。标准的ListView支持不同种类的视图，但是现在我们假设所有的item-views是一样的。我们将只使用LinkedList来作为缓存容器.每当我们移除一个子视图时(在 removeNonVisibleViews())我们添加一个到缓存中，每当我们向adapter调用getView是（在fillListDown（）和fillListUp（））时，我们返回一个缓存视图（如果有的话）作为convertView。\n\n###点击和长按\n\n想让list变的有用的，那么就需要让在list中的所有item可以被点击。AdapterView实现了设置OnItemClickListener和OnItemLongClickLstener的方法，我们需要确认在合适的时间调用这些监听器。为了支持点击item的视图，我们需要做三件事情\n1. 检测一个点击时间\n2. 找出被点击的item\n3. 调用监听器（如果设置了），携带正确的参数\n那么从顶部开始，并且实现一个点击检测吧。\n\nAndroid提供的[GestureDestector](http://developer.android.com/reference/android/view/GestureDetector.html)类可以使用，但是我们事实上我不建议使用。其中一个原因是我发现它相当不可靠，特别是长按手势和甩手势。另一个原因是如果你委托手势检测到另一类的话，你可能无法追踪触摸状态，并且想要知道更多关于触摸状态的信息。\n\n首先，定义一些触摸状态\n\n```\n/** User is not touching the list */\nprivate static final int TOUCH_STATE_RESTING = 0;\n/** User is touching the list and right now it's still a \"click\" */\nprivate static final int TOUCH_STATE_CLICK = 1;\n/** User is scrolling the list */\nprivate static final int TOUCH_STATE_SCROLL = 2;\n```\n我们事前已经重写过了OnTouchEvent()，现在我们将添加一些代码来处理新的状态。\n\n```\n@Override\n public boolean onTouchEvent(final MotionEvent event) {\n     if (getChildCount() == 0) {\n         return false;\n     }\n     switch (event.getAction()) {\n         case MotionEvent.ACTION_DOWN:\n             startTouch(event);\n             break;\n         case MotionEvent.ACTION_MOVE:\n             if (mTouchState == TOUCH_STATE_CLICK) {\n                 startScrollIfNeeded(event);\n             }\n             if (mTouchState == TOUCH_STATE_SCROLL) {\n                 scrollList((int)event.getY() - mTouchStartY);\n             }\n             break;\n         case MotionEvent.ACTION_UP:\n             if (mTouchState == TOUCH_STATE_CLICK) {\n                 clickChildAt((int)event.getX(), (int)event.getY());\n             }\n             endTouch();\n             break;\n         default:\n             endTouch();\n             break;\n     }\n     return true;\n }\n```\n在添加代码前，这段的大部分是相同的。处理按下事件的代码被重构为一个方法,startTouch()。同时我们将状态改变为TOUCH_STATE_CLICK。现在我们不知道用户是要点击或者滑动视图，但是直到我们识别为一个滑动，我们就处理它为一个点击。\n\n滑动的识别是在startScrollIfNeeded()中处理的，在滑动事件函数（move events）中被调用的那个。比较当前触摸坐标和按下事件的坐标，如果用户手指滑动的距离超出了临界值，那么就改变状态为TOUCH_STATE_SCROLL。我使用10px的临界值，效果还不错。你也可以使用ViewConfiguraion类然后调用getScaledTouchSlop()获取的值作为临界值。\n\nIf we are scrolling,then it's the same code as without the additions for click/state,though it's now in a separate method.(眼花了).list的顶部被修改，布局被要求重新布置list。\n\n为了支持点击事件，我们也需要处理好ACTION_UP事件，我们还需要确认我们把ACTION_CANCEL和ACTION_OUTSIDE事件区分开来。除了按下和移动事件，其他所有的事件我们都需要重置触摸状态为TOUCH_STATE_RESTING,已经在endTouch()中调用了，但是唯独ACTION_UP我们需要调用点击监听器。当然，我们只能调用点击监听器，如果我们是在点击状态而不是滑动状态。\n\n```\nprivate void clickChildAt(final int x, final int y) {\n    final int index = getContainingChildIndex(x, y);\n    if (index != INVALID_INDEX) {\n        final View itemView = getChildAt(index);\n        final int position = mFirstItemPosition + index;\n        final long id = mAdapter.getItemId(position);\n        performItemClick(itemView, position, id);\n    }\n}\nprivate int getContainingChildIndex(final int x, final int y) {\n    if (mRect == null) {\n        mRect = new Rect();\n    }\n    for (int index = 0; index &lt; getChildCount(); index++) {\n        getChildAt(index).getHitRect(mRect);\n        if (mRect.contains(x, y)) {\n            return index;\n        }\n    }\n    return INVALID_INDEX;\n}\n```\nclickChildAt() is responsible for calling the listener (if any) with the position for the child at the specified coordinates. To find the correct view clickChildAt() uses getContainingChildIndex() which loops through the child views and for each view checks if the coordinates given are contained within the hit-rect of the view or not.\n\nWhen we have click handling in place, adding a check for long press is quite simple. A convenient way of checking for a long press is to create a Runnable that calls the long press listener. Then whenever we get a down event we post this Runnable with a delay on the view). Whenever we get an up event or when we switch to scrolling, we know it’s not going to be a long press any more so then we simply remove the Runnable by calling [removeCallbacks()](http://developer.android.com/reference/android/view/View.html#removeCallbacks(java.lang.Runnable)). How long to check for a long-press is up to you and the specific view you are implementing, but if it’s not something special, it’s a good idea to use the same delay as the rest of the system. Use [ViewConfiguration.getLongPressTimeout()](http://developer.android.com/reference/android/view/ViewConfiguration.html#getLongPressTimeout()) to get it.\n\nIn order to be able to scroll the list even if the child views respond to touch events, you need to intercept touch events when you want to start scrolling. This is done by overriding [onInterceptTouchEvent()](http://developer.android.com/reference/android/view/ViewGroup.html#onInterceptTouchEvent(android.view.MotionEvent))  which lets us monitor all the touch events passed to our children and lets us, if we want to, intercept the touch events at any point.\n\n```\n@Override\npublic boolean onInterceptTouchEvent(final MotionEvent event) {\n    switch (event.getAction()) {\n        case MotionEvent.ACTION_DOWN:\n            startTouch(event);\n            return false;\n        case MotionEvent.ACTION_MOVE:\n            return startScrollIfNeeded(event);\n        default:\n            endTouch();\n            return false;\n    }\n}\n```\n\nThe implementation of onInterceptTouchEvent() looks quite like onTouchEvent(). If we get a down event, we save the position of the list then return false to let the motion event pass to wherever it’s going. When we get move events, we check if we’ve moved far enough for this to be counted as a scroll move. If we have moved enough, we set the state to scrolling and then we return true to intercept future events.\n\n####To be continued…\nWhat we’ve made so far is a very simple list. We handle views efficiently and a user can scroll it and click and long press items. If we stop here however, we could just as well have used ListView (though we’ve learned a bit about implementing a view group). In the next part of this tutorial, we will take a look at canvas transformations and give the list a more 3D look and after that we will look into the dynamics of the list like bounce and fling effects.\n\n[[Download] 3D List sample project – Part 1 (31kb)](http://developer.sonymobile.com/downloads/code-example-module/3d-list-sample-project-part-1/)\n","source":"_posts/2013-05-11-custom-adapterview.md","raw":"---\ncategory: Android\ndate: 2013-05-11\nlayout: post\ntitle: 创建属于你自己的3D ListView - Part 1(译)\n\n---\n原文连接 [Making your own 3D list - Part 1](http://developer.sonymobile.com/2010/05/20/android-tutorial-making-your-own-3d-list-part-1/)\n\n本文是教你如何在安卓应用中做出很酷效果的ListView的教材第一章，我叫Anders Ericson，主要从事UI工作，在Timescape应用中有个就是我做的，你可以在Xperia X10 mini 和 Xperia X10 mini pro中找到.当用户尝试使用一个App时，UI是他们第一个关注的东西,所以我决定做一个教材，使得其他任何安卓开发者可以创建属于他们自己的ListView,类似与在Timescape中的3D感觉和物理特性(dynamics).\n\n在教材的第一章，我们将创建一个很基础的list，然后在接下去的两章中，越来越多的功能和特性将添加进来。我同时也会教你如何使用list的基本构造，然后改变它使得无论如何工作的都使你的应用做到最好。下面那个链接是第一章的源码，已经为你准备好构建在如Eclipse这样的IDE中。同时不要忘了下载Sony Ericsson Tutorials 应用从Android Market中，你可以尝试使用同样的应用在教材的每一步。我很期待看到你的评论和问题。\n\nAndroid中标准的ListView已经支持了很多东西，并且包括了绝大多数的你可以想到的用户事件。但是listview看起来太平淡了，当你想继承它并且做很多事情时，都发现做不到，然后无疾而终。标准ListView的另一个缺点是缺乏好的物理特性（和改变它的能力）。因此，如果你要你的UI看起来不那么普通的话，你要做的仅仅是实现你自己的View.\n\n因为在一篇文章中写完会有太多的代码，所以我准备分为3部分。第一部分（就是这章）先创建一个基本的List，有太多的东西要去包括，但我想让我们更关注它们在后面几章.第二章，我们将看到listview的外貌改变和一些类3D图像算法。最后一章，我们将改变list的行为并且添加一些物理动力学进去，一些非常能提升外观和感觉的东西。\n\n虽然这里用到的技术和在X10 Mini上用到的一样，当这篇教材的目的不是仅仅拷贝一个看起来很特殊的list，而是教你实现自己的listview。我很确定你肯定有很多关于你的listview该看起来怎么样，它的行为和它用来干嘛的主意。\n\n### Hello AdapterView\n\n当我们瞄准一个list（能显示其他view）,我们需要继承ViewGroup,更合适的是AdapterView。（原因，或者更多的原因我们不从AbsListView继承，是因为它不允许我们在list上做有活力的效果）。那么，让我们从开始建立安卓项目并且创建一个继承自AdapterView<Adapter> 的 MyListView 开始吧，AdapterView有四个抽象函数我们需要去实现:\n\n- getAdapter()\n- setAdapter()\n- getSelectedView()\n- setSelection()\n\ngetAdapter()和setAdapter()直接实现，其他两个现在先仅仅抛出异常.\n\n```\npublic class MyListView extends AdapterView {\n    /** The adapter with all the data */\n    private Adapter mAdapter;\n    public MyListView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n    @Override\n    public void setAdapter(Adapter adapter) {\n        mAdapter = adapter;\n        removeAllViewsInLayout();\n        requestLayout();\n    }\n    @Override\n    public Adapter getAdapter() {\n        return mAdapter;\n    }\n    @Override\n    public void setSelection(int position) {\n        throw new UnsupportedOperationException(\"Not supported\");\n    }\n    @Override\n    public View getSelectedView() {\n        throw new UnsupportedOperationException(\"Not supported\");\n    }\n}\n```\n这里唯一值得注意的是setAdapter方法。当我们获得一个新的Adapter我们移除之前所有的视图，然后请求一个布局，并且按照adapter放置视图。如果我们现在创建一个activity和带有假数据的adapter，然后使用新视图，我们将得不到任何东西，在屏幕上。这是因为如果我们要在屏幕上得到一些东西，我们需要重写onLayout()方法。\n\n#### 显示我们的第一个视图\n\n在[onLayout( )](http://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int) )中，我们从adpater中获取视图，并且添加他们作为一个子视图。\n\n```\n@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    super.onLayout(changed, left, top, right, bottom);\n    // if we don't have an adapter, we don't need to do anything\n    if (mAdapter == null) {\n        return;\n    }\n    if (getChildCount() == 0) {\n        int position = 0;\n        int bottomEdge = 0;\n        while (bottomEdge &lt; getHeight() &amp;&amp; position &lt; mAdapter.getCount()) {\n            View newBottomChild = mAdapter.getView(position, null, this);\n            addAndMeasureChild(newBottomChild);\n            bottomEdge += newBottomChild.getMeasuredHeight();\n            position++;\n        }\n    }\n    positionItems();\n}\n```\nSo，What happends hers? 首先执行父调用和空值检查，然后开始真正有用的代码。如果我们还没有添加任何子节点，那么我们就开始那么做。这个while循环直到我们添加足够多的视图覆盖整个屏幕为止。当我们从adapter获得一个视图，我们就把它添加为一个子节点，然后我们需要测量(measure)它，为的是得到它的正确尺寸。当我们添加完所有的视图，我们把它们放置到正确的位置.\n\n\n```\n/**\n * Adds a view as a child view and takes care of measuring it\n *\n * @param child The view to add\n */\nprivate void addAndMeasureChild(View child) {\n    LayoutParams params = child.getLayoutParams();\n    if (params == null) {\n        params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);\n    }\n    addViewInLayout(child, -1, params, true);\n    int itemWidth = getWidth();\n    child.measure(MeasureSpec.EXACTLY | itemWidth, MeasureSpec.UNSPECIFIED);\n}\n/**\n * Positions the children at the &quot;correct&quot; positions\n */\nprivate void positionItems() {\n    int top = 0;\n    for (int index = 0; index < getChildCount(); index++) {\n        View child = getChildAt(index);\n        int width = child.getMeasuredWidth();\n        int height = child.getMeasuredHeight();\n        int left = (getWidth() - width) / 2;\n        child.layout(left, top, left + width, top + height);\n        top += height;\n    }\n}\n\n```\n这些代码比较简单，自解释，所以我不准备过多描述。虽然我在测量子视图时走了点捷径，但是这些代码在大部分情况下是工作良好的。positioItems()从top（0)开始，然后布局这些子视图，一个挨着一个，没有任何padding。值得注意的是，我们忽略了list可能有的padding.\n\n### 滑动\n如果现在运行这些代码，我们在屏幕上得到一些东西了。然而，这一点交互的感觉也没有（interactive）。当我们触摸屏幕时它不会滑动，我们也不能点击任何item.要让触摸生效，我们需要重写 onTouchEvent()。\n\n仅仅使其滑动的触摸逻辑是十分简单的，当我们得到一个按下事件，我们保存下按下事件的位置，和list的位置。我们将使用第一个item的top作为list的位置(position)，当我们获得一个移动事件，我们计算与按下事件的距离，然后根据开始位置和当前位置的距离重新安置list。\n\n```\n@Override\npublic boolean onTouchEvent(MotionEvent event) {\n    if (getChildCount() == 0) {\n        return false;\n    }\n    switch (event.getAction()) {\n        case MotionEvent.ACTION_DOWN:\n            mTouchStartY = (int)event.getY();\n            mListTopStart = getChildAt(0).getTop();\n            break;\n        case MotionEvent.ACTION_MOVE:\n            int scrolledDistance = (int)event.getY() - mTouchStartY;\n            mListTop = mListTopStart + scrolledDistance;\n            requestLayout();\n            break;\n        default:\n            break;\n    }\n    return true;\n}\n```\n现在list的位置已经由mListTop确定下来了，无论何时它改变了，我实际上只需要请求重新布局就好了。我们之前实现的positionItem()总是从0开始布局。现在我们需要改变它，以至于它能从mListTop开始。\n\n如果我们现在就去尝试滑动，它会表现的不错，但我们还是能发现一些明显的问题在我们的list中。首先，滑动没有限制，这样我们可以把所有的item滑出屏幕外。我们需要几种限制检查方式去阻止我们那样做。第二，如果我们往下滑，我们只能看到之前已经显示了的item。没有新的item显示出来，即使adapter包含了更多的item。我们现在就修复第二个问题，然后把第一个问题放到下一章再说。\n\n#### 处理所有的item\n之所以在我们滑动式没有新的item出现，原因在于onLayout()这段代码。这段代码只会在没有一个视图未被添加的时候才会添加视图。**(The code there only adds views if no views haven't already been added.)** list组件的必要条件之一就是无论它是有10个item还是10,000个item，它都应该工作正常。记住了这点，我们就不能简单地在开始的时候把所有的item从adapter拿出，然后全部添加为子视图，我们需要确定我们能高效地处理这些视图.为了做到高效，我们只需要持有list可见那部分的子视图。如果我们能维持一小块视图的缓存，最好不过了，我们能让adpater重用这些而不是反复的从xml中inflate。\n\n处理这些问题的地方在onLayout()。新版本的onLayout()看起来像是这样的：\n\n```\n@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    super.onLayout(changed, left, top, right, bottom);\n    // if we don't have an adapter, we don't need to do anything\n    if (mAdapter == null) {\n        return;\n    }\n    if (getChildCount() == 0) {\n        mLastItemPosition = -1;\n        fillListDown(mListTop);\n    } else {\n        int offset = mListTop + mListTopOffset - getChildTop(getChildAt(0));\n        removeNonVisibleViews(offset);\n        fillList(offset);\n    }\n    positionItems();\n    invalidate();\n}\n```\nfillListDown()和之前的while循环或多或少是同一个东西。也添加了一个方法做同样的事情，只是它从顶部开始添加，叫做fillListUp()。他们都叫做fillList()。removeNonVisibleViews()把超出可见范围（超出顶部和底部）的视图移除掉。有两个变量被添加进来，为了跟踪视图，确保与adpater连接时在正确的位置：mFirstItemPosition和mLastPosition。它们是当前可见视图的在adpater中第一个和最后一个位置。每当我们移除或者添加一个视图，它都会更新。当滑动中的list滑到第一个可见item的顶部时，我们也需要更新list的位置，每当我们在顶部添加一个新视图或者移除顶部视图时。\n\n为了弥补positionItems()将上下移动list的事实，我们需要让removeVisibleViews()和fillList()知道到底list移动了多少。这就是偏移变量(offset variable)。否则我们可能不会移除那些执行positionItems()时离开可见区域的items,或者我们可能忘了去添加将变为可见状态的items。当mListTop被定义为第一个item的顶部，即使它不可见，我们也需要跟踪当前第一个可见item到之前第一个item位置的距离。\n\n如果你之前有实现过一个adapter，你应该知道检测并且使用convertView参数，代替每次从xml中inflat一个新的视图，这种方式来提升性能。现在我们正实现它的另一面，那就是我们将调用getView()而不是实现它，然后我们需要确定我们让adapter重用views。我们需要的是可以重用视图的缓存。标准的ListView支持不同种类的视图，但是现在我们假设所有的item-views是一样的。我们将只使用LinkedList来作为缓存容器.每当我们移除一个子视图时(在 removeNonVisibleViews())我们添加一个到缓存中，每当我们向adapter调用getView是（在fillListDown（）和fillListUp（））时，我们返回一个缓存视图（如果有的话）作为convertView。\n\n###点击和长按\n\n想让list变的有用的，那么就需要让在list中的所有item可以被点击。AdapterView实现了设置OnItemClickListener和OnItemLongClickLstener的方法，我们需要确认在合适的时间调用这些监听器。为了支持点击item的视图，我们需要做三件事情\n1. 检测一个点击时间\n2. 找出被点击的item\n3. 调用监听器（如果设置了），携带正确的参数\n那么从顶部开始，并且实现一个点击检测吧。\n\nAndroid提供的[GestureDestector](http://developer.android.com/reference/android/view/GestureDetector.html)类可以使用，但是我们事实上我不建议使用。其中一个原因是我发现它相当不可靠，特别是长按手势和甩手势。另一个原因是如果你委托手势检测到另一类的话，你可能无法追踪触摸状态，并且想要知道更多关于触摸状态的信息。\n\n首先，定义一些触摸状态\n\n```\n/** User is not touching the list */\nprivate static final int TOUCH_STATE_RESTING = 0;\n/** User is touching the list and right now it's still a \"click\" */\nprivate static final int TOUCH_STATE_CLICK = 1;\n/** User is scrolling the list */\nprivate static final int TOUCH_STATE_SCROLL = 2;\n```\n我们事前已经重写过了OnTouchEvent()，现在我们将添加一些代码来处理新的状态。\n\n```\n@Override\n public boolean onTouchEvent(final MotionEvent event) {\n     if (getChildCount() == 0) {\n         return false;\n     }\n     switch (event.getAction()) {\n         case MotionEvent.ACTION_DOWN:\n             startTouch(event);\n             break;\n         case MotionEvent.ACTION_MOVE:\n             if (mTouchState == TOUCH_STATE_CLICK) {\n                 startScrollIfNeeded(event);\n             }\n             if (mTouchState == TOUCH_STATE_SCROLL) {\n                 scrollList((int)event.getY() - mTouchStartY);\n             }\n             break;\n         case MotionEvent.ACTION_UP:\n             if (mTouchState == TOUCH_STATE_CLICK) {\n                 clickChildAt((int)event.getX(), (int)event.getY());\n             }\n             endTouch();\n             break;\n         default:\n             endTouch();\n             break;\n     }\n     return true;\n }\n```\n在添加代码前，这段的大部分是相同的。处理按下事件的代码被重构为一个方法,startTouch()。同时我们将状态改变为TOUCH_STATE_CLICK。现在我们不知道用户是要点击或者滑动视图，但是直到我们识别为一个滑动，我们就处理它为一个点击。\n\n滑动的识别是在startScrollIfNeeded()中处理的，在滑动事件函数（move events）中被调用的那个。比较当前触摸坐标和按下事件的坐标，如果用户手指滑动的距离超出了临界值，那么就改变状态为TOUCH_STATE_SCROLL。我使用10px的临界值，效果还不错。你也可以使用ViewConfiguraion类然后调用getScaledTouchSlop()获取的值作为临界值。\n\nIf we are scrolling,then it's the same code as without the additions for click/state,though it's now in a separate method.(眼花了).list的顶部被修改，布局被要求重新布置list。\n\n为了支持点击事件，我们也需要处理好ACTION_UP事件，我们还需要确认我们把ACTION_CANCEL和ACTION_OUTSIDE事件区分开来。除了按下和移动事件，其他所有的事件我们都需要重置触摸状态为TOUCH_STATE_RESTING,已经在endTouch()中调用了，但是唯独ACTION_UP我们需要调用点击监听器。当然，我们只能调用点击监听器，如果我们是在点击状态而不是滑动状态。\n\n```\nprivate void clickChildAt(final int x, final int y) {\n    final int index = getContainingChildIndex(x, y);\n    if (index != INVALID_INDEX) {\n        final View itemView = getChildAt(index);\n        final int position = mFirstItemPosition + index;\n        final long id = mAdapter.getItemId(position);\n        performItemClick(itemView, position, id);\n    }\n}\nprivate int getContainingChildIndex(final int x, final int y) {\n    if (mRect == null) {\n        mRect = new Rect();\n    }\n    for (int index = 0; index &lt; getChildCount(); index++) {\n        getChildAt(index).getHitRect(mRect);\n        if (mRect.contains(x, y)) {\n            return index;\n        }\n    }\n    return INVALID_INDEX;\n}\n```\nclickChildAt() is responsible for calling the listener (if any) with the position for the child at the specified coordinates. To find the correct view clickChildAt() uses getContainingChildIndex() which loops through the child views and for each view checks if the coordinates given are contained within the hit-rect of the view or not.\n\nWhen we have click handling in place, adding a check for long press is quite simple. A convenient way of checking for a long press is to create a Runnable that calls the long press listener. Then whenever we get a down event we post this Runnable with a delay on the view). Whenever we get an up event or when we switch to scrolling, we know it’s not going to be a long press any more so then we simply remove the Runnable by calling [removeCallbacks()](http://developer.android.com/reference/android/view/View.html#removeCallbacks(java.lang.Runnable)). How long to check for a long-press is up to you and the specific view you are implementing, but if it’s not something special, it’s a good idea to use the same delay as the rest of the system. Use [ViewConfiguration.getLongPressTimeout()](http://developer.android.com/reference/android/view/ViewConfiguration.html#getLongPressTimeout()) to get it.\n\nIn order to be able to scroll the list even if the child views respond to touch events, you need to intercept touch events when you want to start scrolling. This is done by overriding [onInterceptTouchEvent()](http://developer.android.com/reference/android/view/ViewGroup.html#onInterceptTouchEvent(android.view.MotionEvent))  which lets us monitor all the touch events passed to our children and lets us, if we want to, intercept the touch events at any point.\n\n```\n@Override\npublic boolean onInterceptTouchEvent(final MotionEvent event) {\n    switch (event.getAction()) {\n        case MotionEvent.ACTION_DOWN:\n            startTouch(event);\n            return false;\n        case MotionEvent.ACTION_MOVE:\n            return startScrollIfNeeded(event);\n        default:\n            endTouch();\n            return false;\n    }\n}\n```\n\nThe implementation of onInterceptTouchEvent() looks quite like onTouchEvent(). If we get a down event, we save the position of the list then return false to let the motion event pass to wherever it’s going. When we get move events, we check if we’ve moved far enough for this to be counted as a scroll move. If we have moved enough, we set the state to scrolling and then we return true to intercept future events.\n\n####To be continued…\nWhat we’ve made so far is a very simple list. We handle views efficiently and a user can scroll it and click and long press items. If we stop here however, we could just as well have used ListView (though we’ve learned a bit about implementing a view group). In the next part of this tutorial, we will take a look at canvas transformations and give the list a more 3D look and after that we will look into the dynamics of the list like bounce and fling effects.\n\n[[Download] 3D List sample project – Part 1 (31kb)](http://developer.sonymobile.com/downloads/code-example-module/3d-list-sample-project-part-1/)\n","slug":"2013-05-11-custom-adapterview","published":1,"updated":"2018-02-14T21:36:14.831Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tkj0007rpfyflmzifkd","content":"<p>原文连接 <a href=\"http://developer.sonymobile.com/2010/05/20/android-tutorial-making-your-own-3d-list-part-1/\" target=\"_blank\" rel=\"noopener\">Making your own 3D list - Part 1</a></p>\n<p>本文是教你如何在安卓应用中做出很酷效果的ListView的教材第一章，我叫Anders Ericson，主要从事UI工作，在Timescape应用中有个就是我做的，你可以在Xperia X10 mini 和 Xperia X10 mini pro中找到.当用户尝试使用一个App时，UI是他们第一个关注的东西,所以我决定做一个教材，使得其他任何安卓开发者可以创建属于他们自己的ListView,类似与在Timescape中的3D感觉和物理特性(dynamics).</p>\n<p>在教材的第一章，我们将创建一个很基础的list，然后在接下去的两章中，越来越多的功能和特性将添加进来。我同时也会教你如何使用list的基本构造，然后改变它使得无论如何工作的都使你的应用做到最好。下面那个链接是第一章的源码，已经为你准备好构建在如Eclipse这样的IDE中。同时不要忘了下载Sony Ericsson Tutorials 应用从Android Market中，你可以尝试使用同样的应用在教材的每一步。我很期待看到你的评论和问题。</p>\n<p>Android中标准的ListView已经支持了很多东西，并且包括了绝大多数的你可以想到的用户事件。但是listview看起来太平淡了，当你想继承它并且做很多事情时，都发现做不到，然后无疾而终。标准ListView的另一个缺点是缺乏好的物理特性（和改变它的能力）。因此，如果你要你的UI看起来不那么普通的话，你要做的仅仅是实现你自己的View.</p>\n<p>因为在一篇文章中写完会有太多的代码，所以我准备分为3部分。第一部分（就是这章）先创建一个基本的List，有太多的东西要去包括，但我想让我们更关注它们在后面几章.第二章，我们将看到listview的外貌改变和一些类3D图像算法。最后一章，我们将改变list的行为并且添加一些物理动力学进去，一些非常能提升外观和感觉的东西。</p>\n<p>虽然这里用到的技术和在X10 Mini上用到的一样，当这篇教材的目的不是仅仅拷贝一个看起来很特殊的list，而是教你实现自己的listview。我很确定你肯定有很多关于你的listview该看起来怎么样，它的行为和它用来干嘛的主意。</p>\n<h3 id=\"Hello-AdapterView\"><a href=\"#Hello-AdapterView\" class=\"headerlink\" title=\"Hello AdapterView\"></a>Hello AdapterView</h3><p>当我们瞄准一个list（能显示其他view）,我们需要继承ViewGroup,更合适的是AdapterView。（原因，或者更多的原因我们不从AbsListView继承，是因为它不允许我们在list上做有活力的效果）。那么，让我们从开始建立安卓项目并且创建一个继承自AdapterView<adapter> 的 MyListView 开始吧，AdapterView有四个抽象函数我们需要去实现:</adapter></p>\n<ul>\n<li>getAdapter()</li>\n<li>setAdapter()</li>\n<li>getSelectedView()</li>\n<li>setSelection()</li>\n</ul>\n<p>getAdapter()和setAdapter()直接实现，其他两个现在先仅仅抛出异常.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyListView extends AdapterView &#123;</span><br><span class=\"line\">    /** The adapter with all the data */</span><br><span class=\"line\">    private Adapter mAdapter;</span><br><span class=\"line\">    public MyListView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setAdapter(Adapter adapter) &#123;</span><br><span class=\"line\">        mAdapter = adapter;</span><br><span class=\"line\">        removeAllViewsInLayout();</span><br><span class=\"line\">        requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Adapter getAdapter() &#123;</span><br><span class=\"line\">        return mAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setSelection(int position) &#123;</span><br><span class=\"line\">        throw new UnsupportedOperationException(&quot;Not supported&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public View getSelectedView() &#123;</span><br><span class=\"line\">        throw new UnsupportedOperationException(&quot;Not supported&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里唯一值得注意的是setAdapter方法。当我们获得一个新的Adapter我们移除之前所有的视图，然后请求一个布局，并且按照adapter放置视图。如果我们现在创建一个activity和带有假数据的adapter，然后使用新视图，我们将得不到任何东西，在屏幕上。这是因为如果我们要在屏幕上得到一些东西，我们需要重写onLayout()方法。</p>\n<h4 id=\"显示我们的第一个视图\"><a href=\"#显示我们的第一个视图\" class=\"headerlink\" title=\"显示我们的第一个视图\"></a>显示我们的第一个视图</h4><p>在<a href=\"http://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int\" target=\"_blank\" rel=\"noopener\">onLayout( )</a> )中，我们从adpater中获取视图，并且添加他们作为一个子视图。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class=\"line\">    super.onLayout(changed, left, top, right, bottom);</span><br><span class=\"line\">    // if we don&apos;t have an adapter, we don&apos;t need to do anything</span><br><span class=\"line\">    if (mAdapter == null) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (getChildCount() == 0) &#123;</span><br><span class=\"line\">        int position = 0;</span><br><span class=\"line\">        int bottomEdge = 0;</span><br><span class=\"line\">        while (bottomEdge &amp;lt; getHeight() &amp;amp;&amp;amp; position &amp;lt; mAdapter.getCount()) &#123;</span><br><span class=\"line\">            View newBottomChild = mAdapter.getView(position, null, this);</span><br><span class=\"line\">            addAndMeasureChild(newBottomChild);</span><br><span class=\"line\">            bottomEdge += newBottomChild.getMeasuredHeight();</span><br><span class=\"line\">            position++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    positionItems();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>So，What happends hers? 首先执行父调用和空值检查，然后开始真正有用的代码。如果我们还没有添加任何子节点，那么我们就开始那么做。这个while循环直到我们添加足够多的视图覆盖整个屏幕为止。当我们从adapter获得一个视图，我们就把它添加为一个子节点，然后我们需要测量(measure)它，为的是得到它的正确尺寸。当我们添加完所有的视图，我们把它们放置到正确的位置.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Adds a view as a child view and takes care of measuring it</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param child The view to add</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void addAndMeasureChild(View child) &#123;</span><br><span class=\"line\">    LayoutParams params = child.getLayoutParams();</span><br><span class=\"line\">    if (params == null) &#123;</span><br><span class=\"line\">        params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addViewInLayout(child, -1, params, true);</span><br><span class=\"line\">    int itemWidth = getWidth();</span><br><span class=\"line\">    child.measure(MeasureSpec.EXACTLY | itemWidth, MeasureSpec.UNSPECIFIED);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Positions the children at the &amp;quot;correct&amp;quot; positions</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void positionItems() &#123;</span><br><span class=\"line\">    int top = 0;</span><br><span class=\"line\">    for (int index = 0; index &lt; getChildCount(); index++) &#123;</span><br><span class=\"line\">        View child = getChildAt(index);</span><br><span class=\"line\">        int width = child.getMeasuredWidth();</span><br><span class=\"line\">        int height = child.getMeasuredHeight();</span><br><span class=\"line\">        int left = (getWidth() - width) / 2;</span><br><span class=\"line\">        child.layout(left, top, left + width, top + height);</span><br><span class=\"line\">        top += height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些代码比较简单，自解释，所以我不准备过多描述。虽然我在测量子视图时走了点捷径，但是这些代码在大部分情况下是工作良好的。positioItems()从top（0)开始，然后布局这些子视图，一个挨着一个，没有任何padding。值得注意的是，我们忽略了list可能有的padding.</p>\n<h3 id=\"滑动\"><a href=\"#滑动\" class=\"headerlink\" title=\"滑动\"></a>滑动</h3><p>如果现在运行这些代码，我们在屏幕上得到一些东西了。然而，这一点交互的感觉也没有（interactive）。当我们触摸屏幕时它不会滑动，我们也不能点击任何item.要让触摸生效，我们需要重写 onTouchEvent()。</p>\n<p>仅仅使其滑动的触摸逻辑是十分简单的，当我们得到一个按下事件，我们保存下按下事件的位置，和list的位置。我们将使用第一个item的top作为list的位置(position)，当我们获得一个移动事件，我们计算与按下事件的距离，然后根据开始位置和当前位置的距离重新安置list。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">    if (getChildCount() == 0) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    switch (event.getAction()) &#123;</span><br><span class=\"line\">        case MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">            mTouchStartY = (int)event.getY();</span><br><span class=\"line\">            mListTopStart = getChildAt(0).getTop();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">            int scrolledDistance = (int)event.getY() - mTouchStartY;</span><br><span class=\"line\">            mListTop = mListTopStart + scrolledDistance;</span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在list的位置已经由mListTop确定下来了，无论何时它改变了，我实际上只需要请求重新布局就好了。我们之前实现的positionItem()总是从0开始布局。现在我们需要改变它，以至于它能从mListTop开始。</p>\n<p>如果我们现在就去尝试滑动，它会表现的不错，但我们还是能发现一些明显的问题在我们的list中。首先，滑动没有限制，这样我们可以把所有的item滑出屏幕外。我们需要几种限制检查方式去阻止我们那样做。第二，如果我们往下滑，我们只能看到之前已经显示了的item。没有新的item显示出来，即使adapter包含了更多的item。我们现在就修复第二个问题，然后把第一个问题放到下一章再说。</p>\n<h4 id=\"处理所有的item\"><a href=\"#处理所有的item\" class=\"headerlink\" title=\"处理所有的item\"></a>处理所有的item</h4><p>之所以在我们滑动式没有新的item出现，原因在于onLayout()这段代码。这段代码只会在没有一个视图未被添加的时候才会添加视图。<strong>(The code there only adds views if no views haven’t already been added.)</strong> list组件的必要条件之一就是无论它是有10个item还是10,000个item，它都应该工作正常。记住了这点，我们就不能简单地在开始的时候把所有的item从adapter拿出，然后全部添加为子视图，我们需要确定我们能高效地处理这些视图.为了做到高效，我们只需要持有list可见那部分的子视图。如果我们能维持一小块视图的缓存，最好不过了，我们能让adpater重用这些而不是反复的从xml中inflate。</p>\n<p>处理这些问题的地方在onLayout()。新版本的onLayout()看起来像是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class=\"line\">    super.onLayout(changed, left, top, right, bottom);</span><br><span class=\"line\">    // if we don&apos;t have an adapter, we don&apos;t need to do anything</span><br><span class=\"line\">    if (mAdapter == null) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (getChildCount() == 0) &#123;</span><br><span class=\"line\">        mLastItemPosition = -1;</span><br><span class=\"line\">        fillListDown(mListTop);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        int offset = mListTop + mListTopOffset - getChildTop(getChildAt(0));</span><br><span class=\"line\">        removeNonVisibleViews(offset);</span><br><span class=\"line\">        fillList(offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    positionItems();</span><br><span class=\"line\">    invalidate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>fillListDown()和之前的while循环或多或少是同一个东西。也添加了一个方法做同样的事情，只是它从顶部开始添加，叫做fillListUp()。他们都叫做fillList()。removeNonVisibleViews()把超出可见范围（超出顶部和底部）的视图移除掉。有两个变量被添加进来，为了跟踪视图，确保与adpater连接时在正确的位置：mFirstItemPosition和mLastPosition。它们是当前可见视图的在adpater中第一个和最后一个位置。每当我们移除或者添加一个视图，它都会更新。当滑动中的list滑到第一个可见item的顶部时，我们也需要更新list的位置，每当我们在顶部添加一个新视图或者移除顶部视图时。</p>\n<p>为了弥补positionItems()将上下移动list的事实，我们需要让removeVisibleViews()和fillList()知道到底list移动了多少。这就是偏移变量(offset variable)。否则我们可能不会移除那些执行positionItems()时离开可见区域的items,或者我们可能忘了去添加将变为可见状态的items。当mListTop被定义为第一个item的顶部，即使它不可见，我们也需要跟踪当前第一个可见item到之前第一个item位置的距离。</p>\n<p>如果你之前有实现过一个adapter，你应该知道检测并且使用convertView参数，代替每次从xml中inflat一个新的视图，这种方式来提升性能。现在我们正实现它的另一面，那就是我们将调用getView()而不是实现它，然后我们需要确定我们让adapter重用views。我们需要的是可以重用视图的缓存。标准的ListView支持不同种类的视图，但是现在我们假设所有的item-views是一样的。我们将只使用LinkedList来作为缓存容器.每当我们移除一个子视图时(在 removeNonVisibleViews())我们添加一个到缓存中，每当我们向adapter调用getView是（在fillListDown（）和fillListUp（））时，我们返回一个缓存视图（如果有的话）作为convertView。</p>\n<p>###点击和长按</p>\n<p>想让list变的有用的，那么就需要让在list中的所有item可以被点击。AdapterView实现了设置OnItemClickListener和OnItemLongClickLstener的方法，我们需要确认在合适的时间调用这些监听器。为了支持点击item的视图，我们需要做三件事情</p>\n<ol>\n<li>检测一个点击时间</li>\n<li>找出被点击的item</li>\n<li>调用监听器（如果设置了），携带正确的参数<br>那么从顶部开始，并且实现一个点击检测吧。</li>\n</ol>\n<p>Android提供的<a href=\"http://developer.android.com/reference/android/view/GestureDetector.html\" target=\"_blank\" rel=\"noopener\">GestureDestector</a>类可以使用，但是我们事实上我不建议使用。其中一个原因是我发现它相当不可靠，特别是长按手势和甩手势。另一个原因是如果你委托手势检测到另一类的话，你可能无法追踪触摸状态，并且想要知道更多关于触摸状态的信息。</p>\n<p>首先，定义一些触摸状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** User is not touching the list */</span><br><span class=\"line\">private static final int TOUCH_STATE_RESTING = 0;</span><br><span class=\"line\">/** User is touching the list and right now it&apos;s still a &quot;click&quot; */</span><br><span class=\"line\">private static final int TOUCH_STATE_CLICK = 1;</span><br><span class=\"line\">/** User is scrolling the list */</span><br><span class=\"line\">private static final int TOUCH_STATE_SCROLL = 2;</span><br></pre></td></tr></table></figure>\n<p>我们事前已经重写过了OnTouchEvent()，现在我们将添加一些代码来处理新的状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\"> public boolean onTouchEvent(final MotionEvent event) &#123;</span><br><span class=\"line\">     if (getChildCount() == 0) &#123;</span><br><span class=\"line\">         return false;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     switch (event.getAction()) &#123;</span><br><span class=\"line\">         case MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">             startTouch(event);</span><br><span class=\"line\">             break;</span><br><span class=\"line\">         case MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">             if (mTouchState == TOUCH_STATE_CLICK) &#123;</span><br><span class=\"line\">                 startScrollIfNeeded(event);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             if (mTouchState == TOUCH_STATE_SCROLL) &#123;</span><br><span class=\"line\">                 scrollList((int)event.getY() - mTouchStartY);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             break;</span><br><span class=\"line\">         case MotionEvent.ACTION_UP:</span><br><span class=\"line\">             if (mTouchState == TOUCH_STATE_CLICK) &#123;</span><br><span class=\"line\">                 clickChildAt((int)event.getX(), (int)event.getY());</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             endTouch();</span><br><span class=\"line\">             break;</span><br><span class=\"line\">         default:</span><br><span class=\"line\">             endTouch();</span><br><span class=\"line\">             break;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return true;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在添加代码前，这段的大部分是相同的。处理按下事件的代码被重构为一个方法,startTouch()。同时我们将状态改变为TOUCH_STATE_CLICK。现在我们不知道用户是要点击或者滑动视图，但是直到我们识别为一个滑动，我们就处理它为一个点击。</p>\n<p>滑动的识别是在startScrollIfNeeded()中处理的，在滑动事件函数（move events）中被调用的那个。比较当前触摸坐标和按下事件的坐标，如果用户手指滑动的距离超出了临界值，那么就改变状态为TOUCH_STATE_SCROLL。我使用10px的临界值，效果还不错。你也可以使用ViewConfiguraion类然后调用getScaledTouchSlop()获取的值作为临界值。</p>\n<p>If we are scrolling,then it’s the same code as without the additions for click/state,though it’s now in a separate method.(眼花了).list的顶部被修改，布局被要求重新布置list。</p>\n<p>为了支持点击事件，我们也需要处理好ACTION_UP事件，我们还需要确认我们把ACTION_CANCEL和ACTION_OUTSIDE事件区分开来。除了按下和移动事件，其他所有的事件我们都需要重置触摸状态为TOUCH_STATE_RESTING,已经在endTouch()中调用了，但是唯独ACTION_UP我们需要调用点击监听器。当然，我们只能调用点击监听器，如果我们是在点击状态而不是滑动状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void clickChildAt(final int x, final int y) &#123;</span><br><span class=\"line\">    final int index = getContainingChildIndex(x, y);</span><br><span class=\"line\">    if (index != INVALID_INDEX) &#123;</span><br><span class=\"line\">        final View itemView = getChildAt(index);</span><br><span class=\"line\">        final int position = mFirstItemPosition + index;</span><br><span class=\"line\">        final long id = mAdapter.getItemId(position);</span><br><span class=\"line\">        performItemClick(itemView, position, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private int getContainingChildIndex(final int x, final int y) &#123;</span><br><span class=\"line\">    if (mRect == null) &#123;</span><br><span class=\"line\">        mRect = new Rect();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int index = 0; index &amp;lt; getChildCount(); index++) &#123;</span><br><span class=\"line\">        getChildAt(index).getHitRect(mRect);</span><br><span class=\"line\">        if (mRect.contains(x, y)) &#123;</span><br><span class=\"line\">            return index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return INVALID_INDEX;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>clickChildAt() is responsible for calling the listener (if any) with the position for the child at the specified coordinates. To find the correct view clickChildAt() uses getContainingChildIndex() which loops through the child views and for each view checks if the coordinates given are contained within the hit-rect of the view or not.</p>\n<p>When we have click handling in place, adding a check for long press is quite simple. A convenient way of checking for a long press is to create a Runnable that calls the long press listener. Then whenever we get a down event we post this Runnable with a delay on the view). Whenever we get an up event or when we switch to scrolling, we know it’s not going to be a long press any more so then we simply remove the Runnable by calling <a href=\"http://developer.android.com/reference/android/view/View.html#removeCallbacks(java.lang.Runnable\" target=\"_blank\" rel=\"noopener\">removeCallbacks()</a>). How long to check for a long-press is up to you and the specific view you are implementing, but if it’s not something special, it’s a good idea to use the same delay as the rest of the system. Use <a href=\"http://developer.android.com/reference/android/view/ViewConfiguration.html#getLongPressTimeout(\" target=\"_blank\" rel=\"noopener\">ViewConfiguration.getLongPressTimeout()</a>) to get it.</p>\n<p>In order to be able to scroll the list even if the child views respond to touch events, you need to intercept touch events when you want to start scrolling. This is done by overriding <a href=\"http://developer.android.com/reference/android/view/ViewGroup.html#onInterceptTouchEvent(android.view.MotionEvent\" target=\"_blank\" rel=\"noopener\">onInterceptTouchEvent()</a>)  which lets us monitor all the touch events passed to our children and lets us, if we want to, intercept the touch events at any point.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(final MotionEvent event) &#123;</span><br><span class=\"line\">    switch (event.getAction()) &#123;</span><br><span class=\"line\">        case MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">            startTouch(event);</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        case MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">            return startScrollIfNeeded(event);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            endTouch();</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The implementation of onInterceptTouchEvent() looks quite like onTouchEvent(). If we get a down event, we save the position of the list then return false to let the motion event pass to wherever it’s going. When we get move events, we check if we’ve moved far enough for this to be counted as a scroll move. If we have moved enough, we set the state to scrolling and then we return true to intercept future events.</p>\n<p>####To be continued…<br>What we’ve made so far is a very simple list. We handle views efficiently and a user can scroll it and click and long press items. If we stop here however, we could just as well have used ListView (though we’ve learned a bit about implementing a view group). In the next part of this tutorial, we will take a look at canvas transformations and give the list a more 3D look and after that we will look into the dynamics of the list like bounce and fling effects.</p>\n<p><a href=\"http://developer.sonymobile.com/downloads/code-example-module/3d-list-sample-project-part-1/\" target=\"_blank\" rel=\"noopener\">[Download] 3D List sample project – Part 1 (31kb)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文连接 <a href=\"http://developer.sonymobile.com/2010/05/20/android-tutorial-making-your-own-3d-list-part-1/\" target=\"_blank\" rel=\"noopener\">Making your own 3D list - Part 1</a></p>\n<p>本文是教你如何在安卓应用中做出很酷效果的ListView的教材第一章，我叫Anders Ericson，主要从事UI工作，在Timescape应用中有个就是我做的，你可以在Xperia X10 mini 和 Xperia X10 mini pro中找到.当用户尝试使用一个App时，UI是他们第一个关注的东西,所以我决定做一个教材，使得其他任何安卓开发者可以创建属于他们自己的ListView,类似与在Timescape中的3D感觉和物理特性(dynamics).</p>\n<p>在教材的第一章，我们将创建一个很基础的list，然后在接下去的两章中，越来越多的功能和特性将添加进来。我同时也会教你如何使用list的基本构造，然后改变它使得无论如何工作的都使你的应用做到最好。下面那个链接是第一章的源码，已经为你准备好构建在如Eclipse这样的IDE中。同时不要忘了下载Sony Ericsson Tutorials 应用从Android Market中，你可以尝试使用同样的应用在教材的每一步。我很期待看到你的评论和问题。</p>\n<p>Android中标准的ListView已经支持了很多东西，并且包括了绝大多数的你可以想到的用户事件。但是listview看起来太平淡了，当你想继承它并且做很多事情时，都发现做不到，然后无疾而终。标准ListView的另一个缺点是缺乏好的物理特性（和改变它的能力）。因此，如果你要你的UI看起来不那么普通的话，你要做的仅仅是实现你自己的View.</p>\n<p>因为在一篇文章中写完会有太多的代码，所以我准备分为3部分。第一部分（就是这章）先创建一个基本的List，有太多的东西要去包括，但我想让我们更关注它们在后面几章.第二章，我们将看到listview的外貌改变和一些类3D图像算法。最后一章，我们将改变list的行为并且添加一些物理动力学进去，一些非常能提升外观和感觉的东西。</p>\n<p>虽然这里用到的技术和在X10 Mini上用到的一样，当这篇教材的目的不是仅仅拷贝一个看起来很特殊的list，而是教你实现自己的listview。我很确定你肯定有很多关于你的listview该看起来怎么样，它的行为和它用来干嘛的主意。</p>\n<h3 id=\"Hello-AdapterView\"><a href=\"#Hello-AdapterView\" class=\"headerlink\" title=\"Hello AdapterView\"></a>Hello AdapterView</h3><p>当我们瞄准一个list（能显示其他view）,我们需要继承ViewGroup,更合适的是AdapterView。（原因，或者更多的原因我们不从AbsListView继承，是因为它不允许我们在list上做有活力的效果）。那么，让我们从开始建立安卓项目并且创建一个继承自AdapterView<adapter> 的 MyListView 开始吧，AdapterView有四个抽象函数我们需要去实现:</adapter></p>\n<ul>\n<li>getAdapter()</li>\n<li>setAdapter()</li>\n<li>getSelectedView()</li>\n<li>setSelection()</li>\n</ul>\n<p>getAdapter()和setAdapter()直接实现，其他两个现在先仅仅抛出异常.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyListView extends AdapterView &#123;</span><br><span class=\"line\">    /** The adapter with all the data */</span><br><span class=\"line\">    private Adapter mAdapter;</span><br><span class=\"line\">    public MyListView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setAdapter(Adapter adapter) &#123;</span><br><span class=\"line\">        mAdapter = adapter;</span><br><span class=\"line\">        removeAllViewsInLayout();</span><br><span class=\"line\">        requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Adapter getAdapter() &#123;</span><br><span class=\"line\">        return mAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setSelection(int position) &#123;</span><br><span class=\"line\">        throw new UnsupportedOperationException(&quot;Not supported&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public View getSelectedView() &#123;</span><br><span class=\"line\">        throw new UnsupportedOperationException(&quot;Not supported&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里唯一值得注意的是setAdapter方法。当我们获得一个新的Adapter我们移除之前所有的视图，然后请求一个布局，并且按照adapter放置视图。如果我们现在创建一个activity和带有假数据的adapter，然后使用新视图，我们将得不到任何东西，在屏幕上。这是因为如果我们要在屏幕上得到一些东西，我们需要重写onLayout()方法。</p>\n<h4 id=\"显示我们的第一个视图\"><a href=\"#显示我们的第一个视图\" class=\"headerlink\" title=\"显示我们的第一个视图\"></a>显示我们的第一个视图</h4><p>在<a href=\"http://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int\" target=\"_blank\" rel=\"noopener\">onLayout( )</a> )中，我们从adpater中获取视图，并且添加他们作为一个子视图。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class=\"line\">    super.onLayout(changed, left, top, right, bottom);</span><br><span class=\"line\">    // if we don&apos;t have an adapter, we don&apos;t need to do anything</span><br><span class=\"line\">    if (mAdapter == null) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (getChildCount() == 0) &#123;</span><br><span class=\"line\">        int position = 0;</span><br><span class=\"line\">        int bottomEdge = 0;</span><br><span class=\"line\">        while (bottomEdge &amp;lt; getHeight() &amp;amp;&amp;amp; position &amp;lt; mAdapter.getCount()) &#123;</span><br><span class=\"line\">            View newBottomChild = mAdapter.getView(position, null, this);</span><br><span class=\"line\">            addAndMeasureChild(newBottomChild);</span><br><span class=\"line\">            bottomEdge += newBottomChild.getMeasuredHeight();</span><br><span class=\"line\">            position++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    positionItems();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>So，What happends hers? 首先执行父调用和空值检查，然后开始真正有用的代码。如果我们还没有添加任何子节点，那么我们就开始那么做。这个while循环直到我们添加足够多的视图覆盖整个屏幕为止。当我们从adapter获得一个视图，我们就把它添加为一个子节点，然后我们需要测量(measure)它，为的是得到它的正确尺寸。当我们添加完所有的视图，我们把它们放置到正确的位置.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Adds a view as a child view and takes care of measuring it</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param child The view to add</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void addAndMeasureChild(View child) &#123;</span><br><span class=\"line\">    LayoutParams params = child.getLayoutParams();</span><br><span class=\"line\">    if (params == null) &#123;</span><br><span class=\"line\">        params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addViewInLayout(child, -1, params, true);</span><br><span class=\"line\">    int itemWidth = getWidth();</span><br><span class=\"line\">    child.measure(MeasureSpec.EXACTLY | itemWidth, MeasureSpec.UNSPECIFIED);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Positions the children at the &amp;quot;correct&amp;quot; positions</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void positionItems() &#123;</span><br><span class=\"line\">    int top = 0;</span><br><span class=\"line\">    for (int index = 0; index &lt; getChildCount(); index++) &#123;</span><br><span class=\"line\">        View child = getChildAt(index);</span><br><span class=\"line\">        int width = child.getMeasuredWidth();</span><br><span class=\"line\">        int height = child.getMeasuredHeight();</span><br><span class=\"line\">        int left = (getWidth() - width) / 2;</span><br><span class=\"line\">        child.layout(left, top, left + width, top + height);</span><br><span class=\"line\">        top += height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些代码比较简单，自解释，所以我不准备过多描述。虽然我在测量子视图时走了点捷径，但是这些代码在大部分情况下是工作良好的。positioItems()从top（0)开始，然后布局这些子视图，一个挨着一个，没有任何padding。值得注意的是，我们忽略了list可能有的padding.</p>\n<h3 id=\"滑动\"><a href=\"#滑动\" class=\"headerlink\" title=\"滑动\"></a>滑动</h3><p>如果现在运行这些代码，我们在屏幕上得到一些东西了。然而，这一点交互的感觉也没有（interactive）。当我们触摸屏幕时它不会滑动，我们也不能点击任何item.要让触摸生效，我们需要重写 onTouchEvent()。</p>\n<p>仅仅使其滑动的触摸逻辑是十分简单的，当我们得到一个按下事件，我们保存下按下事件的位置，和list的位置。我们将使用第一个item的top作为list的位置(position)，当我们获得一个移动事件，我们计算与按下事件的距离，然后根据开始位置和当前位置的距离重新安置list。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">    if (getChildCount() == 0) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    switch (event.getAction()) &#123;</span><br><span class=\"line\">        case MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">            mTouchStartY = (int)event.getY();</span><br><span class=\"line\">            mListTopStart = getChildAt(0).getTop();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">            int scrolledDistance = (int)event.getY() - mTouchStartY;</span><br><span class=\"line\">            mListTop = mListTopStart + scrolledDistance;</span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在list的位置已经由mListTop确定下来了，无论何时它改变了，我实际上只需要请求重新布局就好了。我们之前实现的positionItem()总是从0开始布局。现在我们需要改变它，以至于它能从mListTop开始。</p>\n<p>如果我们现在就去尝试滑动，它会表现的不错，但我们还是能发现一些明显的问题在我们的list中。首先，滑动没有限制，这样我们可以把所有的item滑出屏幕外。我们需要几种限制检查方式去阻止我们那样做。第二，如果我们往下滑，我们只能看到之前已经显示了的item。没有新的item显示出来，即使adapter包含了更多的item。我们现在就修复第二个问题，然后把第一个问题放到下一章再说。</p>\n<h4 id=\"处理所有的item\"><a href=\"#处理所有的item\" class=\"headerlink\" title=\"处理所有的item\"></a>处理所有的item</h4><p>之所以在我们滑动式没有新的item出现，原因在于onLayout()这段代码。这段代码只会在没有一个视图未被添加的时候才会添加视图。<strong>(The code there only adds views if no views haven’t already been added.)</strong> list组件的必要条件之一就是无论它是有10个item还是10,000个item，它都应该工作正常。记住了这点，我们就不能简单地在开始的时候把所有的item从adapter拿出，然后全部添加为子视图，我们需要确定我们能高效地处理这些视图.为了做到高效，我们只需要持有list可见那部分的子视图。如果我们能维持一小块视图的缓存，最好不过了，我们能让adpater重用这些而不是反复的从xml中inflate。</p>\n<p>处理这些问题的地方在onLayout()。新版本的onLayout()看起来像是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class=\"line\">    super.onLayout(changed, left, top, right, bottom);</span><br><span class=\"line\">    // if we don&apos;t have an adapter, we don&apos;t need to do anything</span><br><span class=\"line\">    if (mAdapter == null) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (getChildCount() == 0) &#123;</span><br><span class=\"line\">        mLastItemPosition = -1;</span><br><span class=\"line\">        fillListDown(mListTop);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        int offset = mListTop + mListTopOffset - getChildTop(getChildAt(0));</span><br><span class=\"line\">        removeNonVisibleViews(offset);</span><br><span class=\"line\">        fillList(offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    positionItems();</span><br><span class=\"line\">    invalidate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>fillListDown()和之前的while循环或多或少是同一个东西。也添加了一个方法做同样的事情，只是它从顶部开始添加，叫做fillListUp()。他们都叫做fillList()。removeNonVisibleViews()把超出可见范围（超出顶部和底部）的视图移除掉。有两个变量被添加进来，为了跟踪视图，确保与adpater连接时在正确的位置：mFirstItemPosition和mLastPosition。它们是当前可见视图的在adpater中第一个和最后一个位置。每当我们移除或者添加一个视图，它都会更新。当滑动中的list滑到第一个可见item的顶部时，我们也需要更新list的位置，每当我们在顶部添加一个新视图或者移除顶部视图时。</p>\n<p>为了弥补positionItems()将上下移动list的事实，我们需要让removeVisibleViews()和fillList()知道到底list移动了多少。这就是偏移变量(offset variable)。否则我们可能不会移除那些执行positionItems()时离开可见区域的items,或者我们可能忘了去添加将变为可见状态的items。当mListTop被定义为第一个item的顶部，即使它不可见，我们也需要跟踪当前第一个可见item到之前第一个item位置的距离。</p>\n<p>如果你之前有实现过一个adapter，你应该知道检测并且使用convertView参数，代替每次从xml中inflat一个新的视图，这种方式来提升性能。现在我们正实现它的另一面，那就是我们将调用getView()而不是实现它，然后我们需要确定我们让adapter重用views。我们需要的是可以重用视图的缓存。标准的ListView支持不同种类的视图，但是现在我们假设所有的item-views是一样的。我们将只使用LinkedList来作为缓存容器.每当我们移除一个子视图时(在 removeNonVisibleViews())我们添加一个到缓存中，每当我们向adapter调用getView是（在fillListDown（）和fillListUp（））时，我们返回一个缓存视图（如果有的话）作为convertView。</p>\n<p>###点击和长按</p>\n<p>想让list变的有用的，那么就需要让在list中的所有item可以被点击。AdapterView实现了设置OnItemClickListener和OnItemLongClickLstener的方法，我们需要确认在合适的时间调用这些监听器。为了支持点击item的视图，我们需要做三件事情</p>\n<ol>\n<li>检测一个点击时间</li>\n<li>找出被点击的item</li>\n<li>调用监听器（如果设置了），携带正确的参数<br>那么从顶部开始，并且实现一个点击检测吧。</li>\n</ol>\n<p>Android提供的<a href=\"http://developer.android.com/reference/android/view/GestureDetector.html\" target=\"_blank\" rel=\"noopener\">GestureDestector</a>类可以使用，但是我们事实上我不建议使用。其中一个原因是我发现它相当不可靠，特别是长按手势和甩手势。另一个原因是如果你委托手势检测到另一类的话，你可能无法追踪触摸状态，并且想要知道更多关于触摸状态的信息。</p>\n<p>首先，定义一些触摸状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** User is not touching the list */</span><br><span class=\"line\">private static final int TOUCH_STATE_RESTING = 0;</span><br><span class=\"line\">/** User is touching the list and right now it&apos;s still a &quot;click&quot; */</span><br><span class=\"line\">private static final int TOUCH_STATE_CLICK = 1;</span><br><span class=\"line\">/** User is scrolling the list */</span><br><span class=\"line\">private static final int TOUCH_STATE_SCROLL = 2;</span><br></pre></td></tr></table></figure>\n<p>我们事前已经重写过了OnTouchEvent()，现在我们将添加一些代码来处理新的状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\"> public boolean onTouchEvent(final MotionEvent event) &#123;</span><br><span class=\"line\">     if (getChildCount() == 0) &#123;</span><br><span class=\"line\">         return false;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     switch (event.getAction()) &#123;</span><br><span class=\"line\">         case MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">             startTouch(event);</span><br><span class=\"line\">             break;</span><br><span class=\"line\">         case MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">             if (mTouchState == TOUCH_STATE_CLICK) &#123;</span><br><span class=\"line\">                 startScrollIfNeeded(event);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             if (mTouchState == TOUCH_STATE_SCROLL) &#123;</span><br><span class=\"line\">                 scrollList((int)event.getY() - mTouchStartY);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             break;</span><br><span class=\"line\">         case MotionEvent.ACTION_UP:</span><br><span class=\"line\">             if (mTouchState == TOUCH_STATE_CLICK) &#123;</span><br><span class=\"line\">                 clickChildAt((int)event.getX(), (int)event.getY());</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             endTouch();</span><br><span class=\"line\">             break;</span><br><span class=\"line\">         default:</span><br><span class=\"line\">             endTouch();</span><br><span class=\"line\">             break;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return true;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在添加代码前，这段的大部分是相同的。处理按下事件的代码被重构为一个方法,startTouch()。同时我们将状态改变为TOUCH_STATE_CLICK。现在我们不知道用户是要点击或者滑动视图，但是直到我们识别为一个滑动，我们就处理它为一个点击。</p>\n<p>滑动的识别是在startScrollIfNeeded()中处理的，在滑动事件函数（move events）中被调用的那个。比较当前触摸坐标和按下事件的坐标，如果用户手指滑动的距离超出了临界值，那么就改变状态为TOUCH_STATE_SCROLL。我使用10px的临界值，效果还不错。你也可以使用ViewConfiguraion类然后调用getScaledTouchSlop()获取的值作为临界值。</p>\n<p>If we are scrolling,then it’s the same code as without the additions for click/state,though it’s now in a separate method.(眼花了).list的顶部被修改，布局被要求重新布置list。</p>\n<p>为了支持点击事件，我们也需要处理好ACTION_UP事件，我们还需要确认我们把ACTION_CANCEL和ACTION_OUTSIDE事件区分开来。除了按下和移动事件，其他所有的事件我们都需要重置触摸状态为TOUCH_STATE_RESTING,已经在endTouch()中调用了，但是唯独ACTION_UP我们需要调用点击监听器。当然，我们只能调用点击监听器，如果我们是在点击状态而不是滑动状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void clickChildAt(final int x, final int y) &#123;</span><br><span class=\"line\">    final int index = getContainingChildIndex(x, y);</span><br><span class=\"line\">    if (index != INVALID_INDEX) &#123;</span><br><span class=\"line\">        final View itemView = getChildAt(index);</span><br><span class=\"line\">        final int position = mFirstItemPosition + index;</span><br><span class=\"line\">        final long id = mAdapter.getItemId(position);</span><br><span class=\"line\">        performItemClick(itemView, position, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private int getContainingChildIndex(final int x, final int y) &#123;</span><br><span class=\"line\">    if (mRect == null) &#123;</span><br><span class=\"line\">        mRect = new Rect();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int index = 0; index &amp;lt; getChildCount(); index++) &#123;</span><br><span class=\"line\">        getChildAt(index).getHitRect(mRect);</span><br><span class=\"line\">        if (mRect.contains(x, y)) &#123;</span><br><span class=\"line\">            return index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return INVALID_INDEX;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>clickChildAt() is responsible for calling the listener (if any) with the position for the child at the specified coordinates. To find the correct view clickChildAt() uses getContainingChildIndex() which loops through the child views and for each view checks if the coordinates given are contained within the hit-rect of the view or not.</p>\n<p>When we have click handling in place, adding a check for long press is quite simple. A convenient way of checking for a long press is to create a Runnable that calls the long press listener. Then whenever we get a down event we post this Runnable with a delay on the view). Whenever we get an up event or when we switch to scrolling, we know it’s not going to be a long press any more so then we simply remove the Runnable by calling <a href=\"http://developer.android.com/reference/android/view/View.html#removeCallbacks(java.lang.Runnable\" target=\"_blank\" rel=\"noopener\">removeCallbacks()</a>). How long to check for a long-press is up to you and the specific view you are implementing, but if it’s not something special, it’s a good idea to use the same delay as the rest of the system. Use <a href=\"http://developer.android.com/reference/android/view/ViewConfiguration.html#getLongPressTimeout(\" target=\"_blank\" rel=\"noopener\">ViewConfiguration.getLongPressTimeout()</a>) to get it.</p>\n<p>In order to be able to scroll the list even if the child views respond to touch events, you need to intercept touch events when you want to start scrolling. This is done by overriding <a href=\"http://developer.android.com/reference/android/view/ViewGroup.html#onInterceptTouchEvent(android.view.MotionEvent\" target=\"_blank\" rel=\"noopener\">onInterceptTouchEvent()</a>)  which lets us monitor all the touch events passed to our children and lets us, if we want to, intercept the touch events at any point.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onInterceptTouchEvent(final MotionEvent event) &#123;</span><br><span class=\"line\">    switch (event.getAction()) &#123;</span><br><span class=\"line\">        case MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">            startTouch(event);</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        case MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">            return startScrollIfNeeded(event);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            endTouch();</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The implementation of onInterceptTouchEvent() looks quite like onTouchEvent(). If we get a down event, we save the position of the list then return false to let the motion event pass to wherever it’s going. When we get move events, we check if we’ve moved far enough for this to be counted as a scroll move. If we have moved enough, we set the state to scrolling and then we return true to intercept future events.</p>\n<p>####To be continued…<br>What we’ve made so far is a very simple list. We handle views efficiently and a user can scroll it and click and long press items. If we stop here however, we could just as well have used ListView (though we’ve learned a bit about implementing a view group). In the next part of this tutorial, we will take a look at canvas transformations and give the list a more 3D look and after that we will look into the dynamics of the list like bounce and fling effects.</p>\n<p><a href=\"http://developer.sonymobile.com/downloads/code-example-module/3d-list-sample-project-part-1/\" target=\"_blank\" rel=\"noopener\">[Download] 3D List sample project – Part 1 (31kb)</a></p>\n"},{"date":"2013-05-12T16:00:00.000Z","layout":"post","title":"介绍开源项目 Android-Universal-Image-Loader -Part 1","_content":"\nGithub地址：[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader) 万能的图片加载器!  \n作者：[nostra13](https://github.com/nostra13)\n\n废话不多开始介绍\n\nThis project aims to provide a reusable instrument for asynchronous image loading, caching and displaying. It is originally based on Fedor Vlasov's project and has been vastly refactored and improved since then.\n\n作者说他也是[Fedor Vlasov's project](https://github.com/thest1/LazyList)这个项目改写过来的，做到对图片的异步加载，缓存和显示。\n\n##特性\n- 多线程图片加载\n- 尽可能多的配置选项（线程池，加载器，解析器，内存/磁盘缓存，显示参数等等）\n- 图片可以缓存在内存中，或者设备文件目录下，或者SD卡中\n- 可以监听加载进度\n- 可以自定义显示每一张图片时都带不同参数\n- 支持Widget\n\n## Quick Setup\n### 1.Include library\n[下载连接 JAR](https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/downloads/universal-image-loader-1.8.4-with-sources.jar)\n\n### 2.Android Manifest\n\n```\n<manifest>\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <!-- Include next permission if you want to allow UIL to cache images on SD card -->\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    ...\n    <application android:name=\"MyApplication\">\n        ...\n    </application>\n</manifest>\n```\n### 3. Application class\n```\npublic class MyApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // Create global configuration and initialize ImageLoader with this configuration\n        ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext())\n            ...\n            .build();\n        ImageLoader.getInstance().init(config);\n    }\n}\n```\n\n## Configuration and Display Options\n\n- Configuration(ImageLoaderConfiguration) 是相对于整个应用的配置\n- Display Options(DisplayImageOptions)是针对每一个显示图片任务所提供的参数(ImageLoader.displayImage(…)).\n\n### Configuration\n所有的选项都是可选的，只选择你真正想制定的去配置。\n\n```\n// DON'T COPY THIS CODE TO YOUR PROJECT! This is just example of ALL options using.\nFile cacheDir = StorageUtils.getCacheDirectory(context);\nImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(context)\n\t\t//如果图片尺寸大于了这个参数，那么就会这按照这个参数对图片大小进行限制并缓存\n        .memoryCacheExtraOptions(480, 800) // default=device screen dimensions\n        .discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75)\n        .taskExecutor(AsyncTask.THREAD_POOL_EXECUTOR)\n        .taskExecutorForCachedImages(AsyncTask.THREAD_POOL_EXECUTOR)\n        .threadPoolSize(3) // default\n        .threadPriority(Thread.NORM_PRIORITY - 1) // default\n        .tasksProcessingOrder(QueueProcessingType.FIFO) // default\n        .denyCacheImageMultipleSizesInMemory()\n        .memoryCache(new LruMemoryCache(2 * 1024 * 1024))\n        .memoryCacheSize(2 * 1024 * 1024)\n        .discCache(new UnlimitedDiscCache(cacheDir)) // default\n        .discCacheSize(50 * 1024 * 1024)\n        .discCacheFileCount(100)\n        .discCacheFileNameGenerator(new HashCodeFileNameGenerator()) // default\n        .imageDownloader(new BaseImageDownloader(context)) // default\n        .imageDecoder(new BaseImageDecoder()) // default\n        .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) // default\n        .enableLogging()\n        .build();\n```\n参数主要包括了这么几类配置\n1. 线程池配置\n2. 内存缓存配置\n3. 磁盘缓存配置\n4. 使用哪个图片下载器\n5. 使用哪个图片解析器\n实际上，不做任何配置也是ImageLoader也是可以使用的。\n插一句，配置选项的确够丰富，但有多是没有必要的。\n\n### Display Options\n\n显示参数可以分别被每一个显示任务调用(ImageLoader.displayImage(…))\n\nNote:**如果没有调用ImageLoader.displayImage(…),那么将使用配置选项中的默认显示参数(ImageLoaderConfiguration.defaultDisplayImageOptions(…))**\n\n```\nDisplayImageOptions options = new DisplayImageOptions.Builder()\n        .showStubImage(R.drawable.ic_stub)  // 在显示真正的图片前，会加载这个资源\n        .showImageForEmptyUri(R.drawable.ic_empty) //空的Url时\n        .showImageOnFail(R.drawable.ic_error)\n        .resetViewBeforeLoading() //\n        .delayBeforeLoading(1000)     // 延长1000ms 加载图片  （想不出来用在什么场景下）\n        .cacheInMemory()              \n        .cacheOnDisc()               \n        .preProcessor(...)            \n        .postProcessor(...)           \n        .extraForDownloader(...)      //可以向加载器携带一些参数\n        .imageScaleType(ImageScaleType.IN_SAMPLE_POWER_OF_2) // default  \n        .bitmapConfig(Bitmap.Config.ARGB_8888) // default\n        .decodingOptions(...)\n        .displayer(new SimpleBitmapDisplayer()) // default\n        .handler(new Handler()) // default\n        .build();\n```\n## 用法\n### 可接收的URL\n```\nString imageUri = \"http://site.com/image.png\"; // from Web\nString imageUri = \"file:///mnt/sdcard/image.png\"; // from SD card\nString imageUri = \"content://media/external/audio/albumart/13\"; // from content provider\nString imageUri = \"assets://image.png\"; // from assets\nString imageUri = \"drawable://\" + R.drawable.image; // from drawables (only imag\nes, non-9patch)\n```\n###例子\n```\n// Load image, decode it to Bitmap and display Bitmap in ImageView\nimageLoader.displayImage(imageUri, imageView);\n```\n```\n// Load image, decode it to Bitmap and return Bitmap to callback\nimageLoader.loadImage(imageUri, new SimpleImageLoadingListener() {\n    @Override\n    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {\n        // Do whatever you want with Bitmap\n    }\n});\n```\n### 完整版\n```\n// Load image, decode it to Bitmap and display Bitmap in ImageView\nimageLoader.displayImage(imageUri, imageView, displayOptions, new ImageLoadingListener() {\n    @Override\n    public void onLoadingStarted(String imageUri, View view) {\n        ...\n    }\n    @Override\n    public void onLoadingFailed(String imageUri, View view, FailReason failReason) {\n        ...\n    }\n    @Override\n    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {\n        ...\n    }\n    @Override\n    public void onLoadingCancelled(String imageUri, View view) {\n        ...\n    }\n});\n```\n```\nImageSize targetSize = new ImageSize(120, 80); // result Bitmap will be fit to this size\nimageLoader.loadImage(imageUri, targetSize, displayOptions, new SimpleImageLoadingListener() {\n    @Override\n    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {\n        // Do whatever you want with Bitmap\n    }\n});\n```\n###ImageLoader Helpers\n一些可能会用到的帮助类和方法\n\n```\nImageLoader |\n            | - getMemoryCache()\n            | - clearMemoryCache()\n            | - getDiscCache()\n            | - clearDiscCache()\n            | - denyNetworkDownloads(boolean)\n            | - handleSlowNetwork(boolean)\n            | - pause()\n            | - resume()\n            | - stop()\n            | - destroy()\n            | - getLoadingUriForView(ImageView)\n            | - cancelDisplayTask(ImageView)\nMemoryCacheUtil |\n                | - findCachedBitmapsForImageUri(...)\n                | - findCacheKeysForImageUri(...)\n                | - removeFromCache(...)\nDiscCacheUtil |\n              | - findInCache(...)\n              | - removeFromCache(...)\nStorageUtils |\n             | - getCacheDirectory(Context)\n             | - getIndividualCacheDirectory(Context)\n             | - getOwnCacheDirectory(Context, String)\nPauseOnScrollListener\n```\n\n## Useful Info\n\n1.使用默认值时缓存无效。如果你想要加载图片的时候使用内存/磁盘中的缓存，那么你应该这样设置DisplayImageOptions:\n\n```\n// Create default options which will be used for every\n//  displayImage(...) call if no options will be passed to this method\nDisplayImageOptions defaultOptions = new DisplayImageOptions.Builder()\n        ...\n        .cacheInMemory()\n        .cacheOnDisc()\n        ...\n        .build();\nImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext())\n        ...\n        .defaultDisplayImageOptions(defaultOptions)\n        ...\n        .build();\nImageLoader.getInstance().init(config); // Do it on Application start\n```\n```\n// Then later, when you want to display image\nImageLoader.getInstance().displayImage(imageUrl, imageView); // Default options will be used\n```\n或者这样:\n\n```\nDisplayImageOptions options = new DisplayImageOptions.Builder()\n        ...\n        .cacheInMemory()\n        .cacheOnDisc()\n        ...\n        .build();\nImageLoader.getInstance().displayImage(imageUrl, imageView, options); // Incoming options will be used\n```\n\n2.如果你允许缓存在磁盘中，那么UIL将尝试缓存到(/sdcard/Android/data/[package_name]/cache)路径中。如果外部存储不可用的话，图片将缓存在设备文件系统下。为了支持在外部存储(SD card）中缓存,那么应该在AndroidManifest.xml中加上这个权限:\n\n```\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n3.UIL如果知道Bitmap应该有多大的尺寸放在确定了点ImageView中？它搜索以下几个定义的参数：\n\n- 从ImageView测量准确的高和宽获得\n- 从android:layout_width 和 android:layout_height 参数获得\n- 从 android:maxWidth 和/或者 android:maxHeight 参数获得\n- 从在configuration定义的maximun width 和/或者 height参数获得\n- 从设备屏幕 width 和/或者 height 获得\n\nIf you often got OutOfMemoryError in your app using Universal Image Loader then try next (all of them or several):\n\n- Reduce thread pool size in configuration (.threadPoolSize(...)). 1 - 5 is recommended.\n- Use .bitmapConfig(Bitmap.Config.RGB_565) in display options. Bitmaps in RGB_565 consume 2 times less memory than in ARGB_8888.\n- Use .memoryCache(new WeakMemoryCache()) in configuration or disable caching in memory at all in display options (don't call .cacheInMemory()).\n- Use .imageScaleType(ImageScaleType.IN_SAMPLE_INT) in display options. Or try .imageScaleType(ImageScaleType.EXACTLY).\n- Avoid using RoundedBitmapDisplayer. It creates new Bitmap object with ARGB_8888 config for displaying during work.\n\n5.For memory cache configuration (ImageLoaderConfiguration.memoryCache(...)) you can use already prepared implementations.\n\n- Cache using only strong references:\nLruMemoryCache (Least recently used bitmap is deleted when cache size limit is exceeded) - Used by default for API >= 9\n- Caches using weak and strong references:\nUsingFreqLimitedMemoryCache (Least frequently used bitmap is deleted when cache size limit is exceeded)\nLRULimitedMemoryCache (Least recently used bitmap is deleted when cache size limit is exceeded) - Used by default for API < 9\nFIFOLimitedMemoryCache (FIFO rule is used for deletion when cache size limit is exceeded)\nLargestLimitedMemoryCache (The largest bitmap is deleted when cache size limit is exceeded)\nLimitedAgeMemoryCache (Decorator. Cached object is deleted when its age exceeds defined value)\n- Cache using only weak references:\nWeakMemoryCache (Unlimited cache)\n\n6.For disc cache configuration (ImageLoaderConfiguration.discCache(...)) you can use already prepared implementations:\n\n- UnlimitedDiscCache (The fastest cache, doesn't limit cache size) - Used by default\n- TotalSizeLimitedDiscCache (Cache limited by total cache size. If cache size exceeds specified limit then file with the most oldest last usage date will be deleted)\n- FileCountLimitedDiscCache (Cache limited by file count. If file count in cache directory exceeds specified limit then file with the most oldest last usage date will be deleted. Use it if your cached files are of about the same size.)\n- LimitedAgeDiscCache (Size-unlimited cache with limited files' lifetime. If age of cached file exceeds defined limit then it will be deleted from cache.)\n**NOTE: UnlimitedDiscCache is 30%-faster than other limited disc cache implementations.**\n\n7.To display bitmap (DisplayImageOptions.displayer(...)) you can use already prepared implementations:\n- RoundedBitmapDisplayer (Displays bitmap with rounded corners)\n- FadeInBitmapDisplayer (Displays image with \"fade in\" animation)\n\n8.To avoid list (grid, ...) scrolling lags you can use PauseOnScrollListener:\n\n```\nboolean pauseOnScroll = false; // or true\nboolean pauseOnFling = true; // or false\nPauseOnScrollListener listener = new PauseOnScrollListener(imageLoader, pauseOnScroll, pauseOnFling);\nlistView.setOnScrollListener(listener);\n```\n","source":"_posts/2013-05-13-android-universal-image-loader.md","raw":"---\ncategory: Android\ndate: 2013-05-13\nlayout: post\ntitle: 介绍开源项目 Android-Universal-Image-Loader -Part 1\n---\n\nGithub地址：[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader) 万能的图片加载器!  \n作者：[nostra13](https://github.com/nostra13)\n\n废话不多开始介绍\n\nThis project aims to provide a reusable instrument for asynchronous image loading, caching and displaying. It is originally based on Fedor Vlasov's project and has been vastly refactored and improved since then.\n\n作者说他也是[Fedor Vlasov's project](https://github.com/thest1/LazyList)这个项目改写过来的，做到对图片的异步加载，缓存和显示。\n\n##特性\n- 多线程图片加载\n- 尽可能多的配置选项（线程池，加载器，解析器，内存/磁盘缓存，显示参数等等）\n- 图片可以缓存在内存中，或者设备文件目录下，或者SD卡中\n- 可以监听加载进度\n- 可以自定义显示每一张图片时都带不同参数\n- 支持Widget\n\n## Quick Setup\n### 1.Include library\n[下载连接 JAR](https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/downloads/universal-image-loader-1.8.4-with-sources.jar)\n\n### 2.Android Manifest\n\n```\n<manifest>\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <!-- Include next permission if you want to allow UIL to cache images on SD card -->\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    ...\n    <application android:name=\"MyApplication\">\n        ...\n    </application>\n</manifest>\n```\n### 3. Application class\n```\npublic class MyApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // Create global configuration and initialize ImageLoader with this configuration\n        ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext())\n            ...\n            .build();\n        ImageLoader.getInstance().init(config);\n    }\n}\n```\n\n## Configuration and Display Options\n\n- Configuration(ImageLoaderConfiguration) 是相对于整个应用的配置\n- Display Options(DisplayImageOptions)是针对每一个显示图片任务所提供的参数(ImageLoader.displayImage(…)).\n\n### Configuration\n所有的选项都是可选的，只选择你真正想制定的去配置。\n\n```\n// DON'T COPY THIS CODE TO YOUR PROJECT! This is just example of ALL options using.\nFile cacheDir = StorageUtils.getCacheDirectory(context);\nImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(context)\n\t\t//如果图片尺寸大于了这个参数，那么就会这按照这个参数对图片大小进行限制并缓存\n        .memoryCacheExtraOptions(480, 800) // default=device screen dimensions\n        .discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75)\n        .taskExecutor(AsyncTask.THREAD_POOL_EXECUTOR)\n        .taskExecutorForCachedImages(AsyncTask.THREAD_POOL_EXECUTOR)\n        .threadPoolSize(3) // default\n        .threadPriority(Thread.NORM_PRIORITY - 1) // default\n        .tasksProcessingOrder(QueueProcessingType.FIFO) // default\n        .denyCacheImageMultipleSizesInMemory()\n        .memoryCache(new LruMemoryCache(2 * 1024 * 1024))\n        .memoryCacheSize(2 * 1024 * 1024)\n        .discCache(new UnlimitedDiscCache(cacheDir)) // default\n        .discCacheSize(50 * 1024 * 1024)\n        .discCacheFileCount(100)\n        .discCacheFileNameGenerator(new HashCodeFileNameGenerator()) // default\n        .imageDownloader(new BaseImageDownloader(context)) // default\n        .imageDecoder(new BaseImageDecoder()) // default\n        .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) // default\n        .enableLogging()\n        .build();\n```\n参数主要包括了这么几类配置\n1. 线程池配置\n2. 内存缓存配置\n3. 磁盘缓存配置\n4. 使用哪个图片下载器\n5. 使用哪个图片解析器\n实际上，不做任何配置也是ImageLoader也是可以使用的。\n插一句，配置选项的确够丰富，但有多是没有必要的。\n\n### Display Options\n\n显示参数可以分别被每一个显示任务调用(ImageLoader.displayImage(…))\n\nNote:**如果没有调用ImageLoader.displayImage(…),那么将使用配置选项中的默认显示参数(ImageLoaderConfiguration.defaultDisplayImageOptions(…))**\n\n```\nDisplayImageOptions options = new DisplayImageOptions.Builder()\n        .showStubImage(R.drawable.ic_stub)  // 在显示真正的图片前，会加载这个资源\n        .showImageForEmptyUri(R.drawable.ic_empty) //空的Url时\n        .showImageOnFail(R.drawable.ic_error)\n        .resetViewBeforeLoading() //\n        .delayBeforeLoading(1000)     // 延长1000ms 加载图片  （想不出来用在什么场景下）\n        .cacheInMemory()              \n        .cacheOnDisc()               \n        .preProcessor(...)            \n        .postProcessor(...)           \n        .extraForDownloader(...)      //可以向加载器携带一些参数\n        .imageScaleType(ImageScaleType.IN_SAMPLE_POWER_OF_2) // default  \n        .bitmapConfig(Bitmap.Config.ARGB_8888) // default\n        .decodingOptions(...)\n        .displayer(new SimpleBitmapDisplayer()) // default\n        .handler(new Handler()) // default\n        .build();\n```\n## 用法\n### 可接收的URL\n```\nString imageUri = \"http://site.com/image.png\"; // from Web\nString imageUri = \"file:///mnt/sdcard/image.png\"; // from SD card\nString imageUri = \"content://media/external/audio/albumart/13\"; // from content provider\nString imageUri = \"assets://image.png\"; // from assets\nString imageUri = \"drawable://\" + R.drawable.image; // from drawables (only imag\nes, non-9patch)\n```\n###例子\n```\n// Load image, decode it to Bitmap and display Bitmap in ImageView\nimageLoader.displayImage(imageUri, imageView);\n```\n```\n// Load image, decode it to Bitmap and return Bitmap to callback\nimageLoader.loadImage(imageUri, new SimpleImageLoadingListener() {\n    @Override\n    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {\n        // Do whatever you want with Bitmap\n    }\n});\n```\n### 完整版\n```\n// Load image, decode it to Bitmap and display Bitmap in ImageView\nimageLoader.displayImage(imageUri, imageView, displayOptions, new ImageLoadingListener() {\n    @Override\n    public void onLoadingStarted(String imageUri, View view) {\n        ...\n    }\n    @Override\n    public void onLoadingFailed(String imageUri, View view, FailReason failReason) {\n        ...\n    }\n    @Override\n    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {\n        ...\n    }\n    @Override\n    public void onLoadingCancelled(String imageUri, View view) {\n        ...\n    }\n});\n```\n```\nImageSize targetSize = new ImageSize(120, 80); // result Bitmap will be fit to this size\nimageLoader.loadImage(imageUri, targetSize, displayOptions, new SimpleImageLoadingListener() {\n    @Override\n    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {\n        // Do whatever you want with Bitmap\n    }\n});\n```\n###ImageLoader Helpers\n一些可能会用到的帮助类和方法\n\n```\nImageLoader |\n            | - getMemoryCache()\n            | - clearMemoryCache()\n            | - getDiscCache()\n            | - clearDiscCache()\n            | - denyNetworkDownloads(boolean)\n            | - handleSlowNetwork(boolean)\n            | - pause()\n            | - resume()\n            | - stop()\n            | - destroy()\n            | - getLoadingUriForView(ImageView)\n            | - cancelDisplayTask(ImageView)\nMemoryCacheUtil |\n                | - findCachedBitmapsForImageUri(...)\n                | - findCacheKeysForImageUri(...)\n                | - removeFromCache(...)\nDiscCacheUtil |\n              | - findInCache(...)\n              | - removeFromCache(...)\nStorageUtils |\n             | - getCacheDirectory(Context)\n             | - getIndividualCacheDirectory(Context)\n             | - getOwnCacheDirectory(Context, String)\nPauseOnScrollListener\n```\n\n## Useful Info\n\n1.使用默认值时缓存无效。如果你想要加载图片的时候使用内存/磁盘中的缓存，那么你应该这样设置DisplayImageOptions:\n\n```\n// Create default options which will be used for every\n//  displayImage(...) call if no options will be passed to this method\nDisplayImageOptions defaultOptions = new DisplayImageOptions.Builder()\n        ...\n        .cacheInMemory()\n        .cacheOnDisc()\n        ...\n        .build();\nImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext())\n        ...\n        .defaultDisplayImageOptions(defaultOptions)\n        ...\n        .build();\nImageLoader.getInstance().init(config); // Do it on Application start\n```\n```\n// Then later, when you want to display image\nImageLoader.getInstance().displayImage(imageUrl, imageView); // Default options will be used\n```\n或者这样:\n\n```\nDisplayImageOptions options = new DisplayImageOptions.Builder()\n        ...\n        .cacheInMemory()\n        .cacheOnDisc()\n        ...\n        .build();\nImageLoader.getInstance().displayImage(imageUrl, imageView, options); // Incoming options will be used\n```\n\n2.如果你允许缓存在磁盘中，那么UIL将尝试缓存到(/sdcard/Android/data/[package_name]/cache)路径中。如果外部存储不可用的话，图片将缓存在设备文件系统下。为了支持在外部存储(SD card）中缓存,那么应该在AndroidManifest.xml中加上这个权限:\n\n```\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n3.UIL如果知道Bitmap应该有多大的尺寸放在确定了点ImageView中？它搜索以下几个定义的参数：\n\n- 从ImageView测量准确的高和宽获得\n- 从android:layout_width 和 android:layout_height 参数获得\n- 从 android:maxWidth 和/或者 android:maxHeight 参数获得\n- 从在configuration定义的maximun width 和/或者 height参数获得\n- 从设备屏幕 width 和/或者 height 获得\n\nIf you often got OutOfMemoryError in your app using Universal Image Loader then try next (all of them or several):\n\n- Reduce thread pool size in configuration (.threadPoolSize(...)). 1 - 5 is recommended.\n- Use .bitmapConfig(Bitmap.Config.RGB_565) in display options. Bitmaps in RGB_565 consume 2 times less memory than in ARGB_8888.\n- Use .memoryCache(new WeakMemoryCache()) in configuration or disable caching in memory at all in display options (don't call .cacheInMemory()).\n- Use .imageScaleType(ImageScaleType.IN_SAMPLE_INT) in display options. Or try .imageScaleType(ImageScaleType.EXACTLY).\n- Avoid using RoundedBitmapDisplayer. It creates new Bitmap object with ARGB_8888 config for displaying during work.\n\n5.For memory cache configuration (ImageLoaderConfiguration.memoryCache(...)) you can use already prepared implementations.\n\n- Cache using only strong references:\nLruMemoryCache (Least recently used bitmap is deleted when cache size limit is exceeded) - Used by default for API >= 9\n- Caches using weak and strong references:\nUsingFreqLimitedMemoryCache (Least frequently used bitmap is deleted when cache size limit is exceeded)\nLRULimitedMemoryCache (Least recently used bitmap is deleted when cache size limit is exceeded) - Used by default for API < 9\nFIFOLimitedMemoryCache (FIFO rule is used for deletion when cache size limit is exceeded)\nLargestLimitedMemoryCache (The largest bitmap is deleted when cache size limit is exceeded)\nLimitedAgeMemoryCache (Decorator. Cached object is deleted when its age exceeds defined value)\n- Cache using only weak references:\nWeakMemoryCache (Unlimited cache)\n\n6.For disc cache configuration (ImageLoaderConfiguration.discCache(...)) you can use already prepared implementations:\n\n- UnlimitedDiscCache (The fastest cache, doesn't limit cache size) - Used by default\n- TotalSizeLimitedDiscCache (Cache limited by total cache size. If cache size exceeds specified limit then file with the most oldest last usage date will be deleted)\n- FileCountLimitedDiscCache (Cache limited by file count. If file count in cache directory exceeds specified limit then file with the most oldest last usage date will be deleted. Use it if your cached files are of about the same size.)\n- LimitedAgeDiscCache (Size-unlimited cache with limited files' lifetime. If age of cached file exceeds defined limit then it will be deleted from cache.)\n**NOTE: UnlimitedDiscCache is 30%-faster than other limited disc cache implementations.**\n\n7.To display bitmap (DisplayImageOptions.displayer(...)) you can use already prepared implementations:\n- RoundedBitmapDisplayer (Displays bitmap with rounded corners)\n- FadeInBitmapDisplayer (Displays image with \"fade in\" animation)\n\n8.To avoid list (grid, ...) scrolling lags you can use PauseOnScrollListener:\n\n```\nboolean pauseOnScroll = false; // or true\nboolean pauseOnFling = true; // or false\nPauseOnScrollListener listener = new PauseOnScrollListener(imageLoader, pauseOnScroll, pauseOnFling);\nlistView.setOnScrollListener(listener);\n```\n","slug":"2013-05-13-android-universal-image-loader","published":1,"updated":"2018-02-14T21:36:14.831Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tkl0008rpfydn76qa5q","content":"<p>Github地址：<a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\" target=\"_blank\" rel=\"noopener\">Android-Universal-Image-Loader</a> 万能的图片加载器!<br>作者：<a href=\"https://github.com/nostra13\" target=\"_blank\" rel=\"noopener\">nostra13</a></p>\n<p>废话不多开始介绍</p>\n<p>This project aims to provide a reusable instrument for asynchronous image loading, caching and displaying. It is originally based on Fedor Vlasov’s project and has been vastly refactored and improved since then.</p>\n<p>作者说他也是<a href=\"https://github.com/thest1/LazyList\" target=\"_blank\" rel=\"noopener\">Fedor Vlasov’s project</a>这个项目改写过来的，做到对图片的异步加载，缓存和显示。</p>\n<p>##特性</p>\n<ul>\n<li>多线程图片加载</li>\n<li>尽可能多的配置选项（线程池，加载器，解析器，内存/磁盘缓存，显示参数等等）</li>\n<li>图片可以缓存在内存中，或者设备文件目录下，或者SD卡中</li>\n<li>可以监听加载进度</li>\n<li>可以自定义显示每一张图片时都带不同参数</li>\n<li>支持Widget</li>\n</ul>\n<h2 id=\"Quick-Setup\"><a href=\"#Quick-Setup\" class=\"headerlink\" title=\"Quick Setup\"></a>Quick Setup</h2><h3 id=\"1-Include-library\"><a href=\"#1-Include-library\" class=\"headerlink\" title=\"1.Include library\"></a>1.Include library</h3><p><a href=\"https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/downloads/universal-image-loader-1.8.4-with-sources.jar\" target=\"_blank\" rel=\"noopener\">下载连接 JAR</a></p>\n<h3 id=\"2-Android-Manifest\"><a href=\"#2-Android-Manifest\" class=\"headerlink\" title=\"2.Android Manifest\"></a>2.Android Manifest</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest&gt;</span><br><span class=\"line\">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class=\"line\">    &lt;!-- Include next permission if you want to allow UIL to cache images on SD card --&gt;</span><br><span class=\"line\">    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;application android:name=&quot;MyApplication&quot;&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &lt;/application&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-Application-class\"><a href=\"#3-Application-class\" class=\"headerlink\" title=\"3. Application class\"></a>3. Application class</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyApplication extends Application &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate() &#123;</span><br><span class=\"line\">        super.onCreate();</span><br><span class=\"line\">        // Create global configuration and initialize ImageLoader with this configuration</span><br><span class=\"line\">        ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext())</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">        ImageLoader.getInstance().init(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Configuration-and-Display-Options\"><a href=\"#Configuration-and-Display-Options\" class=\"headerlink\" title=\"Configuration and Display Options\"></a>Configuration and Display Options</h2><ul>\n<li>Configuration(ImageLoaderConfiguration) 是相对于整个应用的配置</li>\n<li>Display Options(DisplayImageOptions)是针对每一个显示图片任务所提供的参数(ImageLoader.displayImage(…)).</li>\n</ul>\n<h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a>Configuration</h3><p>所有的选项都是可选的，只选择你真正想制定的去配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// DON&apos;T COPY THIS CODE TO YOUR PROJECT! This is just example of ALL options using.</span><br><span class=\"line\">File cacheDir = StorageUtils.getCacheDirectory(context);</span><br><span class=\"line\">ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(context)</span><br><span class=\"line\">\t\t//如果图片尺寸大于了这个参数，那么就会这按照这个参数对图片大小进行限制并缓存</span><br><span class=\"line\">        .memoryCacheExtraOptions(480, 800) // default=device screen dimensions</span><br><span class=\"line\">        .discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75)</span><br><span class=\"line\">        .taskExecutor(AsyncTask.THREAD_POOL_EXECUTOR)</span><br><span class=\"line\">        .taskExecutorForCachedImages(AsyncTask.THREAD_POOL_EXECUTOR)</span><br><span class=\"line\">        .threadPoolSize(3) // default</span><br><span class=\"line\">        .threadPriority(Thread.NORM_PRIORITY - 1) // default</span><br><span class=\"line\">        .tasksProcessingOrder(QueueProcessingType.FIFO) // default</span><br><span class=\"line\">        .denyCacheImageMultipleSizesInMemory()</span><br><span class=\"line\">        .memoryCache(new LruMemoryCache(2 * 1024 * 1024))</span><br><span class=\"line\">        .memoryCacheSize(2 * 1024 * 1024)</span><br><span class=\"line\">        .discCache(new UnlimitedDiscCache(cacheDir)) // default</span><br><span class=\"line\">        .discCacheSize(50 * 1024 * 1024)</span><br><span class=\"line\">        .discCacheFileCount(100)</span><br><span class=\"line\">        .discCacheFileNameGenerator(new HashCodeFileNameGenerator()) // default</span><br><span class=\"line\">        .imageDownloader(new BaseImageDownloader(context)) // default</span><br><span class=\"line\">        .imageDecoder(new BaseImageDecoder()) // default</span><br><span class=\"line\">        .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) // default</span><br><span class=\"line\">        .enableLogging()</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<p>参数主要包括了这么几类配置</p>\n<ol>\n<li>线程池配置</li>\n<li>内存缓存配置</li>\n<li>磁盘缓存配置</li>\n<li>使用哪个图片下载器</li>\n<li>使用哪个图片解析器<br>实际上，不做任何配置也是ImageLoader也是可以使用的。<br>插一句，配置选项的确够丰富，但有多是没有必要的。</li>\n</ol>\n<h3 id=\"Display-Options\"><a href=\"#Display-Options\" class=\"headerlink\" title=\"Display Options\"></a>Display Options</h3><p>显示参数可以分别被每一个显示任务调用(ImageLoader.displayImage(…))</p>\n<p>Note:<strong>如果没有调用ImageLoader.displayImage(…),那么将使用配置选项中的默认显示参数(ImageLoaderConfiguration.defaultDisplayImageOptions(…))</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisplayImageOptions options = new DisplayImageOptions.Builder()</span><br><span class=\"line\">        .showStubImage(R.drawable.ic_stub)  // 在显示真正的图片前，会加载这个资源</span><br><span class=\"line\">        .showImageForEmptyUri(R.drawable.ic_empty) //空的Url时</span><br><span class=\"line\">        .showImageOnFail(R.drawable.ic_error)</span><br><span class=\"line\">        .resetViewBeforeLoading() //</span><br><span class=\"line\">        .delayBeforeLoading(1000)     // 延长1000ms 加载图片  （想不出来用在什么场景下）</span><br><span class=\"line\">        .cacheInMemory()              </span><br><span class=\"line\">        .cacheOnDisc()               </span><br><span class=\"line\">        .preProcessor(...)            </span><br><span class=\"line\">        .postProcessor(...)           </span><br><span class=\"line\">        .extraForDownloader(...)      //可以向加载器携带一些参数</span><br><span class=\"line\">        .imageScaleType(ImageScaleType.IN_SAMPLE_POWER_OF_2) // default  </span><br><span class=\"line\">        .bitmapConfig(Bitmap.Config.ARGB_8888) // default</span><br><span class=\"line\">        .decodingOptions(...)</span><br><span class=\"line\">        .displayer(new SimpleBitmapDisplayer()) // default</span><br><span class=\"line\">        .handler(new Handler()) // default</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><h3 id=\"可接收的URL\"><a href=\"#可接收的URL\" class=\"headerlink\" title=\"可接收的URL\"></a>可接收的URL</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String imageUri = &quot;http://site.com/image.png&quot;; // from Web</span><br><span class=\"line\">String imageUri = &quot;file:///mnt/sdcard/image.png&quot;; // from SD card</span><br><span class=\"line\">String imageUri = &quot;content://media/external/audio/albumart/13&quot;; // from content provider</span><br><span class=\"line\">String imageUri = &quot;assets://image.png&quot;; // from assets</span><br><span class=\"line\">String imageUri = &quot;drawable://&quot; + R.drawable.image; // from drawables (only imag</span><br><span class=\"line\">es, non-9patch)</span><br></pre></td></tr></table></figure>\n<p>###例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Load image, decode it to Bitmap and display Bitmap in ImageView</span><br><span class=\"line\">imageLoader.displayImage(imageUri, imageView);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Load image, decode it to Bitmap and return Bitmap to callback</span><br><span class=\"line\">imageLoader.loadImage(imageUri, new SimpleImageLoadingListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</span><br><span class=\"line\">        // Do whatever you want with Bitmap</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"完整版\"><a href=\"#完整版\" class=\"headerlink\" title=\"完整版\"></a>完整版</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Load image, decode it to Bitmap and display Bitmap in ImageView</span><br><span class=\"line\">imageLoader.displayImage(imageUri, imageView, displayOptions, new ImageLoadingListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingStarted(String imageUri, View view) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingFailed(String imageUri, View view, FailReason failReason) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingCancelled(String imageUri, View view) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ImageSize targetSize = new ImageSize(120, 80); // result Bitmap will be fit to this size</span><br><span class=\"line\">imageLoader.loadImage(imageUri, targetSize, displayOptions, new SimpleImageLoadingListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</span><br><span class=\"line\">        // Do whatever you want with Bitmap</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>###ImageLoader Helpers<br>一些可能会用到的帮助类和方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ImageLoader |</span><br><span class=\"line\">            | - getMemoryCache()</span><br><span class=\"line\">            | - clearMemoryCache()</span><br><span class=\"line\">            | - getDiscCache()</span><br><span class=\"line\">            | - clearDiscCache()</span><br><span class=\"line\">            | - denyNetworkDownloads(boolean)</span><br><span class=\"line\">            | - handleSlowNetwork(boolean)</span><br><span class=\"line\">            | - pause()</span><br><span class=\"line\">            | - resume()</span><br><span class=\"line\">            | - stop()</span><br><span class=\"line\">            | - destroy()</span><br><span class=\"line\">            | - getLoadingUriForView(ImageView)</span><br><span class=\"line\">            | - cancelDisplayTask(ImageView)</span><br><span class=\"line\">MemoryCacheUtil |</span><br><span class=\"line\">                | - findCachedBitmapsForImageUri(...)</span><br><span class=\"line\">                | - findCacheKeysForImageUri(...)</span><br><span class=\"line\">                | - removeFromCache(...)</span><br><span class=\"line\">DiscCacheUtil |</span><br><span class=\"line\">              | - findInCache(...)</span><br><span class=\"line\">              | - removeFromCache(...)</span><br><span class=\"line\">StorageUtils |</span><br><span class=\"line\">             | - getCacheDirectory(Context)</span><br><span class=\"line\">             | - getIndividualCacheDirectory(Context)</span><br><span class=\"line\">             | - getOwnCacheDirectory(Context, String)</span><br><span class=\"line\">PauseOnScrollListener</span><br></pre></td></tr></table></figure>\n<h2 id=\"Useful-Info\"><a href=\"#Useful-Info\" class=\"headerlink\" title=\"Useful Info\"></a>Useful Info</h2><p>1.使用默认值时缓存无效。如果你想要加载图片的时候使用内存/磁盘中的缓存，那么你应该这样设置DisplayImageOptions:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create default options which will be used for every</span><br><span class=\"line\">//  displayImage(...) call if no options will be passed to this method</span><br><span class=\"line\">DisplayImageOptions defaultOptions = new DisplayImageOptions.Builder()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .cacheInMemory()</span><br><span class=\"line\">        .cacheOnDisc()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext())</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .defaultDisplayImageOptions(defaultOptions)</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">ImageLoader.getInstance().init(config); // Do it on Application start</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Then later, when you want to display image</span><br><span class=\"line\">ImageLoader.getInstance().displayImage(imageUrl, imageView); // Default options will be used</span><br></pre></td></tr></table></figure>\n<p>或者这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisplayImageOptions options = new DisplayImageOptions.Builder()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .cacheInMemory()</span><br><span class=\"line\">        .cacheOnDisc()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">ImageLoader.getInstance().displayImage(imageUrl, imageView, options); // Incoming options will be used</span><br></pre></td></tr></table></figure>\n<p>2.如果你允许缓存在磁盘中，那么UIL将尝试缓存到(/sdcard/Android/data/[package_name]/cache)路径中。如果外部存储不可用的话，图片将缓存在设备文件系统下。为了支持在外部存储(SD card）中缓存,那么应该在AndroidManifest.xml中加上这个权限:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>3.UIL如果知道Bitmap应该有多大的尺寸放在确定了点ImageView中？它搜索以下几个定义的参数：</p>\n<ul>\n<li>从ImageView测量准确的高和宽获得</li>\n<li>从android:layout_width 和 android:layout_height 参数获得</li>\n<li>从 android:maxWidth 和/或者 android:maxHeight 参数获得</li>\n<li>从在configuration定义的maximun width 和/或者 height参数获得</li>\n<li>从设备屏幕 width 和/或者 height 获得</li>\n</ul>\n<p>If you often got OutOfMemoryError in your app using Universal Image Loader then try next (all of them or several):</p>\n<ul>\n<li>Reduce thread pool size in configuration (.threadPoolSize(…)). 1 - 5 is recommended.</li>\n<li>Use .bitmapConfig(Bitmap.Config.RGB_565) in display options. Bitmaps in RGB_565 consume 2 times less memory than in ARGB_8888.</li>\n<li>Use .memoryCache(new WeakMemoryCache()) in configuration or disable caching in memory at all in display options (don’t call .cacheInMemory()).</li>\n<li>Use .imageScaleType(ImageScaleType.IN_SAMPLE_INT) in display options. Or try .imageScaleType(ImageScaleType.EXACTLY).</li>\n<li>Avoid using RoundedBitmapDisplayer. It creates new Bitmap object with ARGB_8888 config for displaying during work.</li>\n</ul>\n<p>5.For memory cache configuration (ImageLoaderConfiguration.memoryCache(…)) you can use already prepared implementations.</p>\n<ul>\n<li>Cache using only strong references:<br>LruMemoryCache (Least recently used bitmap is deleted when cache size limit is exceeded) - Used by default for API &gt;= 9</li>\n<li>Caches using weak and strong references:<br>UsingFreqLimitedMemoryCache (Least frequently used bitmap is deleted when cache size limit is exceeded)<br>LRULimitedMemoryCache (Least recently used bitmap is deleted when cache size limit is exceeded) - Used by default for API &lt; 9<br>FIFOLimitedMemoryCache (FIFO rule is used for deletion when cache size limit is exceeded)<br>LargestLimitedMemoryCache (The largest bitmap is deleted when cache size limit is exceeded)<br>LimitedAgeMemoryCache (Decorator. Cached object is deleted when its age exceeds defined value)</li>\n<li>Cache using only weak references:<br>WeakMemoryCache (Unlimited cache)</li>\n</ul>\n<p>6.For disc cache configuration (ImageLoaderConfiguration.discCache(…)) you can use already prepared implementations:</p>\n<ul>\n<li>UnlimitedDiscCache (The fastest cache, doesn’t limit cache size) - Used by default</li>\n<li>TotalSizeLimitedDiscCache (Cache limited by total cache size. If cache size exceeds specified limit then file with the most oldest last usage date will be deleted)</li>\n<li>FileCountLimitedDiscCache (Cache limited by file count. If file count in cache directory exceeds specified limit then file with the most oldest last usage date will be deleted. Use it if your cached files are of about the same size.)</li>\n<li>LimitedAgeDiscCache (Size-unlimited cache with limited files’ lifetime. If age of cached file exceeds defined limit then it will be deleted from cache.)<br><strong>NOTE: UnlimitedDiscCache is 30%-faster than other limited disc cache implementations.</strong></li>\n</ul>\n<p>7.To display bitmap (DisplayImageOptions.displayer(…)) you can use already prepared implementations:</p>\n<ul>\n<li>RoundedBitmapDisplayer (Displays bitmap with rounded corners)</li>\n<li>FadeInBitmapDisplayer (Displays image with “fade in” animation)</li>\n</ul>\n<p>8.To avoid list (grid, …) scrolling lags you can use PauseOnScrollListener:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean pauseOnScroll = false; // or true</span><br><span class=\"line\">boolean pauseOnFling = true; // or false</span><br><span class=\"line\">PauseOnScrollListener listener = new PauseOnScrollListener(imageLoader, pauseOnScroll, pauseOnFling);</span><br><span class=\"line\">listView.setOnScrollListener(listener);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Github地址：<a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\" target=\"_blank\" rel=\"noopener\">Android-Universal-Image-Loader</a> 万能的图片加载器!<br>作者：<a href=\"https://github.com/nostra13\" target=\"_blank\" rel=\"noopener\">nostra13</a></p>\n<p>废话不多开始介绍</p>\n<p>This project aims to provide a reusable instrument for asynchronous image loading, caching and displaying. It is originally based on Fedor Vlasov’s project and has been vastly refactored and improved since then.</p>\n<p>作者说他也是<a href=\"https://github.com/thest1/LazyList\" target=\"_blank\" rel=\"noopener\">Fedor Vlasov’s project</a>这个项目改写过来的，做到对图片的异步加载，缓存和显示。</p>\n<p>##特性</p>\n<ul>\n<li>多线程图片加载</li>\n<li>尽可能多的配置选项（线程池，加载器，解析器，内存/磁盘缓存，显示参数等等）</li>\n<li>图片可以缓存在内存中，或者设备文件目录下，或者SD卡中</li>\n<li>可以监听加载进度</li>\n<li>可以自定义显示每一张图片时都带不同参数</li>\n<li>支持Widget</li>\n</ul>\n<h2 id=\"Quick-Setup\"><a href=\"#Quick-Setup\" class=\"headerlink\" title=\"Quick Setup\"></a>Quick Setup</h2><h3 id=\"1-Include-library\"><a href=\"#1-Include-library\" class=\"headerlink\" title=\"1.Include library\"></a>1.Include library</h3><p><a href=\"https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/downloads/universal-image-loader-1.8.4-with-sources.jar\" target=\"_blank\" rel=\"noopener\">下载连接 JAR</a></p>\n<h3 id=\"2-Android-Manifest\"><a href=\"#2-Android-Manifest\" class=\"headerlink\" title=\"2.Android Manifest\"></a>2.Android Manifest</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest&gt;</span><br><span class=\"line\">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class=\"line\">    &lt;!-- Include next permission if you want to allow UIL to cache images on SD card --&gt;</span><br><span class=\"line\">    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;application android:name=&quot;MyApplication&quot;&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &lt;/application&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-Application-class\"><a href=\"#3-Application-class\" class=\"headerlink\" title=\"3. Application class\"></a>3. Application class</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyApplication extends Application &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate() &#123;</span><br><span class=\"line\">        super.onCreate();</span><br><span class=\"line\">        // Create global configuration and initialize ImageLoader with this configuration</span><br><span class=\"line\">        ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext())</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">        ImageLoader.getInstance().init(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Configuration-and-Display-Options\"><a href=\"#Configuration-and-Display-Options\" class=\"headerlink\" title=\"Configuration and Display Options\"></a>Configuration and Display Options</h2><ul>\n<li>Configuration(ImageLoaderConfiguration) 是相对于整个应用的配置</li>\n<li>Display Options(DisplayImageOptions)是针对每一个显示图片任务所提供的参数(ImageLoader.displayImage(…)).</li>\n</ul>\n<h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a>Configuration</h3><p>所有的选项都是可选的，只选择你真正想制定的去配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// DON&apos;T COPY THIS CODE TO YOUR PROJECT! This is just example of ALL options using.</span><br><span class=\"line\">File cacheDir = StorageUtils.getCacheDirectory(context);</span><br><span class=\"line\">ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(context)</span><br><span class=\"line\">\t\t//如果图片尺寸大于了这个参数，那么就会这按照这个参数对图片大小进行限制并缓存</span><br><span class=\"line\">        .memoryCacheExtraOptions(480, 800) // default=device screen dimensions</span><br><span class=\"line\">        .discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75)</span><br><span class=\"line\">        .taskExecutor(AsyncTask.THREAD_POOL_EXECUTOR)</span><br><span class=\"line\">        .taskExecutorForCachedImages(AsyncTask.THREAD_POOL_EXECUTOR)</span><br><span class=\"line\">        .threadPoolSize(3) // default</span><br><span class=\"line\">        .threadPriority(Thread.NORM_PRIORITY - 1) // default</span><br><span class=\"line\">        .tasksProcessingOrder(QueueProcessingType.FIFO) // default</span><br><span class=\"line\">        .denyCacheImageMultipleSizesInMemory()</span><br><span class=\"line\">        .memoryCache(new LruMemoryCache(2 * 1024 * 1024))</span><br><span class=\"line\">        .memoryCacheSize(2 * 1024 * 1024)</span><br><span class=\"line\">        .discCache(new UnlimitedDiscCache(cacheDir)) // default</span><br><span class=\"line\">        .discCacheSize(50 * 1024 * 1024)</span><br><span class=\"line\">        .discCacheFileCount(100)</span><br><span class=\"line\">        .discCacheFileNameGenerator(new HashCodeFileNameGenerator()) // default</span><br><span class=\"line\">        .imageDownloader(new BaseImageDownloader(context)) // default</span><br><span class=\"line\">        .imageDecoder(new BaseImageDecoder()) // default</span><br><span class=\"line\">        .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) // default</span><br><span class=\"line\">        .enableLogging()</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<p>参数主要包括了这么几类配置</p>\n<ol>\n<li>线程池配置</li>\n<li>内存缓存配置</li>\n<li>磁盘缓存配置</li>\n<li>使用哪个图片下载器</li>\n<li>使用哪个图片解析器<br>实际上，不做任何配置也是ImageLoader也是可以使用的。<br>插一句，配置选项的确够丰富，但有多是没有必要的。</li>\n</ol>\n<h3 id=\"Display-Options\"><a href=\"#Display-Options\" class=\"headerlink\" title=\"Display Options\"></a>Display Options</h3><p>显示参数可以分别被每一个显示任务调用(ImageLoader.displayImage(…))</p>\n<p>Note:<strong>如果没有调用ImageLoader.displayImage(…),那么将使用配置选项中的默认显示参数(ImageLoaderConfiguration.defaultDisplayImageOptions(…))</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisplayImageOptions options = new DisplayImageOptions.Builder()</span><br><span class=\"line\">        .showStubImage(R.drawable.ic_stub)  // 在显示真正的图片前，会加载这个资源</span><br><span class=\"line\">        .showImageForEmptyUri(R.drawable.ic_empty) //空的Url时</span><br><span class=\"line\">        .showImageOnFail(R.drawable.ic_error)</span><br><span class=\"line\">        .resetViewBeforeLoading() //</span><br><span class=\"line\">        .delayBeforeLoading(1000)     // 延长1000ms 加载图片  （想不出来用在什么场景下）</span><br><span class=\"line\">        .cacheInMemory()              </span><br><span class=\"line\">        .cacheOnDisc()               </span><br><span class=\"line\">        .preProcessor(...)            </span><br><span class=\"line\">        .postProcessor(...)           </span><br><span class=\"line\">        .extraForDownloader(...)      //可以向加载器携带一些参数</span><br><span class=\"line\">        .imageScaleType(ImageScaleType.IN_SAMPLE_POWER_OF_2) // default  </span><br><span class=\"line\">        .bitmapConfig(Bitmap.Config.ARGB_8888) // default</span><br><span class=\"line\">        .decodingOptions(...)</span><br><span class=\"line\">        .displayer(new SimpleBitmapDisplayer()) // default</span><br><span class=\"line\">        .handler(new Handler()) // default</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><h3 id=\"可接收的URL\"><a href=\"#可接收的URL\" class=\"headerlink\" title=\"可接收的URL\"></a>可接收的URL</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String imageUri = &quot;http://site.com/image.png&quot;; // from Web</span><br><span class=\"line\">String imageUri = &quot;file:///mnt/sdcard/image.png&quot;; // from SD card</span><br><span class=\"line\">String imageUri = &quot;content://media/external/audio/albumart/13&quot;; // from content provider</span><br><span class=\"line\">String imageUri = &quot;assets://image.png&quot;; // from assets</span><br><span class=\"line\">String imageUri = &quot;drawable://&quot; + R.drawable.image; // from drawables (only imag</span><br><span class=\"line\">es, non-9patch)</span><br></pre></td></tr></table></figure>\n<p>###例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Load image, decode it to Bitmap and display Bitmap in ImageView</span><br><span class=\"line\">imageLoader.displayImage(imageUri, imageView);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Load image, decode it to Bitmap and return Bitmap to callback</span><br><span class=\"line\">imageLoader.loadImage(imageUri, new SimpleImageLoadingListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</span><br><span class=\"line\">        // Do whatever you want with Bitmap</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"完整版\"><a href=\"#完整版\" class=\"headerlink\" title=\"完整版\"></a>完整版</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Load image, decode it to Bitmap and display Bitmap in ImageView</span><br><span class=\"line\">imageLoader.displayImage(imageUri, imageView, displayOptions, new ImageLoadingListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingStarted(String imageUri, View view) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingFailed(String imageUri, View view, FailReason failReason) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingCancelled(String imageUri, View view) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ImageSize targetSize = new ImageSize(120, 80); // result Bitmap will be fit to this size</span><br><span class=\"line\">imageLoader.loadImage(imageUri, targetSize, displayOptions, new SimpleImageLoadingListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</span><br><span class=\"line\">        // Do whatever you want with Bitmap</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>###ImageLoader Helpers<br>一些可能会用到的帮助类和方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ImageLoader |</span><br><span class=\"line\">            | - getMemoryCache()</span><br><span class=\"line\">            | - clearMemoryCache()</span><br><span class=\"line\">            | - getDiscCache()</span><br><span class=\"line\">            | - clearDiscCache()</span><br><span class=\"line\">            | - denyNetworkDownloads(boolean)</span><br><span class=\"line\">            | - handleSlowNetwork(boolean)</span><br><span class=\"line\">            | - pause()</span><br><span class=\"line\">            | - resume()</span><br><span class=\"line\">            | - stop()</span><br><span class=\"line\">            | - destroy()</span><br><span class=\"line\">            | - getLoadingUriForView(ImageView)</span><br><span class=\"line\">            | - cancelDisplayTask(ImageView)</span><br><span class=\"line\">MemoryCacheUtil |</span><br><span class=\"line\">                | - findCachedBitmapsForImageUri(...)</span><br><span class=\"line\">                | - findCacheKeysForImageUri(...)</span><br><span class=\"line\">                | - removeFromCache(...)</span><br><span class=\"line\">DiscCacheUtil |</span><br><span class=\"line\">              | - findInCache(...)</span><br><span class=\"line\">              | - removeFromCache(...)</span><br><span class=\"line\">StorageUtils |</span><br><span class=\"line\">             | - getCacheDirectory(Context)</span><br><span class=\"line\">             | - getIndividualCacheDirectory(Context)</span><br><span class=\"line\">             | - getOwnCacheDirectory(Context, String)</span><br><span class=\"line\">PauseOnScrollListener</span><br></pre></td></tr></table></figure>\n<h2 id=\"Useful-Info\"><a href=\"#Useful-Info\" class=\"headerlink\" title=\"Useful Info\"></a>Useful Info</h2><p>1.使用默认值时缓存无效。如果你想要加载图片的时候使用内存/磁盘中的缓存，那么你应该这样设置DisplayImageOptions:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create default options which will be used for every</span><br><span class=\"line\">//  displayImage(...) call if no options will be passed to this method</span><br><span class=\"line\">DisplayImageOptions defaultOptions = new DisplayImageOptions.Builder()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .cacheInMemory()</span><br><span class=\"line\">        .cacheOnDisc()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext())</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .defaultDisplayImageOptions(defaultOptions)</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">ImageLoader.getInstance().init(config); // Do it on Application start</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Then later, when you want to display image</span><br><span class=\"line\">ImageLoader.getInstance().displayImage(imageUrl, imageView); // Default options will be used</span><br></pre></td></tr></table></figure>\n<p>或者这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisplayImageOptions options = new DisplayImageOptions.Builder()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .cacheInMemory()</span><br><span class=\"line\">        .cacheOnDisc()</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">ImageLoader.getInstance().displayImage(imageUrl, imageView, options); // Incoming options will be used</span><br></pre></td></tr></table></figure>\n<p>2.如果你允许缓存在磁盘中，那么UIL将尝试缓存到(/sdcard/Android/data/[package_name]/cache)路径中。如果外部存储不可用的话，图片将缓存在设备文件系统下。为了支持在外部存储(SD card）中缓存,那么应该在AndroidManifest.xml中加上这个权限:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>3.UIL如果知道Bitmap应该有多大的尺寸放在确定了点ImageView中？它搜索以下几个定义的参数：</p>\n<ul>\n<li>从ImageView测量准确的高和宽获得</li>\n<li>从android:layout_width 和 android:layout_height 参数获得</li>\n<li>从 android:maxWidth 和/或者 android:maxHeight 参数获得</li>\n<li>从在configuration定义的maximun width 和/或者 height参数获得</li>\n<li>从设备屏幕 width 和/或者 height 获得</li>\n</ul>\n<p>If you often got OutOfMemoryError in your app using Universal Image Loader then try next (all of them or several):</p>\n<ul>\n<li>Reduce thread pool size in configuration (.threadPoolSize(…)). 1 - 5 is recommended.</li>\n<li>Use .bitmapConfig(Bitmap.Config.RGB_565) in display options. Bitmaps in RGB_565 consume 2 times less memory than in ARGB_8888.</li>\n<li>Use .memoryCache(new WeakMemoryCache()) in configuration or disable caching in memory at all in display options (don’t call .cacheInMemory()).</li>\n<li>Use .imageScaleType(ImageScaleType.IN_SAMPLE_INT) in display options. Or try .imageScaleType(ImageScaleType.EXACTLY).</li>\n<li>Avoid using RoundedBitmapDisplayer. It creates new Bitmap object with ARGB_8888 config for displaying during work.</li>\n</ul>\n<p>5.For memory cache configuration (ImageLoaderConfiguration.memoryCache(…)) you can use already prepared implementations.</p>\n<ul>\n<li>Cache using only strong references:<br>LruMemoryCache (Least recently used bitmap is deleted when cache size limit is exceeded) - Used by default for API &gt;= 9</li>\n<li>Caches using weak and strong references:<br>UsingFreqLimitedMemoryCache (Least frequently used bitmap is deleted when cache size limit is exceeded)<br>LRULimitedMemoryCache (Least recently used bitmap is deleted when cache size limit is exceeded) - Used by default for API &lt; 9<br>FIFOLimitedMemoryCache (FIFO rule is used for deletion when cache size limit is exceeded)<br>LargestLimitedMemoryCache (The largest bitmap is deleted when cache size limit is exceeded)<br>LimitedAgeMemoryCache (Decorator. Cached object is deleted when its age exceeds defined value)</li>\n<li>Cache using only weak references:<br>WeakMemoryCache (Unlimited cache)</li>\n</ul>\n<p>6.For disc cache configuration (ImageLoaderConfiguration.discCache(…)) you can use already prepared implementations:</p>\n<ul>\n<li>UnlimitedDiscCache (The fastest cache, doesn’t limit cache size) - Used by default</li>\n<li>TotalSizeLimitedDiscCache (Cache limited by total cache size. If cache size exceeds specified limit then file with the most oldest last usage date will be deleted)</li>\n<li>FileCountLimitedDiscCache (Cache limited by file count. If file count in cache directory exceeds specified limit then file with the most oldest last usage date will be deleted. Use it if your cached files are of about the same size.)</li>\n<li>LimitedAgeDiscCache (Size-unlimited cache with limited files’ lifetime. If age of cached file exceeds defined limit then it will be deleted from cache.)<br><strong>NOTE: UnlimitedDiscCache is 30%-faster than other limited disc cache implementations.</strong></li>\n</ul>\n<p>7.To display bitmap (DisplayImageOptions.displayer(…)) you can use already prepared implementations:</p>\n<ul>\n<li>RoundedBitmapDisplayer (Displays bitmap with rounded corners)</li>\n<li>FadeInBitmapDisplayer (Displays image with “fade in” animation)</li>\n</ul>\n<p>8.To avoid list (grid, …) scrolling lags you can use PauseOnScrollListener:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean pauseOnScroll = false; // or true</span><br><span class=\"line\">boolean pauseOnFling = true; // or false</span><br><span class=\"line\">PauseOnScrollListener listener = new PauseOnScrollListener(imageLoader, pauseOnScroll, pauseOnFling);</span><br><span class=\"line\">listView.setOnScrollListener(listener);</span><br></pre></td></tr></table></figure>\n"},{"date":"2013-05-13T16:00:00.000Z","layout":"post","title":"Java并发之CountDownLatch","_content":"书摘：\n\nCountDownLatch被用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成。\n\n你可以向CountDownLatch对象设置一个初始计数值，任务在这个对象上调用wati()的方法都将阻塞，知道这个计数值达到0。其他任务在结束其工作时，可以在该对象上调用countDown()来减少这个计数值。CountDownLatch被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用[CyclicBarrier](http://linkyan.com/4000/2013/05/cyclicbarrier/)。\n\n调用countDown()的任务在产生这个调用时并没有被阻塞，只有对await()的调用会被阻塞，直到计数值达到0。\n\nCountDownLatch的典型用法是将一个程序分为n个互相独立的可解决任务，并创建值为0的CountDownLatch。当每个任务完成是，都会在这个锁存器上调用countDown()。等待问题被解决的任务在这个锁存器上调用await()，将他们自己拦住，知道锁存器计数结束。下面演示这种技术的一个框架示例：\n\n\n```\nclass TaskProtion implements Runnable {\n    private static int counter = 0;\n    private final int id = counter++;\n    private static Random rand = new Random(47);\n    private final CountDownLatch latch;\n\n    TaskProtion(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        //ToDo\n        try {\n            dowork();\n            latch.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void dowork() throws InterruptedException {\n        TimeUnit.MILLISECONDS.sleep(rand.nextInt(2000));\n        System.out.println(this + \"completed\");\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%1$-3d\", id);\n    }\n}\n\nclass WaitingTask implements Runnable {\n    private static int counter = 0;\n    private final int id = counter++;\n    private final CountDownLatch latch;\n\n    WaitingTask(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        //ToDo\n        try {\n            latch.await();\n            System.out.println(\"Latch barrier passed for \" + this);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"WaitingTask %1$-3d \", id);\n    }\n}\n\npublic class CountDownLatchDemo {\n    static final int SIZE = 100;\n\n    public static void main(String[] args) throws Exception {\n        ExecutorService exec = Executors.newCachedThreadPool();\n        CountDownLatch latch = new CountDownLatch(SIZE);\n\n        for (int i = 0; i < 10; i++) {\n            exec.execute(new WaitingTask(latch));\n        }\n        for (int i = 0; i < SIZE; i++) {\n            exec.execute(new TaskProtion(latch));\n        }\n\n        System.out.println(\"Launched all tasks \");\n        exec.shutdown();\n\n    }\n}\n```\n\nTaskPortion将随即地休眠一段时间，以模拟这部分工作的完成，而WaitingTask表示系统中，必须等待的部分，它要等待到问题的初始部分完成为止。所有任务都使用了在main()中定义的同一个单一的CountDownLatch。\n\n[链接:Java并发之CyclicBarrier](http://linkyan.com/2013/05/cyclicbarrier/)\n","source":"_posts/2013-05-14-countdownlatch.md","raw":"---\ncategory: Android\ndate: 2013-05-14\nlayout: post\ntitle: Java并发之CountDownLatch\n---\n书摘：\n\nCountDownLatch被用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成。\n\n你可以向CountDownLatch对象设置一个初始计数值，任务在这个对象上调用wati()的方法都将阻塞，知道这个计数值达到0。其他任务在结束其工作时，可以在该对象上调用countDown()来减少这个计数值。CountDownLatch被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用[CyclicBarrier](http://linkyan.com/4000/2013/05/cyclicbarrier/)。\n\n调用countDown()的任务在产生这个调用时并没有被阻塞，只有对await()的调用会被阻塞，直到计数值达到0。\n\nCountDownLatch的典型用法是将一个程序分为n个互相独立的可解决任务，并创建值为0的CountDownLatch。当每个任务完成是，都会在这个锁存器上调用countDown()。等待问题被解决的任务在这个锁存器上调用await()，将他们自己拦住，知道锁存器计数结束。下面演示这种技术的一个框架示例：\n\n\n```\nclass TaskProtion implements Runnable {\n    private static int counter = 0;\n    private final int id = counter++;\n    private static Random rand = new Random(47);\n    private final CountDownLatch latch;\n\n    TaskProtion(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        //ToDo\n        try {\n            dowork();\n            latch.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void dowork() throws InterruptedException {\n        TimeUnit.MILLISECONDS.sleep(rand.nextInt(2000));\n        System.out.println(this + \"completed\");\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%1$-3d\", id);\n    }\n}\n\nclass WaitingTask implements Runnable {\n    private static int counter = 0;\n    private final int id = counter++;\n    private final CountDownLatch latch;\n\n    WaitingTask(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        //ToDo\n        try {\n            latch.await();\n            System.out.println(\"Latch barrier passed for \" + this);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"WaitingTask %1$-3d \", id);\n    }\n}\n\npublic class CountDownLatchDemo {\n    static final int SIZE = 100;\n\n    public static void main(String[] args) throws Exception {\n        ExecutorService exec = Executors.newCachedThreadPool();\n        CountDownLatch latch = new CountDownLatch(SIZE);\n\n        for (int i = 0; i < 10; i++) {\n            exec.execute(new WaitingTask(latch));\n        }\n        for (int i = 0; i < SIZE; i++) {\n            exec.execute(new TaskProtion(latch));\n        }\n\n        System.out.println(\"Launched all tasks \");\n        exec.shutdown();\n\n    }\n}\n```\n\nTaskPortion将随即地休眠一段时间，以模拟这部分工作的完成，而WaitingTask表示系统中，必须等待的部分，它要等待到问题的初始部分完成为止。所有任务都使用了在main()中定义的同一个单一的CountDownLatch。\n\n[链接:Java并发之CyclicBarrier](http://linkyan.com/2013/05/cyclicbarrier/)\n","slug":"2013-05-14-countdownlatch","published":1,"updated":"2018-02-14T21:36:14.831Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tkn000brpfy43twa6bl","content":"<p>书摘：</p>\n<p>CountDownLatch被用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成。</p>\n<p>你可以向CountDownLatch对象设置一个初始计数值，任务在这个对象上调用wati()的方法都将阻塞，知道这个计数值达到0。其他任务在结束其工作时，可以在该对象上调用countDown()来减少这个计数值。CountDownLatch被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用<a href=\"http://linkyan.com/4000/2013/05/cyclicbarrier/\" target=\"_blank\" rel=\"noopener\">CyclicBarrier</a>。</p>\n<p>调用countDown()的任务在产生这个调用时并没有被阻塞，只有对await()的调用会被阻塞，直到计数值达到0。</p>\n<p>CountDownLatch的典型用法是将一个程序分为n个互相独立的可解决任务，并创建值为0的CountDownLatch。当每个任务完成是，都会在这个锁存器上调用countDown()。等待问题被解决的任务在这个锁存器上调用await()，将他们自己拦住，知道锁存器计数结束。下面演示这种技术的一个框架示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskProtion implements Runnable &#123;</span><br><span class=\"line\">    private static int counter = 0;</span><br><span class=\"line\">    private final int id = counter++;</span><br><span class=\"line\">    private static Random rand = new Random(47);</span><br><span class=\"line\">    private final CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    TaskProtion(CountDownLatch latch) &#123;</span><br><span class=\"line\">        this.latch = latch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            dowork();</span><br><span class=\"line\">            latch.countDown();</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void dowork() throws InterruptedException &#123;</span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(rand.nextInt(2000));</span><br><span class=\"line\">        System.out.println(this + &quot;completed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return String.format(&quot;%1$-3d&quot;, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class WaitingTask implements Runnable &#123;</span><br><span class=\"line\">    private static int counter = 0;</span><br><span class=\"line\">    private final int id = counter++;</span><br><span class=\"line\">    private final CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    WaitingTask(CountDownLatch latch) &#123;</span><br><span class=\"line\">        this.latch = latch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            System.out.println(&quot;Latch barrier passed for &quot; + this);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return String.format(&quot;WaitingTask %1$-3d &quot;, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class CountDownLatchDemo &#123;</span><br><span class=\"line\">    static final int SIZE = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        CountDownLatch latch = new CountDownLatch(SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            exec.execute(new WaitingTask(latch));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = 0; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">            exec.execute(new TaskProtion(latch));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;Launched all tasks &quot;);</span><br><span class=\"line\">        exec.shutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TaskPortion将随即地休眠一段时间，以模拟这部分工作的完成，而WaitingTask表示系统中，必须等待的部分，它要等待到问题的初始部分完成为止。所有任务都使用了在main()中定义的同一个单一的CountDownLatch。</p>\n<p><a href=\"http://linkyan.com/2013/05/cyclicbarrier/\" target=\"_blank\" rel=\"noopener\">链接:Java并发之CyclicBarrier</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>书摘：</p>\n<p>CountDownLatch被用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成。</p>\n<p>你可以向CountDownLatch对象设置一个初始计数值，任务在这个对象上调用wati()的方法都将阻塞，知道这个计数值达到0。其他任务在结束其工作时，可以在该对象上调用countDown()来减少这个计数值。CountDownLatch被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用<a href=\"http://linkyan.com/4000/2013/05/cyclicbarrier/\" target=\"_blank\" rel=\"noopener\">CyclicBarrier</a>。</p>\n<p>调用countDown()的任务在产生这个调用时并没有被阻塞，只有对await()的调用会被阻塞，直到计数值达到0。</p>\n<p>CountDownLatch的典型用法是将一个程序分为n个互相独立的可解决任务，并创建值为0的CountDownLatch。当每个任务完成是，都会在这个锁存器上调用countDown()。等待问题被解决的任务在这个锁存器上调用await()，将他们自己拦住，知道锁存器计数结束。下面演示这种技术的一个框架示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskProtion implements Runnable &#123;</span><br><span class=\"line\">    private static int counter = 0;</span><br><span class=\"line\">    private final int id = counter++;</span><br><span class=\"line\">    private static Random rand = new Random(47);</span><br><span class=\"line\">    private final CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    TaskProtion(CountDownLatch latch) &#123;</span><br><span class=\"line\">        this.latch = latch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            dowork();</span><br><span class=\"line\">            latch.countDown();</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void dowork() throws InterruptedException &#123;</span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(rand.nextInt(2000));</span><br><span class=\"line\">        System.out.println(this + &quot;completed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return String.format(&quot;%1$-3d&quot;, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class WaitingTask implements Runnable &#123;</span><br><span class=\"line\">    private static int counter = 0;</span><br><span class=\"line\">    private final int id = counter++;</span><br><span class=\"line\">    private final CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    WaitingTask(CountDownLatch latch) &#123;</span><br><span class=\"line\">        this.latch = latch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            System.out.println(&quot;Latch barrier passed for &quot; + this);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return String.format(&quot;WaitingTask %1$-3d &quot;, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class CountDownLatchDemo &#123;</span><br><span class=\"line\">    static final int SIZE = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        CountDownLatch latch = new CountDownLatch(SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            exec.execute(new WaitingTask(latch));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = 0; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">            exec.execute(new TaskProtion(latch));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;Launched all tasks &quot;);</span><br><span class=\"line\">        exec.shutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TaskPortion将随即地休眠一段时间，以模拟这部分工作的完成，而WaitingTask表示系统中，必须等待的部分，它要等待到问题的初始部分完成为止。所有任务都使用了在main()中定义的同一个单一的CountDownLatch。</p>\n<p><a href=\"http://linkyan.com/2013/05/cyclicbarrier/\" target=\"_blank\" rel=\"noopener\">链接:Java并发之CyclicBarrier</a></p>\n"},{"date":"2013-05-13T16:00:00.000Z","layout":"post","title":"程序算法与人生选择","_content":"\n每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。\n\n我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇[《三个故事和三个问题》](http://coolshell.cn/articles/6142.html)一样，让我想到写一篇这样的文章。\n\n##几个例子\n\n当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：\n\n- 某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……\n- 还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。\n\n- 另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。\n- 还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。\n- 还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。\n- 等等，等等……\n\n我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，**懂算法的人应该是知道怎么做选择的。**\n\n##排序算法\n\n你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。\n\n所以，在选择中纠结的人有必要参考一下排序算法。\n\n- 首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。**这个算法告诉我们，人的杂念越少，就越容易做出选择。**\n- 好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资>业务前景吗？业务前景>能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&&业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。**这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择。**\n\n这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？\n\n排序算法的核心思想就是，让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择。\n\n##贪婪算法\n\n所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是哈夫曼编码。\n\n对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，\n\n- 比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。\n- 或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。\n\n这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。\n\n有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。**贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？。**\n\n##动态规划\n\n但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。**因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定，因而没法达到最佳解。**\n\n动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。\n\n动态规划算法至少告诉我们两个事：\n\n1. **承前启后非常重要**，当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。\n\n2. **是否可以回退也很重要。**这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你错失了B公司，那到你明天还能不能找回来？\n\n比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，Yahoo和Baidu谁能给我们开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能回退到Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？\n\n##Dijkstra最短路径\n\n最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：\n\n1. 在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。\n\n2. 从离自己最近的结点开始贪婪。\n\n3. 走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。\n\n4. 再贪婪与原点最短的结点，如此反复。\n\n这个算法给我们带来了一些这样的启示：\n\n有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。**所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。**我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。\n有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么[我用两天时间就可以了解Go语言的原因](http://coolshell.cn/articles/8489.html)）。这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径。\n##算法就是Trade-Off\n\n你根本没有办法能得到所有你想得到的东西，**任何的选择都意味着放弃——当你要去获得一个东西的时候，你总是需要放弃一些东西。人生本来就是一个跷跷板，一头上，另一头必然下。**这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——**你总是要用某种东西去交易某种东西。**\n\n我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……\n\n**每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生。**\n\n---\n[原文连接](http://coolshell.cn/articles/8790.html)\n\n非常喜欢这篇文章就转过来，时时督促自己！\n###我的算法是什么？我的目标是什么？\n![car ](http://pic.yupoo.com/wsyanligang_v/CRnsVx3l/3Zin9.jpg)\n","source":"_posts/2013-05-14-lifealgorithm.md","raw":"---\ncategory: Android\ndate: 2013-05-14\nlayout: post\ntitle: 程序算法与人生选择\n---\n\n每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。\n\n我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇[《三个故事和三个问题》](http://coolshell.cn/articles/6142.html)一样，让我想到写一篇这样的文章。\n\n##几个例子\n\n当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：\n\n- 某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……\n- 还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。\n\n- 另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。\n- 还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。\n- 还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。\n- 等等，等等……\n\n我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，**懂算法的人应该是知道怎么做选择的。**\n\n##排序算法\n\n你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。\n\n所以，在选择中纠结的人有必要参考一下排序算法。\n\n- 首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。**这个算法告诉我们，人的杂念越少，就越容易做出选择。**\n- 好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资>业务前景吗？业务前景>能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&&业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。**这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择。**\n\n这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？\n\n排序算法的核心思想就是，让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择。\n\n##贪婪算法\n\n所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是哈夫曼编码。\n\n对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，\n\n- 比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。\n- 或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。\n\n这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。\n\n有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。**贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？。**\n\n##动态规划\n\n但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。**因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定，因而没法达到最佳解。**\n\n动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。\n\n动态规划算法至少告诉我们两个事：\n\n1. **承前启后非常重要**，当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。\n\n2. **是否可以回退也很重要。**这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你错失了B公司，那到你明天还能不能找回来？\n\n比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，Yahoo和Baidu谁能给我们开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能回退到Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？\n\n##Dijkstra最短路径\n\n最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：\n\n1. 在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。\n\n2. 从离自己最近的结点开始贪婪。\n\n3. 走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。\n\n4. 再贪婪与原点最短的结点，如此反复。\n\n这个算法给我们带来了一些这样的启示：\n\n有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。**所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。**我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。\n有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么[我用两天时间就可以了解Go语言的原因](http://coolshell.cn/articles/8489.html)）。这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径。\n##算法就是Trade-Off\n\n你根本没有办法能得到所有你想得到的东西，**任何的选择都意味着放弃——当你要去获得一个东西的时候，你总是需要放弃一些东西。人生本来就是一个跷跷板，一头上，另一头必然下。**这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——**你总是要用某种东西去交易某种东西。**\n\n我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……\n\n**每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生。**\n\n---\n[原文连接](http://coolshell.cn/articles/8790.html)\n\n非常喜欢这篇文章就转过来，时时督促自己！\n###我的算法是什么？我的目标是什么？\n![car ](http://pic.yupoo.com/wsyanligang_v/CRnsVx3l/3Zin9.jpg)\n","slug":"2013-05-14-lifealgorithm","published":1,"updated":"2018-02-14T21:36:14.832Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tld000jrpfysn8m3vv1","content":"<p>每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。</p>\n<p>我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇<a href=\"http://coolshell.cn/articles/6142.html\" target=\"_blank\" rel=\"noopener\">《三个故事和三个问题》</a>一样，让我想到写一篇这样的文章。</p>\n<p>##几个例子</p>\n<p>当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：</p>\n<ul>\n<li>某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……</li>\n<li><p>还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。</p>\n</li>\n<li><p>另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。</p>\n</li>\n<li>还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。</li>\n<li>还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。</li>\n<li>等等，等等……</li>\n</ul>\n<p>我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，<strong>懂算法的人应该是知道怎么做选择的。</strong></p>\n<p>##排序算法</p>\n<p>你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。</p>\n<p>所以，在选择中纠结的人有必要参考一下排序算法。</p>\n<ul>\n<li>首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。<strong>这个算法告诉我们，人的杂念越少，就越容易做出选择。</strong></li>\n<li>好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资&gt;业务前景吗？业务前景&gt;能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&amp;&amp;业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。<strong>这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择。</strong></li>\n</ul>\n<p>这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？</p>\n<p>排序算法的核心思想就是，让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择。</p>\n<p>##贪婪算法</p>\n<p>所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是哈夫曼编码。</p>\n<p>对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，</p>\n<ul>\n<li>比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。</li>\n<li>或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。</li>\n</ul>\n<p>这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。</p>\n<p>有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。<strong>贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？。</strong></p>\n<p>##动态规划</p>\n<p>但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。<strong>因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定，因而没法达到最佳解。</strong></p>\n<p>动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>\n<p>动态规划算法至少告诉我们两个事：</p>\n<ol>\n<li><p><strong>承前启后非常重要</strong>，当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。</p>\n</li>\n<li><p><strong>是否可以回退也很重要。</strong>这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你错失了B公司，那到你明天还能不能找回来？</p>\n</li>\n</ol>\n<p>比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，Yahoo和Baidu谁能给我们开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能回退到Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？</p>\n<p>##Dijkstra最短路径</p>\n<p>最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：</p>\n<ol>\n<li><p>在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。</p>\n</li>\n<li><p>从离自己最近的结点开始贪婪。</p>\n</li>\n<li><p>走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。</p>\n</li>\n<li><p>再贪婪与原点最短的结点，如此反复。</p>\n</li>\n</ol>\n<p>这个算法给我们带来了一些这样的启示：</p>\n<p>有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。<strong>所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。</strong>我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。<br>有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么<a href=\"http://coolshell.cn/articles/8489.html\" target=\"_blank\" rel=\"noopener\">我用两天时间就可以了解Go语言的原因</a>）。这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径。</p>\n<p>##算法就是Trade-Off</p>\n<p>你根本没有办法能得到所有你想得到的东西，<strong>任何的选择都意味着放弃——当你要去获得一个东西的时候，你总是需要放弃一些东西。人生本来就是一个跷跷板，一头上，另一头必然下。</strong>这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——<strong>你总是要用某种东西去交易某种东西。</strong></p>\n<p>我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……</p>\n<p><strong>每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生。</strong></p>\n<hr>\n<p><a href=\"http://coolshell.cn/articles/8790.html\" target=\"_blank\" rel=\"noopener\">原文连接</a></p>\n<p>非常喜欢这篇文章就转过来，时时督促自己！</p>\n<p>###我的算法是什么？我的目标是什么？<br><img src=\"http://pic.yupoo.com/wsyanligang_v/CRnsVx3l/3Zin9.jpg\" alt=\"car \"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。</p>\n<p>我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇<a href=\"http://coolshell.cn/articles/6142.html\" target=\"_blank\" rel=\"noopener\">《三个故事和三个问题》</a>一样，让我想到写一篇这样的文章。</p>\n<p>##几个例子</p>\n<p>当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：</p>\n<ul>\n<li>某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……</li>\n<li><p>还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。</p>\n</li>\n<li><p>另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。</p>\n</li>\n<li>还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。</li>\n<li>还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。</li>\n<li>等等，等等……</li>\n</ul>\n<p>我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，<strong>懂算法的人应该是知道怎么做选择的。</strong></p>\n<p>##排序算法</p>\n<p>你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。</p>\n<p>所以，在选择中纠结的人有必要参考一下排序算法。</p>\n<ul>\n<li>首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。<strong>这个算法告诉我们，人的杂念越少，就越容易做出选择。</strong></li>\n<li>好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资&gt;业务前景吗？业务前景&gt;能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&amp;&amp;业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。<strong>这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择。</strong></li>\n</ul>\n<p>这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？</p>\n<p>排序算法的核心思想就是，让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择。</p>\n<p>##贪婪算法</p>\n<p>所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是哈夫曼编码。</p>\n<p>对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，</p>\n<ul>\n<li>比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。</li>\n<li>或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。</li>\n</ul>\n<p>这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。</p>\n<p>有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。<strong>贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？。</strong></p>\n<p>##动态规划</p>\n<p>但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。<strong>因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定，因而没法达到最佳解。</strong></p>\n<p>动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>\n<p>动态规划算法至少告诉我们两个事：</p>\n<ol>\n<li><p><strong>承前启后非常重要</strong>，当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。</p>\n</li>\n<li><p><strong>是否可以回退也很重要。</strong>这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你错失了B公司，那到你明天还能不能找回来？</p>\n</li>\n</ol>\n<p>比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，Yahoo和Baidu谁能给我们开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能回退到Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？</p>\n<p>##Dijkstra最短路径</p>\n<p>最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：</p>\n<ol>\n<li><p>在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。</p>\n</li>\n<li><p>从离自己最近的结点开始贪婪。</p>\n</li>\n<li><p>走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。</p>\n</li>\n<li><p>再贪婪与原点最短的结点，如此反复。</p>\n</li>\n</ol>\n<p>这个算法给我们带来了一些这样的启示：</p>\n<p>有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。<strong>所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。</strong>我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。<br>有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么<a href=\"http://coolshell.cn/articles/8489.html\" target=\"_blank\" rel=\"noopener\">我用两天时间就可以了解Go语言的原因</a>）。这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径。</p>\n<p>##算法就是Trade-Off</p>\n<p>你根本没有办法能得到所有你想得到的东西，<strong>任何的选择都意味着放弃——当你要去获得一个东西的时候，你总是需要放弃一些东西。人生本来就是一个跷跷板，一头上，另一头必然下。</strong>这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——<strong>你总是要用某种东西去交易某种东西。</strong></p>\n<p>我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……</p>\n<p><strong>每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生。</strong></p>\n<hr>\n<p><a href=\"http://coolshell.cn/articles/8790.html\" target=\"_blank\" rel=\"noopener\">原文连接</a></p>\n<p>非常喜欢这篇文章就转过来，时时督促自己！</p>\n<p>###我的算法是什么？我的目标是什么？<br><img src=\"http://pic.yupoo.com/wsyanligang_v/CRnsVx3l/3Zin9.jpg\" alt=\"car \"></p>\n"},{"date":"2013-05-13T16:00:00.000Z","layout":"post","title":"Lazy ListView--细化ListView加载图片策略","_content":"\n使用ListView控件来加载图片时，我们一般会使用异步加载的方式。但是如果我们滑动过快的话，可能会超出AsyncTask最大128个线程的限制，然后报异常，FC。于是我们可以使用```setOnScrollListener(…)```监听当ScrollState变为```SCROLL_STAT_IDLE```时我们再触发图片加载，[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader) 有实现这样的逻辑。\n\n但是我将细化这个加载策略\n\n1. ScrollState==SCROLL_STATE_TOUCH_SCROLL（我们手指触摸屏幕，拖动ListView滑动） 时，我们和往常一样创建加载任务，并且显示图片，我们定义为普通加载模式。\n2. ScrollState==SCROLL_STATE_FLING （ListView在滑动，但是我们手指已经离开了屏幕，ListView出去 Fling 状态）时，图片停止加载。我们定义为延迟加载模式。\n3. ScrollState==SCROLL_STATE_IDEL，这时候ListView滑动停止，我们根据不同的加载模式，有不同的策略。\n4. 在普通加载模式下，图片逐张被加载显示出来。\n5. 在延迟加载模式下，LazyAdapter中会回调onLazyLoad 并带有两个参数：\n\t1. firstVisibleItem\n\t2. lastVisibleItem\n\nAdapter需要根据这两个变量来创建加载图片任务，并显示。我们需要继承LazyAdapter类。\n\n```\npublic abstract class LazyAdapter extends BaseAdapter {\n\t...\n    public abstract void onLazyLoad(int first, int last);\n    ...\n}\n```\nLazyListView 中监听ScrollState是这样实现的：\n\n\n```\npublic class LazyListView extends ListView implements AbsListView.OnScrollListener {\n\t. . .\n    private int mFirstCount;\n    private int mVisibleCount;\n    private LazyAdapter mLazyAdapter;\n    @Override\n    public void onScrollStateChanged(AbsListView view, int scrollState) {\n        // TODO Auto-generated method stub\n        if (scrollState == SCROLL_STATE_IDLE) {\n            mLazyAdapter.onLazyLoad(mFirstCount, mVisibleCount + mFirstCount);\n        }\n    }\n    @Override\n    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n        // TODO Auto-generated method stub\n        mFirstCount = firstVisibleItem;\n        mVisibleCount = visibleItemCount;\n    }\n}\n```\n接着我们需要LazyAapater维持两个变量```isFirstLoad```和```mCurrentScrollState```\n一个用来标记是否第一次加载，一个用来记录当前的ScrollState。在调用```notifyDataSetChanged()```时，还需要重新标记为第一次加载状态，这是因为它不会触发ScrollState改变。\n\n所以完整版的LazyAdapter是这样的：\n\n```\npublic abstract class LazyAdapter extends BaseAdapter {\n    private boolean isFirstLoad;\n    private int mCurrentScrollState;\n    public void setFirstLoad(boolean isFirstLoad) {\n        this.isFirstLoad = isFirstLoad;\n    }\n    public boolean isFirstLoad() {\n        return isFirstLoad;\n    }\n    public void resetFirstLoad() {\n        this.isFirstLoad = true;\n    }\n    public void setScrollState(int state) {\n        this.mCurrentScrollState = state;\n    }\n    public boolean isTouchScroll() {\n        return mCurrentScrollState == AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL;\n    }\n    @Override\n    public void notifyDataSetChanged() {\n        // TODO Auto-generated method stub\n        resetFirstLoad();\n        super.notifyDataSetChanged();\n    }\n    public abstract void onLazyLoad(int first, int last);\n}\n```\n\n在LazyListView调用```setAdapter()```时，我们需要类型检测下，并且将LazyAdapter设为第一次加载状态.\n然后完成版的LazyListView是这样的:\n\n```\npublic class LazyListView extends ListView implements AbsListView.OnScrollListener {\n    public LazyListView(Context context) {\n        super(context);\n        setOnScrollListener(this);\n    }\n    public LazyListView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        setOnScrollListener(this);\n    }\n    public LazyListView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        setOnScrollListener(this);\n    }\n    private int mFirstCount;\n    private int mVisibleCount;\n    private LazyAdapter mLazyAdapter;\n    @Override\n    public void setAdapter(ListAdapter adapter) {\n        if (adapter instanceof LazyAdapter) {\n            mLazyAdapter = (LazyAdapter) adapter;\n            mLazyAdapter.setFirstLoad(true);\n            super.setAdapter(adapter);\n        } else {\n            throw new IllegalArgumentException(\"The adapter must be LazyAdapter\");\n        }\n    }\n    @Override\n    public void onScrollStateChanged(AbsListView view, int scrollState) {\n        // TODO Auto-generated method stub\n        if (scrollState == SCROLL_STATE_IDLE) {\n            mLazyAdapter.onLazyLoad(mFirstCount, mVisibleCount + mFirstCount);\n        }\n        if (mLazyAdapter.isFirstLoad()) {\n            if (scrollState == SCROLL_STATE_TOUCH_SCROLL) {\n                mLazyAdapter.setFirstLoad(false);\n            }\n        }\n        mLazyAdapter.setScrollState(scrollState);\n    }\n    @Override\n    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n        mFirstCount = firstVisibleItem;\n        mVisibleCount = visibleItemCount;\n    }\n}\n```\n\n接着看看我们如何使用：\n\n```\npublic class DemoAdapter extends LazyAdapter {\n    private SparseArray<LKImageView> mLazyImgs;\n    @Override\n    public void onLazyLoad(int first, int last) {\n        //ToDo\n        for (int i = first - 2; i < last + 2; i++) {      \n            LKImageView img = mLazyImgs.get(i);\n            if (img != null) {\n            \tDisplayOptions options=…\n                img.displayWithMemory(options);\n            }\n        }\n        mLazyImgs.clear();\n    }\n    @Override\n    public View getView(int position, View cv, ViewGroup viewGroup) {\n      \t…\n       \tHolder holder=…\n       \tDisplayOptions options=…\n       \tif(isFirstLoad()){\n       \t\tholder.mImg.display(options);\n       \t}else{\n       \t\tif(isTouchScroll()){\n       \t\t\tholder.mImg.display(options);\n       \t\t}else{\n       \t\t\tif(holder.mImg.tryDisplayWithMemory(options)){\n       \t\t\t\tmLazyImgs.append(position,holder.mImg);\n       \t\t\t}\n       \t\t}\n       \t}\n       \t. . .\n        return view;  //ToDo\n    }\n}\n```\n\nLKImageView 是继承自ImageView类，并扩展了很多附加功能的控件，可以实现内存/磁盘缓存，显示功能==>Link-ImageLoader\n现在我们只要知道：\n\n- ```public void display(DisplayOptions options);``` 异步加载图片的方法。\n- ```public boolean tryDisplayWithMemory(DisplayOptions options); ```尝试从内存中同步加载图片的方法\n\n在onLazyLoad()中 ```for (int i = first - 2; i < last + 2; i++)```\n分别-2和+2，可以做到不仅仅加载当前屏幕的可见范围，还可以多加载几个，不做调整也是没有关系的。\n\n**并且```mLazyImgs.clear()```在结束是必须要调用的，不然会有问题。**\n\n现在就去尝试下吧，你可以下载我们的这个应用\n\n<img src=\"https://lh4.ggpht.com/EUP4NTyHIMdWZsMgYX5w2kgIE3e3JE5Ud_Yx7tkeYOj8AALgSS2TUYoW92V-dQvVyVM=w124\" height=50>[壁纸控](https://play.google.com/store/apps/details?id=com.huaban.wallpaper&feature=search_result#?t=W251bGwsMSwxLDEsImNvbS5odWFiYW4ud2FsbHBhcGVyIl0.) ，里面使用了这套加载策略。\n","source":"_posts/2013-05-14-lazylistview.md","raw":"---\ncategory: Android\ndate: 2013-05-14\nlayout: post\ntitle: Lazy ListView--细化ListView加载图片策略\n---\n\n使用ListView控件来加载图片时，我们一般会使用异步加载的方式。但是如果我们滑动过快的话，可能会超出AsyncTask最大128个线程的限制，然后报异常，FC。于是我们可以使用```setOnScrollListener(…)```监听当ScrollState变为```SCROLL_STAT_IDLE```时我们再触发图片加载，[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader) 有实现这样的逻辑。\n\n但是我将细化这个加载策略\n\n1. ScrollState==SCROLL_STATE_TOUCH_SCROLL（我们手指触摸屏幕，拖动ListView滑动） 时，我们和往常一样创建加载任务，并且显示图片，我们定义为普通加载模式。\n2. ScrollState==SCROLL_STATE_FLING （ListView在滑动，但是我们手指已经离开了屏幕，ListView出去 Fling 状态）时，图片停止加载。我们定义为延迟加载模式。\n3. ScrollState==SCROLL_STATE_IDEL，这时候ListView滑动停止，我们根据不同的加载模式，有不同的策略。\n4. 在普通加载模式下，图片逐张被加载显示出来。\n5. 在延迟加载模式下，LazyAdapter中会回调onLazyLoad 并带有两个参数：\n\t1. firstVisibleItem\n\t2. lastVisibleItem\n\nAdapter需要根据这两个变量来创建加载图片任务，并显示。我们需要继承LazyAdapter类。\n\n```\npublic abstract class LazyAdapter extends BaseAdapter {\n\t...\n    public abstract void onLazyLoad(int first, int last);\n    ...\n}\n```\nLazyListView 中监听ScrollState是这样实现的：\n\n\n```\npublic class LazyListView extends ListView implements AbsListView.OnScrollListener {\n\t. . .\n    private int mFirstCount;\n    private int mVisibleCount;\n    private LazyAdapter mLazyAdapter;\n    @Override\n    public void onScrollStateChanged(AbsListView view, int scrollState) {\n        // TODO Auto-generated method stub\n        if (scrollState == SCROLL_STATE_IDLE) {\n            mLazyAdapter.onLazyLoad(mFirstCount, mVisibleCount + mFirstCount);\n        }\n    }\n    @Override\n    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n        // TODO Auto-generated method stub\n        mFirstCount = firstVisibleItem;\n        mVisibleCount = visibleItemCount;\n    }\n}\n```\n接着我们需要LazyAapater维持两个变量```isFirstLoad```和```mCurrentScrollState```\n一个用来标记是否第一次加载，一个用来记录当前的ScrollState。在调用```notifyDataSetChanged()```时，还需要重新标记为第一次加载状态，这是因为它不会触发ScrollState改变。\n\n所以完整版的LazyAdapter是这样的：\n\n```\npublic abstract class LazyAdapter extends BaseAdapter {\n    private boolean isFirstLoad;\n    private int mCurrentScrollState;\n    public void setFirstLoad(boolean isFirstLoad) {\n        this.isFirstLoad = isFirstLoad;\n    }\n    public boolean isFirstLoad() {\n        return isFirstLoad;\n    }\n    public void resetFirstLoad() {\n        this.isFirstLoad = true;\n    }\n    public void setScrollState(int state) {\n        this.mCurrentScrollState = state;\n    }\n    public boolean isTouchScroll() {\n        return mCurrentScrollState == AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL;\n    }\n    @Override\n    public void notifyDataSetChanged() {\n        // TODO Auto-generated method stub\n        resetFirstLoad();\n        super.notifyDataSetChanged();\n    }\n    public abstract void onLazyLoad(int first, int last);\n}\n```\n\n在LazyListView调用```setAdapter()```时，我们需要类型检测下，并且将LazyAdapter设为第一次加载状态.\n然后完成版的LazyListView是这样的:\n\n```\npublic class LazyListView extends ListView implements AbsListView.OnScrollListener {\n    public LazyListView(Context context) {\n        super(context);\n        setOnScrollListener(this);\n    }\n    public LazyListView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        setOnScrollListener(this);\n    }\n    public LazyListView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        setOnScrollListener(this);\n    }\n    private int mFirstCount;\n    private int mVisibleCount;\n    private LazyAdapter mLazyAdapter;\n    @Override\n    public void setAdapter(ListAdapter adapter) {\n        if (adapter instanceof LazyAdapter) {\n            mLazyAdapter = (LazyAdapter) adapter;\n            mLazyAdapter.setFirstLoad(true);\n            super.setAdapter(adapter);\n        } else {\n            throw new IllegalArgumentException(\"The adapter must be LazyAdapter\");\n        }\n    }\n    @Override\n    public void onScrollStateChanged(AbsListView view, int scrollState) {\n        // TODO Auto-generated method stub\n        if (scrollState == SCROLL_STATE_IDLE) {\n            mLazyAdapter.onLazyLoad(mFirstCount, mVisibleCount + mFirstCount);\n        }\n        if (mLazyAdapter.isFirstLoad()) {\n            if (scrollState == SCROLL_STATE_TOUCH_SCROLL) {\n                mLazyAdapter.setFirstLoad(false);\n            }\n        }\n        mLazyAdapter.setScrollState(scrollState);\n    }\n    @Override\n    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n        mFirstCount = firstVisibleItem;\n        mVisibleCount = visibleItemCount;\n    }\n}\n```\n\n接着看看我们如何使用：\n\n```\npublic class DemoAdapter extends LazyAdapter {\n    private SparseArray<LKImageView> mLazyImgs;\n    @Override\n    public void onLazyLoad(int first, int last) {\n        //ToDo\n        for (int i = first - 2; i < last + 2; i++) {      \n            LKImageView img = mLazyImgs.get(i);\n            if (img != null) {\n            \tDisplayOptions options=…\n                img.displayWithMemory(options);\n            }\n        }\n        mLazyImgs.clear();\n    }\n    @Override\n    public View getView(int position, View cv, ViewGroup viewGroup) {\n      \t…\n       \tHolder holder=…\n       \tDisplayOptions options=…\n       \tif(isFirstLoad()){\n       \t\tholder.mImg.display(options);\n       \t}else{\n       \t\tif(isTouchScroll()){\n       \t\t\tholder.mImg.display(options);\n       \t\t}else{\n       \t\t\tif(holder.mImg.tryDisplayWithMemory(options)){\n       \t\t\t\tmLazyImgs.append(position,holder.mImg);\n       \t\t\t}\n       \t\t}\n       \t}\n       \t. . .\n        return view;  //ToDo\n    }\n}\n```\n\nLKImageView 是继承自ImageView类，并扩展了很多附加功能的控件，可以实现内存/磁盘缓存，显示功能==>Link-ImageLoader\n现在我们只要知道：\n\n- ```public void display(DisplayOptions options);``` 异步加载图片的方法。\n- ```public boolean tryDisplayWithMemory(DisplayOptions options); ```尝试从内存中同步加载图片的方法\n\n在onLazyLoad()中 ```for (int i = first - 2; i < last + 2; i++)```\n分别-2和+2，可以做到不仅仅加载当前屏幕的可见范围，还可以多加载几个，不做调整也是没有关系的。\n\n**并且```mLazyImgs.clear()```在结束是必须要调用的，不然会有问题。**\n\n现在就去尝试下吧，你可以下载我们的这个应用\n\n<img src=\"https://lh4.ggpht.com/EUP4NTyHIMdWZsMgYX5w2kgIE3e3JE5Ud_Yx7tkeYOj8AALgSS2TUYoW92V-dQvVyVM=w124\" height=50>[壁纸控](https://play.google.com/store/apps/details?id=com.huaban.wallpaper&feature=search_result#?t=W251bGwsMSwxLDEsImNvbS5odWFiYW4ud2FsbHBhcGVyIl0.) ，里面使用了这套加载策略。\n","slug":"2013-05-14-lazylistview","published":1,"updated":"2018-02-14T21:36:14.831Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tle000krpfyenhqjl5u","content":"<p>使用ListView控件来加载图片时，我们一般会使用异步加载的方式。但是如果我们滑动过快的话，可能会超出AsyncTask最大128个线程的限制，然后报异常，FC。于是我们可以使用<figure class=\"highlight plain\"><figcaption><span>有实现这样的逻辑。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">但是我将细化这个加载策略</span><br><span class=\"line\"></span><br><span class=\"line\">1. ScrollState==SCROLL_STATE_TOUCH_SCROLL（我们手指触摸屏幕，拖动ListView滑动） 时，我们和往常一样创建加载任务，并且显示图片，我们定义为普通加载模式。</span><br><span class=\"line\">2. ScrollState==SCROLL_STATE_FLING （ListView在滑动，但是我们手指已经离开了屏幕，ListView出去 Fling 状态）时，图片停止加载。我们定义为延迟加载模式。</span><br><span class=\"line\">3. ScrollState==SCROLL_STATE_IDEL，这时候ListView滑动停止，我们根据不同的加载模式，有不同的策略。</span><br><span class=\"line\">4. 在普通加载模式下，图片逐张被加载显示出来。</span><br><span class=\"line\">5. 在延迟加载模式下，LazyAdapter中会回调onLazyLoad 并带有两个参数：</span><br><span class=\"line\">\t1. firstVisibleItem</span><br><span class=\"line\">\t2. lastVisibleItem</span><br><span class=\"line\"></span><br><span class=\"line\">Adapter需要根据这两个变量来创建加载图片任务，并显示。我们需要继承LazyAdapter类。</span><br></pre></td></tr></table></figure></p>\n<p>public abstract class LazyAdapter extends BaseAdapter {<br>    …<br>    public abstract void onLazyLoad(int first, int last);<br>    …<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LazyListView 中监听ScrollState是这样实现的：</span><br></pre></td></tr></table></figure></p>\n<p>public class LazyListView extends ListView implements AbsListView.OnScrollListener {<br>    . . .<br>    private int mFirstCount;<br>    private int mVisibleCount;<br>    private LazyAdapter mLazyAdapter;<br>    @Override<br>    public void onScrollStateChanged(AbsListView view, int scrollState) {<br>        // TODO Auto-generated method stub<br>        if (scrollState == SCROLL_STATE_IDLE) {<br>            mLazyAdapter.onLazyLoad(mFirstCount, mVisibleCount + mFirstCount);<br>        }<br>    }<br>    @Override<br>    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {<br>        // TODO Auto-generated method stub<br>        mFirstCount = firstVisibleItem;<br>        mVisibleCount = visibleItemCount;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接着我们需要LazyAapater维持两个变量```isFirstLoad```和```mCurrentScrollState</span><br></pre></td></tr></table></figure></p>\n<p>一个用来标记是否第一次加载，一个用来记录当前的ScrollState。在调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">所以完整版的LazyAdapter是这样的：</span><br></pre></td></tr></table></figure></p>\n<p>public abstract class LazyAdapter extends BaseAdapter {<br>    private boolean isFirstLoad;<br>    private int mCurrentScrollState;<br>    public void setFirstLoad(boolean isFirstLoad) {<br>        this.isFirstLoad = isFirstLoad;<br>    }<br>    public boolean isFirstLoad() {<br>        return isFirstLoad;<br>    }<br>    public void resetFirstLoad() {<br>        this.isFirstLoad = true;<br>    }<br>    public void setScrollState(int state) {<br>        this.mCurrentScrollState = state;<br>    }<br>    public boolean isTouchScroll() {<br>        return mCurrentScrollState == AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL;<br>    }<br>    @Override<br>    public void notifyDataSetChanged() {<br>        // TODO Auto-generated method stub<br>        resetFirstLoad();<br>        super.notifyDataSetChanged();<br>    }<br>    public abstract void onLazyLoad(int first, int last);<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在LazyListView调用```setAdapter()```时，我们需要类型检测下，并且将LazyAdapter设为第一次加载状态.</span><br><span class=\"line\">然后完成版的LazyListView是这样的:</span><br></pre></td></tr></table></figure></p>\n<p>public class LazyListView extends ListView implements AbsListView.OnScrollListener {<br>    public LazyListView(Context context) {<br>        super(context);<br>        setOnScrollListener(this);<br>    }<br>    public LazyListView(Context context, AttributeSet attrs) {<br>        super(context, attrs);<br>        setOnScrollListener(this);<br>    }<br>    public LazyListView(Context context, AttributeSet attrs, int defStyle) {<br>        super(context, attrs, defStyle);<br>        setOnScrollListener(this);<br>    }<br>    private int mFirstCount;<br>    private int mVisibleCount;<br>    private LazyAdapter mLazyAdapter;<br>    @Override<br>    public void setAdapter(ListAdapter adapter) {<br>        if (adapter instanceof LazyAdapter) {<br>            mLazyAdapter = (LazyAdapter) adapter;<br>            mLazyAdapter.setFirstLoad(true);<br>            super.setAdapter(adapter);<br>        } else {<br>            throw new IllegalArgumentException(“The adapter must be LazyAdapter”);<br>        }<br>    }<br>    @Override<br>    public void onScrollStateChanged(AbsListView view, int scrollState) {<br>        // TODO Auto-generated method stub<br>        if (scrollState == SCROLL_STATE_IDLE) {<br>            mLazyAdapter.onLazyLoad(mFirstCount, mVisibleCount + mFirstCount);<br>        }<br>        if (mLazyAdapter.isFirstLoad()) {<br>            if (scrollState == SCROLL_STATE_TOUCH_SCROLL) {<br>                mLazyAdapter.setFirstLoad(false);<br>            }<br>        }<br>        mLazyAdapter.setScrollState(scrollState);<br>    }<br>    @Override<br>    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {<br>        mFirstCount = firstVisibleItem;<br>        mVisibleCount = visibleItemCount;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">接着看看我们如何使用：</span><br></pre></td></tr></table></figure></p>\n<p>public class DemoAdapter extends LazyAdapter {<br>    private SparseArray<lkimageview> mLazyImgs;<br>    @Override<br>    public void onLazyLoad(int first, int last) {<br>        //ToDo<br>        for (int i = first - 2; i &lt; last + 2; i++) {<br>            LKImageView img = mLazyImgs.get(i);<br>            if (img != null) {<br>                DisplayOptions options=…<br>                img.displayWithMemory(options);<br>            }<br>        }<br>        mLazyImgs.clear();<br>    }<br>    @Override<br>    public View getView(int position, View cv, ViewGroup viewGroup) {<br>          …<br>           Holder holder=…<br>           DisplayOptions options=…<br>           if(isFirstLoad()){<br>               holder.mImg.display(options);<br>           }else{<br>               if(isTouchScroll()){<br>                   holder.mImg.display(options);<br>               }else{<br>                   if(holder.mImg.tryDisplayWithMemory(options)){<br>                       mLazyImgs.append(position,holder.mImg);<br>                   }<br>               }<br>           }<br>           . . .<br>        return view;  //ToDo<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">LKImageView 是继承自ImageView类，并扩展了很多附加功能的控件，可以实现内存/磁盘缓存，显示功能==&gt;Link-ImageLoader</span><br><span class=\"line\">现在我们只要知道：</span><br><span class=\"line\"></span><br><span class=\"line\">- ```public void display(DisplayOptions options);``` 异步加载图片的方法。</span><br><span class=\"line\">- ```public boolean tryDisplayWithMemory(DisplayOptions options); ```尝试从内存中同步加载图片的方法</span><br><span class=\"line\"></span><br><span class=\"line\">在onLazyLoad()中 ```for (int i = first - 2; i &lt; last + 2; i++)</span><br></pre></td></tr></table></figure></lkimageview></p>\n<p>分别-2和+2，可以做到不仅仅加载当前屏幕的可见范围，还可以多加载几个，不做调整也是没有关系的。</p>\n<p><strong>并且<code>mLazyImgs.clear()</code>在结束是必须要调用的，不然会有问题。</strong></p>\n<p>现在就去尝试下吧，你可以下载我们的这个应用</p>\n<p><img src=\"https://lh4.ggpht.com/EUP4NTyHIMdWZsMgYX5w2kgIE3e3JE5Ud_Yx7tkeYOj8AALgSS2TUYoW92V-dQvVyVM=w124\" height=\"50\"><a href=\"https://play.google.com/store/apps/details?id=com.huaban.wallpaper&amp;feature=search_result#?t=W251bGwsMSwxLDEsImNvbS5odWFiYW4ud2FsbHBhcGVyIl0.\" target=\"_blank\" rel=\"noopener\">壁纸控</a> ，里面使用了这套加载策略。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用ListView控件来加载图片时，我们一般会使用异步加载的方式。但是如果我们滑动过快的话，可能会超出AsyncTask最大128个线程的限制，然后报异常，FC。于是我们可以使用<figure class=\"highlight plain\"><figcaption><span>有实现这样的逻辑。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">但是我将细化这个加载策略</span><br><span class=\"line\"></span><br><span class=\"line\">1. ScrollState==SCROLL_STATE_TOUCH_SCROLL（我们手指触摸屏幕，拖动ListView滑动） 时，我们和往常一样创建加载任务，并且显示图片，我们定义为普通加载模式。</span><br><span class=\"line\">2. ScrollState==SCROLL_STATE_FLING （ListView在滑动，但是我们手指已经离开了屏幕，ListView出去 Fling 状态）时，图片停止加载。我们定义为延迟加载模式。</span><br><span class=\"line\">3. ScrollState==SCROLL_STATE_IDEL，这时候ListView滑动停止，我们根据不同的加载模式，有不同的策略。</span><br><span class=\"line\">4. 在普通加载模式下，图片逐张被加载显示出来。</span><br><span class=\"line\">5. 在延迟加载模式下，LazyAdapter中会回调onLazyLoad 并带有两个参数：</span><br><span class=\"line\">\t1. firstVisibleItem</span><br><span class=\"line\">\t2. lastVisibleItem</span><br><span class=\"line\"></span><br><span class=\"line\">Adapter需要根据这两个变量来创建加载图片任务，并显示。我们需要继承LazyAdapter类。</span><br></pre></td></tr></table></figure></p>\n<p>public abstract class LazyAdapter extends BaseAdapter {<br>    …<br>    public abstract void onLazyLoad(int first, int last);<br>    …<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LazyListView 中监听ScrollState是这样实现的：</span><br></pre></td></tr></table></figure></p>\n<p>public class LazyListView extends ListView implements AbsListView.OnScrollListener {<br>    . . .<br>    private int mFirstCount;<br>    private int mVisibleCount;<br>    private LazyAdapter mLazyAdapter;<br>    @Override<br>    public void onScrollStateChanged(AbsListView view, int scrollState) {<br>        // TODO Auto-generated method stub<br>        if (scrollState == SCROLL_STATE_IDLE) {<br>            mLazyAdapter.onLazyLoad(mFirstCount, mVisibleCount + mFirstCount);<br>        }<br>    }<br>    @Override<br>    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {<br>        // TODO Auto-generated method stub<br>        mFirstCount = firstVisibleItem;<br>        mVisibleCount = visibleItemCount;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接着我们需要LazyAapater维持两个变量```isFirstLoad```和```mCurrentScrollState</span><br></pre></td></tr></table></figure></p>\n<p>一个用来标记是否第一次加载，一个用来记录当前的ScrollState。在调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">所以完整版的LazyAdapter是这样的：</span><br></pre></td></tr></table></figure></p>\n<p>public abstract class LazyAdapter extends BaseAdapter {<br>    private boolean isFirstLoad;<br>    private int mCurrentScrollState;<br>    public void setFirstLoad(boolean isFirstLoad) {<br>        this.isFirstLoad = isFirstLoad;<br>    }<br>    public boolean isFirstLoad() {<br>        return isFirstLoad;<br>    }<br>    public void resetFirstLoad() {<br>        this.isFirstLoad = true;<br>    }<br>    public void setScrollState(int state) {<br>        this.mCurrentScrollState = state;<br>    }<br>    public boolean isTouchScroll() {<br>        return mCurrentScrollState == AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL;<br>    }<br>    @Override<br>    public void notifyDataSetChanged() {<br>        // TODO Auto-generated method stub<br>        resetFirstLoad();<br>        super.notifyDataSetChanged();<br>    }<br>    public abstract void onLazyLoad(int first, int last);<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在LazyListView调用```setAdapter()```时，我们需要类型检测下，并且将LazyAdapter设为第一次加载状态.</span><br><span class=\"line\">然后完成版的LazyListView是这样的:</span><br></pre></td></tr></table></figure></p>\n<p>public class LazyListView extends ListView implements AbsListView.OnScrollListener {<br>    public LazyListView(Context context) {<br>        super(context);<br>        setOnScrollListener(this);<br>    }<br>    public LazyListView(Context context, AttributeSet attrs) {<br>        super(context, attrs);<br>        setOnScrollListener(this);<br>    }<br>    public LazyListView(Context context, AttributeSet attrs, int defStyle) {<br>        super(context, attrs, defStyle);<br>        setOnScrollListener(this);<br>    }<br>    private int mFirstCount;<br>    private int mVisibleCount;<br>    private LazyAdapter mLazyAdapter;<br>    @Override<br>    public void setAdapter(ListAdapter adapter) {<br>        if (adapter instanceof LazyAdapter) {<br>            mLazyAdapter = (LazyAdapter) adapter;<br>            mLazyAdapter.setFirstLoad(true);<br>            super.setAdapter(adapter);<br>        } else {<br>            throw new IllegalArgumentException(“The adapter must be LazyAdapter”);<br>        }<br>    }<br>    @Override<br>    public void onScrollStateChanged(AbsListView view, int scrollState) {<br>        // TODO Auto-generated method stub<br>        if (scrollState == SCROLL_STATE_IDLE) {<br>            mLazyAdapter.onLazyLoad(mFirstCount, mVisibleCount + mFirstCount);<br>        }<br>        if (mLazyAdapter.isFirstLoad()) {<br>            if (scrollState == SCROLL_STATE_TOUCH_SCROLL) {<br>                mLazyAdapter.setFirstLoad(false);<br>            }<br>        }<br>        mLazyAdapter.setScrollState(scrollState);<br>    }<br>    @Override<br>    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {<br>        mFirstCount = firstVisibleItem;<br>        mVisibleCount = visibleItemCount;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">接着看看我们如何使用：</span><br></pre></td></tr></table></figure></p>\n<p>public class DemoAdapter extends LazyAdapter {<br>    private SparseArray<lkimageview> mLazyImgs;<br>    @Override<br>    public void onLazyLoad(int first, int last) {<br>        //ToDo<br>        for (int i = first - 2; i &lt; last + 2; i++) {<br>            LKImageView img = mLazyImgs.get(i);<br>            if (img != null) {<br>                DisplayOptions options=…<br>                img.displayWithMemory(options);<br>            }<br>        }<br>        mLazyImgs.clear();<br>    }<br>    @Override<br>    public View getView(int position, View cv, ViewGroup viewGroup) {<br>          …<br>           Holder holder=…<br>           DisplayOptions options=…<br>           if(isFirstLoad()){<br>               holder.mImg.display(options);<br>           }else{<br>               if(isTouchScroll()){<br>                   holder.mImg.display(options);<br>               }else{<br>                   if(holder.mImg.tryDisplayWithMemory(options)){<br>                       mLazyImgs.append(position,holder.mImg);<br>                   }<br>               }<br>           }<br>           . . .<br>        return view;  //ToDo<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">LKImageView 是继承自ImageView类，并扩展了很多附加功能的控件，可以实现内存/磁盘缓存，显示功能==&gt;Link-ImageLoader</span><br><span class=\"line\">现在我们只要知道：</span><br><span class=\"line\"></span><br><span class=\"line\">- ```public void display(DisplayOptions options);``` 异步加载图片的方法。</span><br><span class=\"line\">- ```public boolean tryDisplayWithMemory(DisplayOptions options); ```尝试从内存中同步加载图片的方法</span><br><span class=\"line\"></span><br><span class=\"line\">在onLazyLoad()中 ```for (int i = first - 2; i &lt; last + 2; i++)</span><br></pre></td></tr></table></figure></lkimageview></p>\n<p>分别-2和+2，可以做到不仅仅加载当前屏幕的可见范围，还可以多加载几个，不做调整也是没有关系的。</p>\n<p><strong>并且<code>mLazyImgs.clear()</code>在结束是必须要调用的，不然会有问题。</strong></p>\n<p>现在就去尝试下吧，你可以下载我们的这个应用</p>\n<p><img src=\"https://lh4.ggpht.com/EUP4NTyHIMdWZsMgYX5w2kgIE3e3JE5Ud_Yx7tkeYOj8AALgSS2TUYoW92V-dQvVyVM=w124\" height=\"50\"><a href=\"https://play.google.com/store/apps/details?id=com.huaban.wallpaper&amp;feature=search_result#?t=W251bGwsMSwxLDEsImNvbS5odWFiYW4ud2FsbHBhcGVyIl0.\" target=\"_blank\" rel=\"noopener\">壁纸控</a> ，里面使用了这套加载策略。</p>\n"},{"date":"2013-05-14T16:00:00.000Z","layout":"post","title":"Android开发者指南之App Widgets (译)","_content":"App Widgets是一种能嵌入到其他应用程序(如Home screen)的小型应用程序界面，并且能接收定时的更新。这些视图被称为用户界面中的窗口小部件，需要App Widget provider才能发布.能持有其他App Widgets的应用组件叫做App Widget host.下面显示了一张Music App Widget的图。\n\n![music app widget](http://developer.android.com/images/appwidgets/appwidget.png)\n\n本文档将描述如何使用App Widget provider发布一个App Widget。\n\n> ####Widget Design\n> 更多关于如何设计你的app widget,你可以阅读这篇 [窗口小部件设计指导](http://developer.android.com/design/patterns/widgets.html).\n\n##基础\n---\n创建一个App Widget ，你需要以下条件:\n\n1. AppWidgetProviderInfo 对象。用来描述App Widget的元数据，比如App Widget的布局，更新频率，AppWidgetProvider类。也可以使用xml定义。\n2. AppWidgetProvider 类实例。定义了一些基本方法，需要你去实现这些接口，是基于广播(broadcast)事件的。通过它，你可以接收到什么时候App Widget被更新了，可使用，不可使用和被删除了等状态。\n3. 界面布局。定义了为App Widget初始化的布局，定义在XML中。\n\n此外，你可以实现一个App Widget配置Activity。这个可选的Activity的主要作用是，当用户在启动器(launches)中添加了你的App Widget时允许他在创建的时候就修改App Widget的设置。\n\n以下各节描述了如何设置每个组件\n\n##在Manifest中声明一个App Widget\n---\n首先，在你应用程序的AndroidManifest.xml文件中声明AppWidgetProvider类，像这样:\n\n```\n<receiver android:name=\"ExampleAppWidgetProvider\" >\n    <intent-filter>\n        <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n    </intent-filter>\n    <meta-data android:name=\"android.appwidget.provider\"\n               android:resource=\"@xml/example_appwidget_info\" />\n</receiver>\n```\n\n`<receiver>`元素需要android:name属性，用来指定App Widget所使用的AppWidgetProvider。\n\n`<intent-filter>`元素必须包含一个带有android:name属性的`<action>`元素。这个属性指定了AppWidgetProvider接收`ACTION_APPWIDGET_UPDATE`广播。这是你必须要显示声明的广播。AppWidgetManager会自动发生其他所有的App Widget广播到AppWidgetProvider中，如果有必要的话。\n\n`<meta-data>`元素指定了AppWidgetProviderInfo的来源并且要求有以下属性：\n- android:name-指定元数据名称。使用`android.appwidget.provider`作为AppWidgetProviderInfo的描述来识别数据\n- android:resource-指定AppWidgetProviderInfo的本地来源\n\n##添加AppWidgetProviderInfo 元数据\n---\nAppWidgetProviderInfo定义了一个App Widget必要的特性（qualities），例如最小的布局尺寸，初始布局资源，多久更新一次App Widget，创建时调用的配置Activity。可以使用单个`<appwidget-provider>`元素的XML资源来定义AppWidgetProviderInfo对象，然后保持到项目的`res/xml/`文件夹下。\n\n例如：\n\n```\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:minWidth=\"294dp\"\n    android:minHeight=\"72dp\"\n    android:updatePeriodMillis=\"86400000\"\n    android:previewImage=\"@drawable/preview\"\n    android:initialLayout=\"@layout/example_appwidget\"\n    android:configure=\"com.example.android.ExampleAppWidgetConfigure\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:widgetCategory=\"home_screen|keyguard\"\n    android:initialKeyguardLayout=\"@layout/example_keyguard\">\n</appwidget-provider>\n```\n\n关于`<appwidget-provider>`属性的一些总结:\n\n- `miniWidth`和`minHeight`\n- `minResizeWidth`和`minResizeHeight`\n- `updatePeriodMillis`\n- `initialLayout`\n- `configure`\n- `perviewImage`\n- `autoAdvanceViewId`\n- `resizeMode`\n- `widgetCategory`\n- `initialKeyguardLayout`\n\n关于更多`<appwidget-provider>可以接收的属性的相关信息，可以查看[AppWidgetProviderInfo](http://developer.android.com/reference/android/appwidget/AppWidgetProviderInfo.html)类。\n\n## 创建App Widget布局\n---\n\n你必须将你的App Widget初始化布局定义在XML中，并且将它保存在项目的`res/layout/`目录下。你可以使用下面列表列出的视图对象来设计你的App Widget,但是在你设计你的App Widget前，请先阅读并理解[App Widget Design Guidelines](http://developer.android.com/guide/practices/ui_guidelines/widget_design.html)。\n\n创建一个App Widget布局是很简单的，如果你很了解[Layouts](http://developer.android.com/guide/topics/ui/declaring-layout.html)的话。但是你应该意识到App Widget是基于[RemoteViews](http://developer.android.com/reference/android/widget/RemoteViews.html)的，它不支持所有类型的布局和控件(view widget)。\n\n一个RemoteViews对象(consequently 一个App Widget)可以支持以下的布局类:\n\n- FrameLayout\n- LinearLayout\n- RelativeLayout\n- GridLayout\n\n和以下控件类:\n\n- AnalogClock\n- Button\n- Chronometer\n- ImageButton\n- ImageView\n- ProgressBar\n- TextView\n- ViewFlipper\n- ListView\n- GridView\n- StackView\n- AdapterViewFlipper\n\n这些类的派生类(Descendants)是不支持的。\n\nRemoteViews 也支持 ViewStub,一种不可见，不占大小的视图，你可以在运行时延迟`inflate`布局资源\n\n### 为App Widget添加margins\n\n## 使用AppWidgetProvider类\n---\n###接收App Widget广播意图 (broadcast intents)\n\n## 创建一个App Widget配置Activity\n---\n\n###从配置Activity更新App Widget\n\n\n## 设置预览图片\n---\n\n##使App Widget在锁屏上可用\n---\n\n###改变大小指导\n\n##使用带有集合的App Widget\n---\nAndroid 3.0引进了带有集合的App Widget。这种App Widget使用RemoteViewService去显示那些支持远程数据的集合,例如从content provider。由RemoteViewsService提供的数据展示在App Widget中使用了以下视图类型中的一种,我们称之为\"collections views\"\n\n- ListView:A view that shows items in a vertically scrolling list. For an example, see the Gmail app widget.\n- GridView:A view that shows items in two-dimensional scrolling grid. For an example, see the Bookmarks app widget.\n- StackView:A stacked card view (kind of like a rolodex), where the user can flick the front card up/down to see the previous/next card, respectively. Examples include the YouTube and Books app widgets.\n- AdapterViewFlipper:An adapter-backed simple ViewAnimator that animates between two or more views. Only one child is shown at a time.\n\n正如上文所述,这些collections views显示支持远程数据的集合。这意味着他们使用Adpater将接口和数据\n绑定一起。Adapter绑定将特殊items从一些集合的数据绑定到特殊的视图对象上。因为这些collection views被adapters支持，所以Android框架必须包含额外的体系结构去支持他们在app widget中使用。在app widget的上下文中，adapter被代替为RemoteViewsFactory,仅仅是简单的对Adapter接口进行了薄封装。当请求在集合中一个具体的item，RemoteViewsFactory会为集合创建并返回RemoteViews对象作为Item。为了能在你的app widget中使用collection view，你必须实现RemoteViewService和RemoteViewsFactory。\n\nRemoteViewsService是一种允许一个远程adapter请求RemoteViews对象的service。\nRemoteViewsFactory是一种为collections view（如ListView,GridView等）和视图中潜在数据做适配的接口。下面这段模板代码,你可以用实现service和interface，从StackView Widget sample中提取出来的:\n\n```\npublic class StackWidgetService extends RemoteViewsService {\n    @Override\n    public RemoteViewsFactory onGetViewFactory(Intent intent) {\n        return new StackRemoteViewsFactory(this.getApplicationContext(), intent);\n    }\n}\nclass StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {\n//... include adapter-like methods here. See the StackView Widget sample.\n}\n```\n\n### 例子应用\n\n本节的代码片段取材至StackView Widget sample:\n\n![sample](http://developer.android.com/images/appwidgets/StackWidget.png)\n\n例子有十个栈视图组成，从\"0!\"显示到\"9!\"。这个例子app widget有以下主要行为：\n\n- 用户可以垂直方向甩动在app widget的顶部View，来显示上一个或者下一个view。这是内建在StackView的行为。\n- Without any user interaction, the app widget automatically advances through its views in sequence, like a slide show. This is due to the setting android:autoAdvanceViewId=\"@id/stack_view\" in the res/xml/stackwidgetinfo.xml file. This setting applies to the view ID, which in this case is the view ID of the stack view.\n- If the user touches the top view, the app widget displays the Toast message \"Touched view n,\" where n is the index (position) of the touched view. For more discussion of how this is implemented, see Adding behavior to individual items.\n\n### 实现带有集合的App Widget\nTo implement an App Widget with collections, you follow the same basic steps you would use to implement any app widget. The following sections describe the additional steps you need to perform to implement an App Widget with collections.\n\n### 带有集合的App Widget的清单\nIn addition to the requirements listed in Declaring an App Widget in the Manifest, to make it possible for App Widgets with collections to bind to your RemoteViewsService, you must declare the service in your manifest file with the permission BIND_REMOTEVIEWS. This prevents other applications from freely accessing your app widget's data. For example, when creating an App Widget that uses RemoteViewsService to populate a collection view, the manifest entry may look like this:\n\n```\n<service android:name=\"MyWidgetService\"\n...\nandroid:permission=\"android.permission.BIND_REMOTEVIEWS\" />\n```\nThe line `android:name=\"MyWidgetService\"` refers to your subclass of RemoteViewsService.\n\n\n### 带有集合的App Widget的布局\nThe main requirement for your app widget layout XML file is that it include one of the collection views: ListView, GridView, StackView, or AdapterViewFlipper. Here is the widget_layout.xml for the StackView Widget sample:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <StackView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:id=\"@+id/stack_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:gravity=\"center\"\n        android:loopViews=\"true\" />\n    <TextView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:id=\"@+id/empty_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:gravity=\"center\"\n        android:background=\"@drawable/widget_item_background\"\n        android:textColor=\"#ffffff\"\n        android:textStyle=\"bold\"\n        android:text=\"@string/empty_view_text\"\n        android:textSize=\"20sp\" />\n</FrameLayout>\n```\nNote that empty views must be siblings of the collection view for which the empty view represents empty state.\n\nIn addition to the layout file for your entire app widget, you must create another layout file that defines the layout for each item in the collection (for example, a layout for each book in a collection of books). For example, the StackView Widget sample only has one layout file, widget_item.xml, since all items use the same layout. But the WeatherListWidget sample has two layout files: dark_widget_item.xml and light_widget_item.xml.\n\n### 带有集合的App Widget的AppWidgetProvider\n\nAs with a regular app widget, the bulk of your code in your AppWidgetProvider subclass typically goes in onUpdate(). The major difference in your implementation for onUpdate() when creating an app widget with collections is that you must call setRemoteAdapter(). This tells the collection view where to get its data. The RemoteViewsService can then return your implementation of RemoteViewsFactory, and the widget can serve up the appropriate data. When you call this method, you must pass an intent that points to your implementation of RemoteViewsService and the App Widget ID that specifies the app widget to update.\n\nFor example, here's how the StackView Widget sample implements the onUpdate() callback method to set the RemoteViewsService as the remote adapter for the app widget collection:\n\n```\npublic void onUpdate(Context context, AppWidgetManager appWidgetManager,\nint[] appWidgetIds) {\n    // update each of the app widgets with the remote adapter\n    for (int i = 0; i < appWidgetIds.length; ++i) {     \n        // Set up the intent that starts the StackViewService, which will\n        // provide the views for this collection.\n        Intent intent = new Intent(context, StackWidgetService.class);\n        // Add the app widget ID to the intent extras.\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);\n        intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));\n        // Instantiate the RemoteViews object for the App Widget layout.\n        RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_layout);\n        // Set up the RemoteViews object to use a RemoteViews adapter.\n        // This adapter connects\n        // to a RemoteViewsService  through the specified intent.\n        // This is how you populate the data.\n        rv.setRemoteAdapter(appWidgetIds[i], R.id.stack_view, intent);       \n        // The empty view is displayed when the collection has no items.\n        // It should be in the same layout used to instantiate the RemoteViews\n        // object above.\n        rv.setEmptyView(R.id.stack_view, R.id.empty_view);\n        //\n        // Do additional processing specific to this app widget...\n        //     \n        appWidgetManager.updateAppWidget(appWidgetIds[i], rv);   \n    }\n    super.onUpdate(context, appWidgetManager, appWidgetIds);\n}\n```\n\n### RemoteViewsService类\n\nAs described above, your RemoteViewsService subclass provides the RemoteViewsFactory used to populate the remote collection view.\n\nSpecifically, you need to perform these steps:\n\n1. Subclass RemoteViewsService. RemoteViewsService is the service through which a remote adapter can request RemoteViews.\n2. In your RemoteViewsService subclass, include a class that implements the RemoteViewsFactory interface. RemoteViewsFactory is an interface for an adapter between a remote collection view (such as ListView, GridView, and so on) and the underlying data for that view. Your implementation is responsible for making a RemoteViews object for each item in the data set. This interface is a thin wrapper around Adapter.\n\nThe primary contents of the RemoteViewsService implementation is its RemoteViewsFactory, described below.\n\n### RemoteViewsFactory接口\n\nYour custom class that implements the RemoteViewsFactory interface provides the app widget with the data for the items in its collection. To do this, it combines your app widget item XML layout file with a source of data. This source of data could be anything from a database to a simple array. In the StackView Widget sample, the data source is an array of WidgetItems. The RemoteViewsFactory functions as an adapter to glue the data to the remote collection view.\n\nThe two most important methods you need to implement for your RemoteViewsFactory subclass are onCreate() and getViewAt() .\n\nThe system calls onCreate() when creating your factory for the first time. This is where you set up any connections and/or cursors to your data source. For example, the StackView Widget sample uses onCreate() to initialize an array of WidgetItem objects. When your app widget is active, the system accesses these objects using their index position in the array and the text they contain is displayed\n\nHere is an excerpt from the StackView Widget sample's RemoteViewsFactory implementation that shows portions of the onCreate() method:\n\n```\nclass StackRemoteViewsFactory implements\nRemoteViewsService.RemoteViewsFactory {\n    private static final int mCount = 10;\n    private List<WidgetItem> mWidgetItems = new ArrayList<WidgetItem>();\n    private Context mContext;\n    private int mAppWidgetId;\n    public StackRemoteViewsFactory(Context context, Intent intent) {\n        mContext = context;\n        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n    }\n    public void onCreate() {\n        // In onCreate() you setup any connections / cursors to your data source. Heavy lifting,\n        // for example downloading or creating content etc, should be deferred to onDataSetChanged()\n        // or getViewAt(). Taking more than 20 seconds in this call will result in an ANR.\n        for (int i = 0; i < mCount; i++) {\n            mWidgetItems.add(new WidgetItem(i + \"!\"));\n        }\n        ...\n    }\n...\n```\n\nThe RemoteViewsFactory method getViewAt() returns a RemoteViews object corresponding to the data at the specified position in the data set. Here is an excerpt from the StackView Widget sample's RemoteViewsFactory implementation:\n\n```\npublic RemoteViews getViewAt(int position) {\n    // Construct a remote views item based on the app widget item XML file,\n    // and set the text based on the position.\n    RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.widget_item);\n    rv.setTextViewText(R.id.widget_item, mWidgetItems.get(position).text);\n    ...\n    // Return the remote views object.\n    return rv;\n}\n```\n\n### 为个别Item添加行为\nThe above sections show you how to bind your data to your app widget collection. But what if you want to add dynamic behavior to the individual items in your collection view?\n\nAs described in Using the AppWidgetProvider Class, you normally use setOnClickPendingIntent() to set an object's click behavior—such as to cause a button to launch an Activity. But this approach is not allowed for child views in an individual collection item (to clarify, you could use setOnClickPendingIntent() to set up a global button in the Gmail app widget that launches the app, for example, but not on the individual list items). Instead, to add click behavior to individual items in a collection, you use setOnClickFillInIntent(). This entails setting up up a pending intent template for your collection view, and then setting a fill-in intent on each item in the collection via your RemoteViewsFactory.\n\nThis section uses the StackView Widget sample to describe how to add behavior to individual items. In the StackView Widget sample, if the user touches the top view, the app widget displays the Toast message \"Touched view n,\" where n is the index (position) of the touched view. This is how it works:\n\n- The StackWidgetProvider (an AppWidgetProvider subclass) creates a pending intent that has a custom action called TOAST_ACTION.\n- When the user touches a view, the intent is fired and it broadcasts TOAST_ACTION.\n- This broadcast is intercepted by the StackWidgetProvider's onReceive() method, and the app widget displays the Toast message for the touched view. The data for the collection items is provided by the RemoteViewsFactory, via the RemoteViewsService.\n\n>Note: The StackView Widget sample uses a broadcast, but typically an app widget would simply launch an activity in a scenario like this one.\n\n#### 设置待定意图模板(pending intent template)\nStackWidgetProvider（AppWidgetProvider子类）设置了一个待定意图.集合中具体的Item不能单独设置属于他们自己的待定意图。(注：性能原因) 取而代之的，集合作为一个整体设置一个待定意图模板，然后具体的Item设置填充意图(fill-in intent)来创建在item-by-item\nThe StackWidgetProvider (AppWidgetProvider subclass) sets up a pending intent. Individuals items of a collection cannot set up their own pending intents. Instead, the collection as a whole sets up a pending intent template, and the individual items set a fill-in intent to create unique behavior on an item-by-item basis.\n\nThis class also receives the broadcast that is sent when the user touches a view. It processes this event in its onReceive() method. If the intent's action is TOAST_ACTION, the app widget displays a Toast message for the current view.\n\n\n```\npublic class StackWidgetProvider extends AppWidgetProvider {\n    public static final String TOAST_ACTION = \"com.example.android.stackwidget.TOAST_ACTION\";\n    public static final String EXTRA_ITEM = \"com.example.android.stackwidget.EXTRA_ITEM\";\n    ...\n    // Called when the BroadcastReceiver receives an Intent broadcast.\n    // Checks to see whether the intent's action is TOAST_ACTION. If it is, the app widget\n    // displays a Toast message for the current item.\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n        if (intent.getAction().equals(TOAST_ACTION)) {\n            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n            int viewIndex = intent.getIntExtra(EXTRA_ITEM, 0);\n            Toast.makeText(context, \"Touched view \" + viewIndex, Toast.LENGTH_SHORT).show();\n        }\n        super.onReceive(context, intent);\n    }\n    @Override\n    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {\n        // update each of the app widgets with the remote adapter\n        for (int i = 0; i < appWidgetIds.length; ++i) {\n            // Sets up the intent that points to the StackViewService that will\n            // provide the views for this collection.\n            Intent intent = new Intent(context, StackWidgetService.class);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);\n            // When intents are compared, the extras are ignored, so we need to embed the extras\n            // into the data so that the extras will not be ignored.\n            intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));\n            RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_layout);\n            rv.setRemoteAdapter(appWidgetIds[i], R.id.stack_view, intent);\n            // The empty view is displayed when the collection has no items. It should be a sibling\n            // of the collection view.\n            rv.setEmptyView(R.id.stack_view, R.id.empty_view);\n            // This section makes it possible for items to have individualized behavior.\n            // It does this by setting up a pending intent template. Individuals items of a collection\n            // cannot set up their own pending intents. Instead, the collection as a whole sets\n            // up a pending intent template, and the individual items set a fillInIntent\n            // to create unique behavior on an item-by-item basis.\n            Intent toastIntent = new Intent(context, StackWidgetProvider.class);\n            // Set the action for the intent.\n            // When the user touches a particular view, it will have the effect of\n            // broadcasting TOAST_ACTION.\n            toastIntent.setAction(StackWidgetProvider.TOAST_ACTION);\n            toastIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);\n            intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));\n            PendingIntent toastPendingIntent = PendingIntent.getBroadcast(context, 0, toastIntent,\n                PendingIntent.FLAG_UPDATE_CURRENT);\n            rv.setPendingIntentTemplate(R.id.stack_view, toastPendingIntent);\n            appWidgetManager.updateAppWidget(appWidgetIds[i], rv);\n        }\n    super.onUpdate(context, appWidgetManager, appWidgetIds);\n    }\n}\n```\n\n#### 设置填充意图(fill-in intent)\n你的RemoteViewsFactory必须为每一个在集合中的item设置一个填充意图(fill-in intent)。这样才可能做到区分给定的Item单独的点击动作。填充意图然后与待定意图模板(PendingItent template)结合一起，确定了当item被点击时将执行的最终意图。\n\n```\npublic class StackWidgetService extends RemoteViewsService {\n    @Override\n    public RemoteViewsFactory onGetViewFactory(Intent intent) {\n        return new StackRemoteViewsFactory(this.getApplicationContext(), intent);\n    }\n}\nclass StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {\n    private static final int mCount = 10;\n    private List<WidgetItem> mWidgetItems = new ArrayList<WidgetItem>();\n    private Context mContext;\n    private int mAppWidgetId;\n    public StackRemoteViewsFactory(Context context, Intent intent) {\n        mContext = context;\n        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n    }\n    // 初始化数据\n        public void onCreate() {\n            // 在 onCreate()你可以建立任何连接/游标 到你的源数据中.Heavy lifting.\n            // 如下载或者创建内容等，应该延迟到onDataSetChanged()方法中\n            // 或者 getViewAt(), 在这个回调中耗时超过20秒，将会引起ANR.\n            for (int i = 0; i < mCount; i++) {\n                mWidgetItems.add(new WidgetItem(i + \"!\"));\n            }\n           ...\n        }\n        ...\n        // Given the position (index) of a WidgetItem in the array, use the item's text value in\n        // combination with the app widget item XML file to construct a RemoteViews object.\n        public RemoteViews getViewAt(int position) {\n            // position will always range from 0 to getCount() - 1.\n            // Construct a RemoteViews item based on the app widget item XML file, and set the\n            // text based on the position.\n            RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.widget_item);\n            rv.setTextViewText(R.id.widget_item, mWidgetItems.get(position).text);\n            // Next, set a fill-intent, which will be used to fill in the pending intent template\n            // that is set on the collection view in StackWidgetProvider.\n            Bundle extras = new Bundle();\n            extras.putInt(StackWidgetProvider.EXTRA_ITEM, position);\n            Intent fillInIntent = new Intent();\n            fillInIntent.putExtras(extras);\n            // Make it possible to distinguish the individual on-click\n            // action of a given item\n            rv.setOnClickFillInIntent(R.id.widget_item, fillInIntent);\n            ...\n            // Return the RemoteViews object.\n            return rv;\n        }\n    ...\n    }\n```\n\n## 保持集合数据最新\n\n下面的流程图发生在一个使用了集合的App Widget更新数据时。它展示了App Widget代码与RemoteViewsFactory的交互，以及你如何触发更新。\n\n![fresh data](http://developer.android.com/images/appwidgets/appwidget_collections.png)\n\n使用了集合的App Widgets的其中一个特性就是可以为用户提供最新的内容。例如，Android 3.0 Gmail app widget，可以为用户提供他们收件箱的一个快照。为了做到这一点，你需要能触发你的RemoteViewsFactory和集合view,去获得并且显示新数据。你可以通过使用AppWidgetManager调用notifyAppWidgetViewDataChanged()来实现这一点。然后在你的RemoteViewsFactory的OnDataChanged()获得一个回调结果，一个你有机会可以获取任何新数据的回调接口。注意，你可以在onDataSetChanged()回调方法中执行密集的同步操作(processing-intensive operations synchronously)。回调方法在元数据或者视图数据从RemoteViewsFactory那里获取之前以及被执行完成，所以你可以放心。此外，你也可以在getViewAt()方法内执行密集的同步操作。**如果这个回调函数执行了很长时间，那么加载视图(RemoteViewsFactory中指定的getLoadingView()方法)将被显示在集合视图中正确的位置，直到它返回结果.**\n","source":"_posts/2013-05-15-app-widget.md","raw":"---\ncategory: Android\ndate: 2013-05-15\nlayout: post\ntitle: Android开发者指南之App Widgets (译)\n---\nApp Widgets是一种能嵌入到其他应用程序(如Home screen)的小型应用程序界面，并且能接收定时的更新。这些视图被称为用户界面中的窗口小部件，需要App Widget provider才能发布.能持有其他App Widgets的应用组件叫做App Widget host.下面显示了一张Music App Widget的图。\n\n![music app widget](http://developer.android.com/images/appwidgets/appwidget.png)\n\n本文档将描述如何使用App Widget provider发布一个App Widget。\n\n> ####Widget Design\n> 更多关于如何设计你的app widget,你可以阅读这篇 [窗口小部件设计指导](http://developer.android.com/design/patterns/widgets.html).\n\n##基础\n---\n创建一个App Widget ，你需要以下条件:\n\n1. AppWidgetProviderInfo 对象。用来描述App Widget的元数据，比如App Widget的布局，更新频率，AppWidgetProvider类。也可以使用xml定义。\n2. AppWidgetProvider 类实例。定义了一些基本方法，需要你去实现这些接口，是基于广播(broadcast)事件的。通过它，你可以接收到什么时候App Widget被更新了，可使用，不可使用和被删除了等状态。\n3. 界面布局。定义了为App Widget初始化的布局，定义在XML中。\n\n此外，你可以实现一个App Widget配置Activity。这个可选的Activity的主要作用是，当用户在启动器(launches)中添加了你的App Widget时允许他在创建的时候就修改App Widget的设置。\n\n以下各节描述了如何设置每个组件\n\n##在Manifest中声明一个App Widget\n---\n首先，在你应用程序的AndroidManifest.xml文件中声明AppWidgetProvider类，像这样:\n\n```\n<receiver android:name=\"ExampleAppWidgetProvider\" >\n    <intent-filter>\n        <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n    </intent-filter>\n    <meta-data android:name=\"android.appwidget.provider\"\n               android:resource=\"@xml/example_appwidget_info\" />\n</receiver>\n```\n\n`<receiver>`元素需要android:name属性，用来指定App Widget所使用的AppWidgetProvider。\n\n`<intent-filter>`元素必须包含一个带有android:name属性的`<action>`元素。这个属性指定了AppWidgetProvider接收`ACTION_APPWIDGET_UPDATE`广播。这是你必须要显示声明的广播。AppWidgetManager会自动发生其他所有的App Widget广播到AppWidgetProvider中，如果有必要的话。\n\n`<meta-data>`元素指定了AppWidgetProviderInfo的来源并且要求有以下属性：\n- android:name-指定元数据名称。使用`android.appwidget.provider`作为AppWidgetProviderInfo的描述来识别数据\n- android:resource-指定AppWidgetProviderInfo的本地来源\n\n##添加AppWidgetProviderInfo 元数据\n---\nAppWidgetProviderInfo定义了一个App Widget必要的特性（qualities），例如最小的布局尺寸，初始布局资源，多久更新一次App Widget，创建时调用的配置Activity。可以使用单个`<appwidget-provider>`元素的XML资源来定义AppWidgetProviderInfo对象，然后保持到项目的`res/xml/`文件夹下。\n\n例如：\n\n```\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:minWidth=\"294dp\"\n    android:minHeight=\"72dp\"\n    android:updatePeriodMillis=\"86400000\"\n    android:previewImage=\"@drawable/preview\"\n    android:initialLayout=\"@layout/example_appwidget\"\n    android:configure=\"com.example.android.ExampleAppWidgetConfigure\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:widgetCategory=\"home_screen|keyguard\"\n    android:initialKeyguardLayout=\"@layout/example_keyguard\">\n</appwidget-provider>\n```\n\n关于`<appwidget-provider>`属性的一些总结:\n\n- `miniWidth`和`minHeight`\n- `minResizeWidth`和`minResizeHeight`\n- `updatePeriodMillis`\n- `initialLayout`\n- `configure`\n- `perviewImage`\n- `autoAdvanceViewId`\n- `resizeMode`\n- `widgetCategory`\n- `initialKeyguardLayout`\n\n关于更多`<appwidget-provider>可以接收的属性的相关信息，可以查看[AppWidgetProviderInfo](http://developer.android.com/reference/android/appwidget/AppWidgetProviderInfo.html)类。\n\n## 创建App Widget布局\n---\n\n你必须将你的App Widget初始化布局定义在XML中，并且将它保存在项目的`res/layout/`目录下。你可以使用下面列表列出的视图对象来设计你的App Widget,但是在你设计你的App Widget前，请先阅读并理解[App Widget Design Guidelines](http://developer.android.com/guide/practices/ui_guidelines/widget_design.html)。\n\n创建一个App Widget布局是很简单的，如果你很了解[Layouts](http://developer.android.com/guide/topics/ui/declaring-layout.html)的话。但是你应该意识到App Widget是基于[RemoteViews](http://developer.android.com/reference/android/widget/RemoteViews.html)的，它不支持所有类型的布局和控件(view widget)。\n\n一个RemoteViews对象(consequently 一个App Widget)可以支持以下的布局类:\n\n- FrameLayout\n- LinearLayout\n- RelativeLayout\n- GridLayout\n\n和以下控件类:\n\n- AnalogClock\n- Button\n- Chronometer\n- ImageButton\n- ImageView\n- ProgressBar\n- TextView\n- ViewFlipper\n- ListView\n- GridView\n- StackView\n- AdapterViewFlipper\n\n这些类的派生类(Descendants)是不支持的。\n\nRemoteViews 也支持 ViewStub,一种不可见，不占大小的视图，你可以在运行时延迟`inflate`布局资源\n\n### 为App Widget添加margins\n\n## 使用AppWidgetProvider类\n---\n###接收App Widget广播意图 (broadcast intents)\n\n## 创建一个App Widget配置Activity\n---\n\n###从配置Activity更新App Widget\n\n\n## 设置预览图片\n---\n\n##使App Widget在锁屏上可用\n---\n\n###改变大小指导\n\n##使用带有集合的App Widget\n---\nAndroid 3.0引进了带有集合的App Widget。这种App Widget使用RemoteViewService去显示那些支持远程数据的集合,例如从content provider。由RemoteViewsService提供的数据展示在App Widget中使用了以下视图类型中的一种,我们称之为\"collections views\"\n\n- ListView:A view that shows items in a vertically scrolling list. For an example, see the Gmail app widget.\n- GridView:A view that shows items in two-dimensional scrolling grid. For an example, see the Bookmarks app widget.\n- StackView:A stacked card view (kind of like a rolodex), where the user can flick the front card up/down to see the previous/next card, respectively. Examples include the YouTube and Books app widgets.\n- AdapterViewFlipper:An adapter-backed simple ViewAnimator that animates between two or more views. Only one child is shown at a time.\n\n正如上文所述,这些collections views显示支持远程数据的集合。这意味着他们使用Adpater将接口和数据\n绑定一起。Adapter绑定将特殊items从一些集合的数据绑定到特殊的视图对象上。因为这些collection views被adapters支持，所以Android框架必须包含额外的体系结构去支持他们在app widget中使用。在app widget的上下文中，adapter被代替为RemoteViewsFactory,仅仅是简单的对Adapter接口进行了薄封装。当请求在集合中一个具体的item，RemoteViewsFactory会为集合创建并返回RemoteViews对象作为Item。为了能在你的app widget中使用collection view，你必须实现RemoteViewService和RemoteViewsFactory。\n\nRemoteViewsService是一种允许一个远程adapter请求RemoteViews对象的service。\nRemoteViewsFactory是一种为collections view（如ListView,GridView等）和视图中潜在数据做适配的接口。下面这段模板代码,你可以用实现service和interface，从StackView Widget sample中提取出来的:\n\n```\npublic class StackWidgetService extends RemoteViewsService {\n    @Override\n    public RemoteViewsFactory onGetViewFactory(Intent intent) {\n        return new StackRemoteViewsFactory(this.getApplicationContext(), intent);\n    }\n}\nclass StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {\n//... include adapter-like methods here. See the StackView Widget sample.\n}\n```\n\n### 例子应用\n\n本节的代码片段取材至StackView Widget sample:\n\n![sample](http://developer.android.com/images/appwidgets/StackWidget.png)\n\n例子有十个栈视图组成，从\"0!\"显示到\"9!\"。这个例子app widget有以下主要行为：\n\n- 用户可以垂直方向甩动在app widget的顶部View，来显示上一个或者下一个view。这是内建在StackView的行为。\n- Without any user interaction, the app widget automatically advances through its views in sequence, like a slide show. This is due to the setting android:autoAdvanceViewId=\"@id/stack_view\" in the res/xml/stackwidgetinfo.xml file. This setting applies to the view ID, which in this case is the view ID of the stack view.\n- If the user touches the top view, the app widget displays the Toast message \"Touched view n,\" where n is the index (position) of the touched view. For more discussion of how this is implemented, see Adding behavior to individual items.\n\n### 实现带有集合的App Widget\nTo implement an App Widget with collections, you follow the same basic steps you would use to implement any app widget. The following sections describe the additional steps you need to perform to implement an App Widget with collections.\n\n### 带有集合的App Widget的清单\nIn addition to the requirements listed in Declaring an App Widget in the Manifest, to make it possible for App Widgets with collections to bind to your RemoteViewsService, you must declare the service in your manifest file with the permission BIND_REMOTEVIEWS. This prevents other applications from freely accessing your app widget's data. For example, when creating an App Widget that uses RemoteViewsService to populate a collection view, the manifest entry may look like this:\n\n```\n<service android:name=\"MyWidgetService\"\n...\nandroid:permission=\"android.permission.BIND_REMOTEVIEWS\" />\n```\nThe line `android:name=\"MyWidgetService\"` refers to your subclass of RemoteViewsService.\n\n\n### 带有集合的App Widget的布局\nThe main requirement for your app widget layout XML file is that it include one of the collection views: ListView, GridView, StackView, or AdapterViewFlipper. Here is the widget_layout.xml for the StackView Widget sample:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <StackView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:id=\"@+id/stack_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:gravity=\"center\"\n        android:loopViews=\"true\" />\n    <TextView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:id=\"@+id/empty_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:gravity=\"center\"\n        android:background=\"@drawable/widget_item_background\"\n        android:textColor=\"#ffffff\"\n        android:textStyle=\"bold\"\n        android:text=\"@string/empty_view_text\"\n        android:textSize=\"20sp\" />\n</FrameLayout>\n```\nNote that empty views must be siblings of the collection view for which the empty view represents empty state.\n\nIn addition to the layout file for your entire app widget, you must create another layout file that defines the layout for each item in the collection (for example, a layout for each book in a collection of books). For example, the StackView Widget sample only has one layout file, widget_item.xml, since all items use the same layout. But the WeatherListWidget sample has two layout files: dark_widget_item.xml and light_widget_item.xml.\n\n### 带有集合的App Widget的AppWidgetProvider\n\nAs with a regular app widget, the bulk of your code in your AppWidgetProvider subclass typically goes in onUpdate(). The major difference in your implementation for onUpdate() when creating an app widget with collections is that you must call setRemoteAdapter(). This tells the collection view where to get its data. The RemoteViewsService can then return your implementation of RemoteViewsFactory, and the widget can serve up the appropriate data. When you call this method, you must pass an intent that points to your implementation of RemoteViewsService and the App Widget ID that specifies the app widget to update.\n\nFor example, here's how the StackView Widget sample implements the onUpdate() callback method to set the RemoteViewsService as the remote adapter for the app widget collection:\n\n```\npublic void onUpdate(Context context, AppWidgetManager appWidgetManager,\nint[] appWidgetIds) {\n    // update each of the app widgets with the remote adapter\n    for (int i = 0; i < appWidgetIds.length; ++i) {     \n        // Set up the intent that starts the StackViewService, which will\n        // provide the views for this collection.\n        Intent intent = new Intent(context, StackWidgetService.class);\n        // Add the app widget ID to the intent extras.\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);\n        intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));\n        // Instantiate the RemoteViews object for the App Widget layout.\n        RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_layout);\n        // Set up the RemoteViews object to use a RemoteViews adapter.\n        // This adapter connects\n        // to a RemoteViewsService  through the specified intent.\n        // This is how you populate the data.\n        rv.setRemoteAdapter(appWidgetIds[i], R.id.stack_view, intent);       \n        // The empty view is displayed when the collection has no items.\n        // It should be in the same layout used to instantiate the RemoteViews\n        // object above.\n        rv.setEmptyView(R.id.stack_view, R.id.empty_view);\n        //\n        // Do additional processing specific to this app widget...\n        //     \n        appWidgetManager.updateAppWidget(appWidgetIds[i], rv);   \n    }\n    super.onUpdate(context, appWidgetManager, appWidgetIds);\n}\n```\n\n### RemoteViewsService类\n\nAs described above, your RemoteViewsService subclass provides the RemoteViewsFactory used to populate the remote collection view.\n\nSpecifically, you need to perform these steps:\n\n1. Subclass RemoteViewsService. RemoteViewsService is the service through which a remote adapter can request RemoteViews.\n2. In your RemoteViewsService subclass, include a class that implements the RemoteViewsFactory interface. RemoteViewsFactory is an interface for an adapter between a remote collection view (such as ListView, GridView, and so on) and the underlying data for that view. Your implementation is responsible for making a RemoteViews object for each item in the data set. This interface is a thin wrapper around Adapter.\n\nThe primary contents of the RemoteViewsService implementation is its RemoteViewsFactory, described below.\n\n### RemoteViewsFactory接口\n\nYour custom class that implements the RemoteViewsFactory interface provides the app widget with the data for the items in its collection. To do this, it combines your app widget item XML layout file with a source of data. This source of data could be anything from a database to a simple array. In the StackView Widget sample, the data source is an array of WidgetItems. The RemoteViewsFactory functions as an adapter to glue the data to the remote collection view.\n\nThe two most important methods you need to implement for your RemoteViewsFactory subclass are onCreate() and getViewAt() .\n\nThe system calls onCreate() when creating your factory for the first time. This is where you set up any connections and/or cursors to your data source. For example, the StackView Widget sample uses onCreate() to initialize an array of WidgetItem objects. When your app widget is active, the system accesses these objects using their index position in the array and the text they contain is displayed\n\nHere is an excerpt from the StackView Widget sample's RemoteViewsFactory implementation that shows portions of the onCreate() method:\n\n```\nclass StackRemoteViewsFactory implements\nRemoteViewsService.RemoteViewsFactory {\n    private static final int mCount = 10;\n    private List<WidgetItem> mWidgetItems = new ArrayList<WidgetItem>();\n    private Context mContext;\n    private int mAppWidgetId;\n    public StackRemoteViewsFactory(Context context, Intent intent) {\n        mContext = context;\n        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n    }\n    public void onCreate() {\n        // In onCreate() you setup any connections / cursors to your data source. Heavy lifting,\n        // for example downloading or creating content etc, should be deferred to onDataSetChanged()\n        // or getViewAt(). Taking more than 20 seconds in this call will result in an ANR.\n        for (int i = 0; i < mCount; i++) {\n            mWidgetItems.add(new WidgetItem(i + \"!\"));\n        }\n        ...\n    }\n...\n```\n\nThe RemoteViewsFactory method getViewAt() returns a RemoteViews object corresponding to the data at the specified position in the data set. Here is an excerpt from the StackView Widget sample's RemoteViewsFactory implementation:\n\n```\npublic RemoteViews getViewAt(int position) {\n    // Construct a remote views item based on the app widget item XML file,\n    // and set the text based on the position.\n    RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.widget_item);\n    rv.setTextViewText(R.id.widget_item, mWidgetItems.get(position).text);\n    ...\n    // Return the remote views object.\n    return rv;\n}\n```\n\n### 为个别Item添加行为\nThe above sections show you how to bind your data to your app widget collection. But what if you want to add dynamic behavior to the individual items in your collection view?\n\nAs described in Using the AppWidgetProvider Class, you normally use setOnClickPendingIntent() to set an object's click behavior—such as to cause a button to launch an Activity. But this approach is not allowed for child views in an individual collection item (to clarify, you could use setOnClickPendingIntent() to set up a global button in the Gmail app widget that launches the app, for example, but not on the individual list items). Instead, to add click behavior to individual items in a collection, you use setOnClickFillInIntent(). This entails setting up up a pending intent template for your collection view, and then setting a fill-in intent on each item in the collection via your RemoteViewsFactory.\n\nThis section uses the StackView Widget sample to describe how to add behavior to individual items. In the StackView Widget sample, if the user touches the top view, the app widget displays the Toast message \"Touched view n,\" where n is the index (position) of the touched view. This is how it works:\n\n- The StackWidgetProvider (an AppWidgetProvider subclass) creates a pending intent that has a custom action called TOAST_ACTION.\n- When the user touches a view, the intent is fired and it broadcasts TOAST_ACTION.\n- This broadcast is intercepted by the StackWidgetProvider's onReceive() method, and the app widget displays the Toast message for the touched view. The data for the collection items is provided by the RemoteViewsFactory, via the RemoteViewsService.\n\n>Note: The StackView Widget sample uses a broadcast, but typically an app widget would simply launch an activity in a scenario like this one.\n\n#### 设置待定意图模板(pending intent template)\nStackWidgetProvider（AppWidgetProvider子类）设置了一个待定意图.集合中具体的Item不能单独设置属于他们自己的待定意图。(注：性能原因) 取而代之的，集合作为一个整体设置一个待定意图模板，然后具体的Item设置填充意图(fill-in intent)来创建在item-by-item\nThe StackWidgetProvider (AppWidgetProvider subclass) sets up a pending intent. Individuals items of a collection cannot set up their own pending intents. Instead, the collection as a whole sets up a pending intent template, and the individual items set a fill-in intent to create unique behavior on an item-by-item basis.\n\nThis class also receives the broadcast that is sent when the user touches a view. It processes this event in its onReceive() method. If the intent's action is TOAST_ACTION, the app widget displays a Toast message for the current view.\n\n\n```\npublic class StackWidgetProvider extends AppWidgetProvider {\n    public static final String TOAST_ACTION = \"com.example.android.stackwidget.TOAST_ACTION\";\n    public static final String EXTRA_ITEM = \"com.example.android.stackwidget.EXTRA_ITEM\";\n    ...\n    // Called when the BroadcastReceiver receives an Intent broadcast.\n    // Checks to see whether the intent's action is TOAST_ACTION. If it is, the app widget\n    // displays a Toast message for the current item.\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n        if (intent.getAction().equals(TOAST_ACTION)) {\n            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n            int viewIndex = intent.getIntExtra(EXTRA_ITEM, 0);\n            Toast.makeText(context, \"Touched view \" + viewIndex, Toast.LENGTH_SHORT).show();\n        }\n        super.onReceive(context, intent);\n    }\n    @Override\n    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {\n        // update each of the app widgets with the remote adapter\n        for (int i = 0; i < appWidgetIds.length; ++i) {\n            // Sets up the intent that points to the StackViewService that will\n            // provide the views for this collection.\n            Intent intent = new Intent(context, StackWidgetService.class);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);\n            // When intents are compared, the extras are ignored, so we need to embed the extras\n            // into the data so that the extras will not be ignored.\n            intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));\n            RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_layout);\n            rv.setRemoteAdapter(appWidgetIds[i], R.id.stack_view, intent);\n            // The empty view is displayed when the collection has no items. It should be a sibling\n            // of the collection view.\n            rv.setEmptyView(R.id.stack_view, R.id.empty_view);\n            // This section makes it possible for items to have individualized behavior.\n            // It does this by setting up a pending intent template. Individuals items of a collection\n            // cannot set up their own pending intents. Instead, the collection as a whole sets\n            // up a pending intent template, and the individual items set a fillInIntent\n            // to create unique behavior on an item-by-item basis.\n            Intent toastIntent = new Intent(context, StackWidgetProvider.class);\n            // Set the action for the intent.\n            // When the user touches a particular view, it will have the effect of\n            // broadcasting TOAST_ACTION.\n            toastIntent.setAction(StackWidgetProvider.TOAST_ACTION);\n            toastIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);\n            intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));\n            PendingIntent toastPendingIntent = PendingIntent.getBroadcast(context, 0, toastIntent,\n                PendingIntent.FLAG_UPDATE_CURRENT);\n            rv.setPendingIntentTemplate(R.id.stack_view, toastPendingIntent);\n            appWidgetManager.updateAppWidget(appWidgetIds[i], rv);\n        }\n    super.onUpdate(context, appWidgetManager, appWidgetIds);\n    }\n}\n```\n\n#### 设置填充意图(fill-in intent)\n你的RemoteViewsFactory必须为每一个在集合中的item设置一个填充意图(fill-in intent)。这样才可能做到区分给定的Item单独的点击动作。填充意图然后与待定意图模板(PendingItent template)结合一起，确定了当item被点击时将执行的最终意图。\n\n```\npublic class StackWidgetService extends RemoteViewsService {\n    @Override\n    public RemoteViewsFactory onGetViewFactory(Intent intent) {\n        return new StackRemoteViewsFactory(this.getApplicationContext(), intent);\n    }\n}\nclass StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {\n    private static final int mCount = 10;\n    private List<WidgetItem> mWidgetItems = new ArrayList<WidgetItem>();\n    private Context mContext;\n    private int mAppWidgetId;\n    public StackRemoteViewsFactory(Context context, Intent intent) {\n        mContext = context;\n        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n    }\n    // 初始化数据\n        public void onCreate() {\n            // 在 onCreate()你可以建立任何连接/游标 到你的源数据中.Heavy lifting.\n            // 如下载或者创建内容等，应该延迟到onDataSetChanged()方法中\n            // 或者 getViewAt(), 在这个回调中耗时超过20秒，将会引起ANR.\n            for (int i = 0; i < mCount; i++) {\n                mWidgetItems.add(new WidgetItem(i + \"!\"));\n            }\n           ...\n        }\n        ...\n        // Given the position (index) of a WidgetItem in the array, use the item's text value in\n        // combination with the app widget item XML file to construct a RemoteViews object.\n        public RemoteViews getViewAt(int position) {\n            // position will always range from 0 to getCount() - 1.\n            // Construct a RemoteViews item based on the app widget item XML file, and set the\n            // text based on the position.\n            RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.widget_item);\n            rv.setTextViewText(R.id.widget_item, mWidgetItems.get(position).text);\n            // Next, set a fill-intent, which will be used to fill in the pending intent template\n            // that is set on the collection view in StackWidgetProvider.\n            Bundle extras = new Bundle();\n            extras.putInt(StackWidgetProvider.EXTRA_ITEM, position);\n            Intent fillInIntent = new Intent();\n            fillInIntent.putExtras(extras);\n            // Make it possible to distinguish the individual on-click\n            // action of a given item\n            rv.setOnClickFillInIntent(R.id.widget_item, fillInIntent);\n            ...\n            // Return the RemoteViews object.\n            return rv;\n        }\n    ...\n    }\n```\n\n## 保持集合数据最新\n\n下面的流程图发生在一个使用了集合的App Widget更新数据时。它展示了App Widget代码与RemoteViewsFactory的交互，以及你如何触发更新。\n\n![fresh data](http://developer.android.com/images/appwidgets/appwidget_collections.png)\n\n使用了集合的App Widgets的其中一个特性就是可以为用户提供最新的内容。例如，Android 3.0 Gmail app widget，可以为用户提供他们收件箱的一个快照。为了做到这一点，你需要能触发你的RemoteViewsFactory和集合view,去获得并且显示新数据。你可以通过使用AppWidgetManager调用notifyAppWidgetViewDataChanged()来实现这一点。然后在你的RemoteViewsFactory的OnDataChanged()获得一个回调结果，一个你有机会可以获取任何新数据的回调接口。注意，你可以在onDataSetChanged()回调方法中执行密集的同步操作(processing-intensive operations synchronously)。回调方法在元数据或者视图数据从RemoteViewsFactory那里获取之前以及被执行完成，所以你可以放心。此外，你也可以在getViewAt()方法内执行密集的同步操作。**如果这个回调函数执行了很长时间，那么加载视图(RemoteViewsFactory中指定的getLoadingView()方法)将被显示在集合视图中正确的位置，直到它返回结果.**\n","slug":"2013-05-15-app-widget","published":1,"updated":"2018-02-14T21:36:14.832Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlh000lrpfyfglz1auu","content":"<p>App Widgets是一种能嵌入到其他应用程序(如Home screen)的小型应用程序界面，并且能接收定时的更新。这些视图被称为用户界面中的窗口小部件，需要App Widget provider才能发布.能持有其他App Widgets的应用组件叫做App Widget host.下面显示了一张Music App Widget的图。</p>\n<p><img src=\"http://developer.android.com/images/appwidgets/appwidget.png\" alt=\"music app widget\"></p>\n<p>本文档将描述如何使用App Widget provider发布一个App Widget。</p>\n<blockquote>\n<p>####Widget Design<br>更多关于如何设计你的app widget,你可以阅读这篇 <a href=\"http://developer.android.com/design/patterns/widgets.html\" target=\"_blank\" rel=\"noopener\">窗口小部件设计指导</a>.</p>\n</blockquote>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"##基础\"></a>##基础</h2><p>创建一个App Widget ，你需要以下条件:</p>\n<ol>\n<li>AppWidgetProviderInfo 对象。用来描述App Widget的元数据，比如App Widget的布局，更新频率，AppWidgetProvider类。也可以使用xml定义。</li>\n<li>AppWidgetProvider 类实例。定义了一些基本方法，需要你去实现这些接口，是基于广播(broadcast)事件的。通过它，你可以接收到什么时候App Widget被更新了，可使用，不可使用和被删除了等状态。</li>\n<li>界面布局。定义了为App Widget初始化的布局，定义在XML中。</li>\n</ol>\n<p>此外，你可以实现一个App Widget配置Activity。这个可选的Activity的主要作用是，当用户在启动器(launches)中添加了你的App Widget时允许他在创建的时候就修改App Widget的设置。</p>\n<p>以下各节描述了如何设置每个组件</p>\n<h2 id=\"在Manifest中声明一个App-Widget\"><a href=\"#在Manifest中声明一个App-Widget\" class=\"headerlink\" title=\"##在Manifest中声明一个App Widget\"></a>##在Manifest中声明一个App Widget</h2><p>首先，在你应用程序的AndroidManifest.xml文件中声明AppWidgetProvider类，像这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver android:name=&quot;ExampleAppWidgetProvider&quot; &gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">    &lt;meta-data android:name=&quot;android.appwidget.provider&quot;</span><br><span class=\"line\">               android:resource=&quot;@xml/example_appwidget_info&quot; /&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>\n<p><code>&lt;receiver&gt;</code>元素需要android:name属性，用来指定App Widget所使用的AppWidgetProvider。</p>\n<p><code>&lt;intent-filter&gt;</code>元素必须包含一个带有android:name属性的<code>&lt;action&gt;</code>元素。这个属性指定了AppWidgetProvider接收<code>ACTION_APPWIDGET_UPDATE</code>广播。这是你必须要显示声明的广播。AppWidgetManager会自动发生其他所有的App Widget广播到AppWidgetProvider中，如果有必要的话。</p>\n<p><code>&lt;meta-data&gt;</code>元素指定了AppWidgetProviderInfo的来源并且要求有以下属性：</p>\n<ul>\n<li>android:name-指定元数据名称。使用<code>android.appwidget.provider</code>作为AppWidgetProviderInfo的描述来识别数据</li>\n<li>android:resource-指定AppWidgetProviderInfo的本地来源</li>\n</ul>\n<h2 id=\"添加AppWidgetProviderInfo-元数据\"><a href=\"#添加AppWidgetProviderInfo-元数据\" class=\"headerlink\" title=\"##添加AppWidgetProviderInfo 元数据\"></a>##添加AppWidgetProviderInfo 元数据</h2><p>AppWidgetProviderInfo定义了一个App Widget必要的特性（qualities），例如最小的布局尺寸，初始布局资源，多久更新一次App Widget，创建时调用的配置Activity。可以使用单个<code>&lt;appwidget-provider&gt;</code>元素的XML资源来定义AppWidgetProviderInfo对象，然后保持到项目的<code>res/xml/</code>文件夹下。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:minWidth=&quot;294dp&quot;</span><br><span class=\"line\">    android:minHeight=&quot;72dp&quot;</span><br><span class=\"line\">    android:updatePeriodMillis=&quot;86400000&quot;</span><br><span class=\"line\">    android:previewImage=&quot;@drawable/preview&quot;</span><br><span class=\"line\">    android:initialLayout=&quot;@layout/example_appwidget&quot;</span><br><span class=\"line\">    android:configure=&quot;com.example.android.ExampleAppWidgetConfigure&quot;</span><br><span class=\"line\">    android:resizeMode=&quot;horizontal|vertical&quot;</span><br><span class=\"line\">    android:widgetCategory=&quot;home_screen|keyguard&quot;</span><br><span class=\"line\">    android:initialKeyguardLayout=&quot;@layout/example_keyguard&quot;&gt;</span><br><span class=\"line\">&lt;/appwidget-provider&gt;</span><br></pre></td></tr></table></figure>\n<p>关于<code>&lt;appwidget-provider&gt;</code>属性的一些总结:</p>\n<ul>\n<li><code>miniWidth</code>和<code>minHeight</code></li>\n<li><code>minResizeWidth</code>和<code>minResizeHeight</code></li>\n<li><code>updatePeriodMillis</code></li>\n<li><code>initialLayout</code></li>\n<li><code>configure</code></li>\n<li><code>perviewImage</code></li>\n<li><code>autoAdvanceViewId</code></li>\n<li><code>resizeMode</code></li>\n<li><code>widgetCategory</code></li>\n<li><code>initialKeyguardLayout</code></li>\n</ul>\n<p>关于更多`<appwidget-provider>可以接收的属性的相关信息，可以查看<a href=\"http://developer.android.com/reference/android/appwidget/AppWidgetProviderInfo.html\" target=\"_blank\" rel=\"noopener\">AppWidgetProviderInfo</a>类。</appwidget-provider></p>\n<h2 id=\"创建App-Widget布局\"><a href=\"#创建App-Widget布局\" class=\"headerlink\" title=\"创建App Widget布局\"></a>创建App Widget布局</h2><hr>\n<p>你必须将你的App Widget初始化布局定义在XML中，并且将它保存在项目的<code>res/layout/</code>目录下。你可以使用下面列表列出的视图对象来设计你的App Widget,但是在你设计你的App Widget前，请先阅读并理解<a href=\"http://developer.android.com/guide/practices/ui_guidelines/widget_design.html\" target=\"_blank\" rel=\"noopener\">App Widget Design Guidelines</a>。</p>\n<p>创建一个App Widget布局是很简单的，如果你很了解<a href=\"http://developer.android.com/guide/topics/ui/declaring-layout.html\" target=\"_blank\" rel=\"noopener\">Layouts</a>的话。但是你应该意识到App Widget是基于<a href=\"http://developer.android.com/reference/android/widget/RemoteViews.html\" target=\"_blank\" rel=\"noopener\">RemoteViews</a>的，它不支持所有类型的布局和控件(view widget)。</p>\n<p>一个RemoteViews对象(consequently 一个App Widget)可以支持以下的布局类:</p>\n<ul>\n<li>FrameLayout</li>\n<li>LinearLayout</li>\n<li>RelativeLayout</li>\n<li>GridLayout</li>\n</ul>\n<p>和以下控件类:</p>\n<ul>\n<li>AnalogClock</li>\n<li>Button</li>\n<li>Chronometer</li>\n<li>ImageButton</li>\n<li>ImageView</li>\n<li>ProgressBar</li>\n<li>TextView</li>\n<li>ViewFlipper</li>\n<li>ListView</li>\n<li>GridView</li>\n<li>StackView</li>\n<li>AdapterViewFlipper</li>\n</ul>\n<p>这些类的派生类(Descendants)是不支持的。</p>\n<p>RemoteViews 也支持 ViewStub,一种不可见，不占大小的视图，你可以在运行时延迟<code>inflate</code>布局资源</p>\n<h3 id=\"为App-Widget添加margins\"><a href=\"#为App-Widget添加margins\" class=\"headerlink\" title=\"为App Widget添加margins\"></a>为App Widget添加margins</h3><h2 id=\"使用AppWidgetProvider类\"><a href=\"#使用AppWidgetProvider类\" class=\"headerlink\" title=\"使用AppWidgetProvider类\"></a>使用AppWidgetProvider类</h2><hr>\n<p>###接收App Widget广播意图 (broadcast intents)</p>\n<h2 id=\"创建一个App-Widget配置Activity\"><a href=\"#创建一个App-Widget配置Activity\" class=\"headerlink\" title=\"创建一个App Widget配置Activity\"></a>创建一个App Widget配置Activity</h2><hr>\n<p>###从配置Activity更新App Widget</p>\n<h2 id=\"设置预览图片\"><a href=\"#设置预览图片\" class=\"headerlink\" title=\"设置预览图片\"></a>设置预览图片</h2><hr>\n<h2 id=\"使App-Widget在锁屏上可用\"><a href=\"#使App-Widget在锁屏上可用\" class=\"headerlink\" title=\"##使App Widget在锁屏上可用\"></a>##使App Widget在锁屏上可用</h2><p>###改变大小指导</p>\n<h2 id=\"使用带有集合的App-Widget\"><a href=\"#使用带有集合的App-Widget\" class=\"headerlink\" title=\"##使用带有集合的App Widget\"></a>##使用带有集合的App Widget</h2><p>Android 3.0引进了带有集合的App Widget。这种App Widget使用RemoteViewService去显示那些支持远程数据的集合,例如从content provider。由RemoteViewsService提供的数据展示在App Widget中使用了以下视图类型中的一种,我们称之为”collections views”</p>\n<ul>\n<li>ListView:A view that shows items in a vertically scrolling list. For an example, see the Gmail app widget.</li>\n<li>GridView:A view that shows items in two-dimensional scrolling grid. For an example, see the Bookmarks app widget.</li>\n<li>StackView:A stacked card view (kind of like a rolodex), where the user can flick the front card up/down to see the previous/next card, respectively. Examples include the YouTube and Books app widgets.</li>\n<li>AdapterViewFlipper:An adapter-backed simple ViewAnimator that animates between two or more views. Only one child is shown at a time.</li>\n</ul>\n<p>正如上文所述,这些collections views显示支持远程数据的集合。这意味着他们使用Adpater将接口和数据<br>绑定一起。Adapter绑定将特殊items从一些集合的数据绑定到特殊的视图对象上。因为这些collection views被adapters支持，所以Android框架必须包含额外的体系结构去支持他们在app widget中使用。在app widget的上下文中，adapter被代替为RemoteViewsFactory,仅仅是简单的对Adapter接口进行了薄封装。当请求在集合中一个具体的item，RemoteViewsFactory会为集合创建并返回RemoteViews对象作为Item。为了能在你的app widget中使用collection view，你必须实现RemoteViewService和RemoteViewsFactory。</p>\n<p>RemoteViewsService是一种允许一个远程adapter请求RemoteViews对象的service。<br>RemoteViewsFactory是一种为collections view（如ListView,GridView等）和视图中潜在数据做适配的接口。下面这段模板代码,你可以用实现service和interface，从StackView Widget sample中提取出来的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StackWidgetService extends RemoteViewsService &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public RemoteViewsFactory onGetViewFactory(Intent intent) &#123;</span><br><span class=\"line\">        return new StackRemoteViewsFactory(this.getApplicationContext(), intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory &#123;</span><br><span class=\"line\">//... include adapter-like methods here. See the StackView Widget sample.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"例子应用\"><a href=\"#例子应用\" class=\"headerlink\" title=\"例子应用\"></a>例子应用</h3><p>本节的代码片段取材至StackView Widget sample:</p>\n<p><img src=\"http://developer.android.com/images/appwidgets/StackWidget.png\" alt=\"sample\"></p>\n<p>例子有十个栈视图组成，从”0!”显示到”9!”。这个例子app widget有以下主要行为：</p>\n<ul>\n<li>用户可以垂直方向甩动在app widget的顶部View，来显示上一个或者下一个view。这是内建在StackView的行为。</li>\n<li>Without any user interaction, the app widget automatically advances through its views in sequence, like a slide show. This is due to the setting android:autoAdvanceViewId=”@id/stack_view” in the res/xml/stackwidgetinfo.xml file. This setting applies to the view ID, which in this case is the view ID of the stack view.</li>\n<li>If the user touches the top view, the app widget displays the Toast message “Touched view n,” where n is the index (position) of the touched view. For more discussion of how this is implemented, see Adding behavior to individual items.</li>\n</ul>\n<h3 id=\"实现带有集合的App-Widget\"><a href=\"#实现带有集合的App-Widget\" class=\"headerlink\" title=\"实现带有集合的App Widget\"></a>实现带有集合的App Widget</h3><p>To implement an App Widget with collections, you follow the same basic steps you would use to implement any app widget. The following sections describe the additional steps you need to perform to implement an App Widget with collections.</p>\n<h3 id=\"带有集合的App-Widget的清单\"><a href=\"#带有集合的App-Widget的清单\" class=\"headerlink\" title=\"带有集合的App Widget的清单\"></a>带有集合的App Widget的清单</h3><p>In addition to the requirements listed in Declaring an App Widget in the Manifest, to make it possible for App Widgets with collections to bind to your RemoteViewsService, you must declare the service in your manifest file with the permission BIND_REMOTEVIEWS. This prevents other applications from freely accessing your app widget’s data. For example, when creating an App Widget that uses RemoteViewsService to populate a collection view, the manifest entry may look like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;service android:name=&quot;MyWidgetService&quot;</span><br><span class=\"line\">...</span><br><span class=\"line\">android:permission=&quot;android.permission.BIND_REMOTEVIEWS&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>The line <code>android:name=&quot;MyWidgetService&quot;</code> refers to your subclass of RemoteViewsService.</p>\n<h3 id=\"带有集合的App-Widget的布局\"><a href=\"#带有集合的App-Widget的布局\" class=\"headerlink\" title=\"带有集合的App Widget的布局\"></a>带有集合的App Widget的布局</h3><p>The main requirement for your app widget layout XML file is that it include one of the collection views: ListView, GridView, StackView, or AdapterViewFlipper. Here is the widget_layout.xml for the StackView Widget sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class=\"line\">    &lt;StackView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">        android:id=&quot;@+id/stack_view&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">        android:gravity=&quot;center&quot;</span><br><span class=\"line\">        android:loopViews=&quot;true&quot; /&gt;</span><br><span class=\"line\">    &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">        android:id=&quot;@+id/empty_view&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">        android:gravity=&quot;center&quot;</span><br><span class=\"line\">        android:background=&quot;@drawable/widget_item_background&quot;</span><br><span class=\"line\">        android:textColor=&quot;#ffffff&quot;</span><br><span class=\"line\">        android:textStyle=&quot;bold&quot;</span><br><span class=\"line\">        android:text=&quot;@string/empty_view_text&quot;</span><br><span class=\"line\">        android:textSize=&quot;20sp&quot; /&gt;</span><br><span class=\"line\">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>Note that empty views must be siblings of the collection view for which the empty view represents empty state.</p>\n<p>In addition to the layout file for your entire app widget, you must create another layout file that defines the layout for each item in the collection (for example, a layout for each book in a collection of books). For example, the StackView Widget sample only has one layout file, widget_item.xml, since all items use the same layout. But the WeatherListWidget sample has two layout files: dark_widget_item.xml and light_widget_item.xml.</p>\n<h3 id=\"带有集合的App-Widget的AppWidgetProvider\"><a href=\"#带有集合的App-Widget的AppWidgetProvider\" class=\"headerlink\" title=\"带有集合的App Widget的AppWidgetProvider\"></a>带有集合的App Widget的AppWidgetProvider</h3><p>As with a regular app widget, the bulk of your code in your AppWidgetProvider subclass typically goes in onUpdate(). The major difference in your implementation for onUpdate() when creating an app widget with collections is that you must call setRemoteAdapter(). This tells the collection view where to get its data. The RemoteViewsService can then return your implementation of RemoteViewsFactory, and the widget can serve up the appropriate data. When you call this method, you must pass an intent that points to your implementation of RemoteViewsService and the App Widget ID that specifies the app widget to update.</p>\n<p>For example, here’s how the StackView Widget sample implements the onUpdate() callback method to set the RemoteViewsService as the remote adapter for the app widget collection:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onUpdate(Context context, AppWidgetManager appWidgetManager,</span><br><span class=\"line\">int[] appWidgetIds) &#123;</span><br><span class=\"line\">    // update each of the app widgets with the remote adapter</span><br><span class=\"line\">    for (int i = 0; i &lt; appWidgetIds.length; ++i) &#123;     </span><br><span class=\"line\">        // Set up the intent that starts the StackViewService, which will</span><br><span class=\"line\">        // provide the views for this collection.</span><br><span class=\"line\">        Intent intent = new Intent(context, StackWidgetService.class);</span><br><span class=\"line\">        // Add the app widget ID to the intent extras.</span><br><span class=\"line\">        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);</span><br><span class=\"line\">        intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));</span><br><span class=\"line\">        // Instantiate the RemoteViews object for the App Widget layout.</span><br><span class=\"line\">        RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_layout);</span><br><span class=\"line\">        // Set up the RemoteViews object to use a RemoteViews adapter.</span><br><span class=\"line\">        // This adapter connects</span><br><span class=\"line\">        // to a RemoteViewsService  through the specified intent.</span><br><span class=\"line\">        // This is how you populate the data.</span><br><span class=\"line\">        rv.setRemoteAdapter(appWidgetIds[i], R.id.stack_view, intent);       </span><br><span class=\"line\">        // The empty view is displayed when the collection has no items.</span><br><span class=\"line\">        // It should be in the same layout used to instantiate the RemoteViews</span><br><span class=\"line\">        // object above.</span><br><span class=\"line\">        rv.setEmptyView(R.id.stack_view, R.id.empty_view);</span><br><span class=\"line\">        //</span><br><span class=\"line\">        // Do additional processing specific to this app widget...</span><br><span class=\"line\">        //     </span><br><span class=\"line\">        appWidgetManager.updateAppWidget(appWidgetIds[i], rv);   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    super.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RemoteViewsService类\"><a href=\"#RemoteViewsService类\" class=\"headerlink\" title=\"RemoteViewsService类\"></a>RemoteViewsService类</h3><p>As described above, your RemoteViewsService subclass provides the RemoteViewsFactory used to populate the remote collection view.</p>\n<p>Specifically, you need to perform these steps:</p>\n<ol>\n<li>Subclass RemoteViewsService. RemoteViewsService is the service through which a remote adapter can request RemoteViews.</li>\n<li>In your RemoteViewsService subclass, include a class that implements the RemoteViewsFactory interface. RemoteViewsFactory is an interface for an adapter between a remote collection view (such as ListView, GridView, and so on) and the underlying data for that view. Your implementation is responsible for making a RemoteViews object for each item in the data set. This interface is a thin wrapper around Adapter.</li>\n</ol>\n<p>The primary contents of the RemoteViewsService implementation is its RemoteViewsFactory, described below.</p>\n<h3 id=\"RemoteViewsFactory接口\"><a href=\"#RemoteViewsFactory接口\" class=\"headerlink\" title=\"RemoteViewsFactory接口\"></a>RemoteViewsFactory接口</h3><p>Your custom class that implements the RemoteViewsFactory interface provides the app widget with the data for the items in its collection. To do this, it combines your app widget item XML layout file with a source of data. This source of data could be anything from a database to a simple array. In the StackView Widget sample, the data source is an array of WidgetItems. The RemoteViewsFactory functions as an adapter to glue the data to the remote collection view.</p>\n<p>The two most important methods you need to implement for your RemoteViewsFactory subclass are onCreate() and getViewAt() .</p>\n<p>The system calls onCreate() when creating your factory for the first time. This is where you set up any connections and/or cursors to your data source. For example, the StackView Widget sample uses onCreate() to initialize an array of WidgetItem objects. When your app widget is active, the system accesses these objects using their index position in the array and the text they contain is displayed</p>\n<p>Here is an excerpt from the StackView Widget sample’s RemoteViewsFactory implementation that shows portions of the onCreate() method:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StackRemoteViewsFactory implements</span><br><span class=\"line\">RemoteViewsService.RemoteViewsFactory &#123;</span><br><span class=\"line\">    private static final int mCount = 10;</span><br><span class=\"line\">    private List&lt;WidgetItem&gt; mWidgetItems = new ArrayList&lt;WidgetItem&gt;();</span><br><span class=\"line\">    private Context mContext;</span><br><span class=\"line\">    private int mAppWidgetId;</span><br><span class=\"line\">    public StackRemoteViewsFactory(Context context, Intent intent) &#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,</span><br><span class=\"line\">                AppWidgetManager.INVALID_APPWIDGET_ID);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void onCreate() &#123;</span><br><span class=\"line\">        // In onCreate() you setup any connections / cursors to your data source. Heavy lifting,</span><br><span class=\"line\">        // for example downloading or creating content etc, should be deferred to onDataSetChanged()</span><br><span class=\"line\">        // or getViewAt(). Taking more than 20 seconds in this call will result in an ANR.</span><br><span class=\"line\">        for (int i = 0; i &lt; mCount; i++) &#123;</span><br><span class=\"line\">            mWidgetItems.add(new WidgetItem(i + &quot;!&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>The RemoteViewsFactory method getViewAt() returns a RemoteViews object corresponding to the data at the specified position in the data set. Here is an excerpt from the StackView Widget sample’s RemoteViewsFactory implementation:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public RemoteViews getViewAt(int position) &#123;</span><br><span class=\"line\">    // Construct a remote views item based on the app widget item XML file,</span><br><span class=\"line\">    // and set the text based on the position.</span><br><span class=\"line\">    RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.widget_item);</span><br><span class=\"line\">    rv.setTextViewText(R.id.widget_item, mWidgetItems.get(position).text);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // Return the remote views object.</span><br><span class=\"line\">    return rv;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为个别Item添加行为\"><a href=\"#为个别Item添加行为\" class=\"headerlink\" title=\"为个别Item添加行为\"></a>为个别Item添加行为</h3><p>The above sections show you how to bind your data to your app widget collection. But what if you want to add dynamic behavior to the individual items in your collection view?</p>\n<p>As described in Using the AppWidgetProvider Class, you normally use setOnClickPendingIntent() to set an object’s click behavior—such as to cause a button to launch an Activity. But this approach is not allowed for child views in an individual collection item (to clarify, you could use setOnClickPendingIntent() to set up a global button in the Gmail app widget that launches the app, for example, but not on the individual list items). Instead, to add click behavior to individual items in a collection, you use setOnClickFillInIntent(). This entails setting up up a pending intent template for your collection view, and then setting a fill-in intent on each item in the collection via your RemoteViewsFactory.</p>\n<p>This section uses the StackView Widget sample to describe how to add behavior to individual items. In the StackView Widget sample, if the user touches the top view, the app widget displays the Toast message “Touched view n,” where n is the index (position) of the touched view. This is how it works:</p>\n<ul>\n<li>The StackWidgetProvider (an AppWidgetProvider subclass) creates a pending intent that has a custom action called TOAST_ACTION.</li>\n<li>When the user touches a view, the intent is fired and it broadcasts TOAST_ACTION.</li>\n<li>This broadcast is intercepted by the StackWidgetProvider’s onReceive() method, and the app widget displays the Toast message for the touched view. The data for the collection items is provided by the RemoteViewsFactory, via the RemoteViewsService.</li>\n</ul>\n<blockquote>\n<p>Note: The StackView Widget sample uses a broadcast, but typically an app widget would simply launch an activity in a scenario like this one.</p>\n</blockquote>\n<h4 id=\"设置待定意图模板-pending-intent-template\"><a href=\"#设置待定意图模板-pending-intent-template\" class=\"headerlink\" title=\"设置待定意图模板(pending intent template)\"></a>设置待定意图模板(pending intent template)</h4><p>StackWidgetProvider（AppWidgetProvider子类）设置了一个待定意图.集合中具体的Item不能单独设置属于他们自己的待定意图。(注：性能原因) 取而代之的，集合作为一个整体设置一个待定意图模板，然后具体的Item设置填充意图(fill-in intent)来创建在item-by-item<br>The StackWidgetProvider (AppWidgetProvider subclass) sets up a pending intent. Individuals items of a collection cannot set up their own pending intents. Instead, the collection as a whole sets up a pending intent template, and the individual items set a fill-in intent to create unique behavior on an item-by-item basis.</p>\n<p>This class also receives the broadcast that is sent when the user touches a view. It processes this event in its onReceive() method. If the intent’s action is TOAST_ACTION, the app widget displays a Toast message for the current view.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StackWidgetProvider extends AppWidgetProvider &#123;</span><br><span class=\"line\">    public static final String TOAST_ACTION = &quot;com.example.android.stackwidget.TOAST_ACTION&quot;;</span><br><span class=\"line\">    public static final String EXTRA_ITEM = &quot;com.example.android.stackwidget.EXTRA_ITEM&quot;;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // Called when the BroadcastReceiver receives an Intent broadcast.</span><br><span class=\"line\">    // Checks to see whether the intent&apos;s action is TOAST_ACTION. If it is, the app widget</span><br><span class=\"line\">    // displays a Toast message for the current item.</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class=\"line\">        AppWidgetManager mgr = AppWidgetManager.getInstance(context);</span><br><span class=\"line\">        if (intent.getAction().equals(TOAST_ACTION)) &#123;</span><br><span class=\"line\">            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,</span><br><span class=\"line\">                AppWidgetManager.INVALID_APPWIDGET_ID);</span><br><span class=\"line\">            int viewIndex = intent.getIntExtra(EXTRA_ITEM, 0);</span><br><span class=\"line\">            Toast.makeText(context, &quot;Touched view &quot; + viewIndex, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        super.onReceive(context, intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123;</span><br><span class=\"line\">        // update each of the app widgets with the remote adapter</span><br><span class=\"line\">        for (int i = 0; i &lt; appWidgetIds.length; ++i) &#123;</span><br><span class=\"line\">            // Sets up the intent that points to the StackViewService that will</span><br><span class=\"line\">            // provide the views for this collection.</span><br><span class=\"line\">            Intent intent = new Intent(context, StackWidgetService.class);</span><br><span class=\"line\">            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);</span><br><span class=\"line\">            // When intents are compared, the extras are ignored, so we need to embed the extras</span><br><span class=\"line\">            // into the data so that the extras will not be ignored.</span><br><span class=\"line\">            intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));</span><br><span class=\"line\">            RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_layout);</span><br><span class=\"line\">            rv.setRemoteAdapter(appWidgetIds[i], R.id.stack_view, intent);</span><br><span class=\"line\">            // The empty view is displayed when the collection has no items. It should be a sibling</span><br><span class=\"line\">            // of the collection view.</span><br><span class=\"line\">            rv.setEmptyView(R.id.stack_view, R.id.empty_view);</span><br><span class=\"line\">            // This section makes it possible for items to have individualized behavior.</span><br><span class=\"line\">            // It does this by setting up a pending intent template. Individuals items of a collection</span><br><span class=\"line\">            // cannot set up their own pending intents. Instead, the collection as a whole sets</span><br><span class=\"line\">            // up a pending intent template, and the individual items set a fillInIntent</span><br><span class=\"line\">            // to create unique behavior on an item-by-item basis.</span><br><span class=\"line\">            Intent toastIntent = new Intent(context, StackWidgetProvider.class);</span><br><span class=\"line\">            // Set the action for the intent.</span><br><span class=\"line\">            // When the user touches a particular view, it will have the effect of</span><br><span class=\"line\">            // broadcasting TOAST_ACTION.</span><br><span class=\"line\">            toastIntent.setAction(StackWidgetProvider.TOAST_ACTION);</span><br><span class=\"line\">            toastIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);</span><br><span class=\"line\">            intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));</span><br><span class=\"line\">            PendingIntent toastPendingIntent = PendingIntent.getBroadcast(context, 0, toastIntent,</span><br><span class=\"line\">                PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class=\"line\">            rv.setPendingIntentTemplate(R.id.stack_view, toastPendingIntent);</span><br><span class=\"line\">            appWidgetManager.updateAppWidget(appWidgetIds[i], rv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    super.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"设置填充意图-fill-in-intent\"><a href=\"#设置填充意图-fill-in-intent\" class=\"headerlink\" title=\"设置填充意图(fill-in intent)\"></a>设置填充意图(fill-in intent)</h4><p>你的RemoteViewsFactory必须为每一个在集合中的item设置一个填充意图(fill-in intent)。这样才可能做到区分给定的Item单独的点击动作。填充意图然后与待定意图模板(PendingItent template)结合一起，确定了当item被点击时将执行的最终意图。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StackWidgetService extends RemoteViewsService &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public RemoteViewsFactory onGetViewFactory(Intent intent) &#123;</span><br><span class=\"line\">        return new StackRemoteViewsFactory(this.getApplicationContext(), intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory &#123;</span><br><span class=\"line\">    private static final int mCount = 10;</span><br><span class=\"line\">    private List&lt;WidgetItem&gt; mWidgetItems = new ArrayList&lt;WidgetItem&gt;();</span><br><span class=\"line\">    private Context mContext;</span><br><span class=\"line\">    private int mAppWidgetId;</span><br><span class=\"line\">    public StackRemoteViewsFactory(Context context, Intent intent) &#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,</span><br><span class=\"line\">                AppWidgetManager.INVALID_APPWIDGET_ID);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 初始化数据</span><br><span class=\"line\">        public void onCreate() &#123;</span><br><span class=\"line\">            // 在 onCreate()你可以建立任何连接/游标 到你的源数据中.Heavy lifting.</span><br><span class=\"line\">            // 如下载或者创建内容等，应该延迟到onDataSetChanged()方法中</span><br><span class=\"line\">            // 或者 getViewAt(), 在这个回调中耗时超过20秒，将会引起ANR.</span><br><span class=\"line\">            for (int i = 0; i &lt; mCount; i++) &#123;</span><br><span class=\"line\">                mWidgetItems.add(new WidgetItem(i + &quot;!&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        // Given the position (index) of a WidgetItem in the array, use the item&apos;s text value in</span><br><span class=\"line\">        // combination with the app widget item XML file to construct a RemoteViews object.</span><br><span class=\"line\">        public RemoteViews getViewAt(int position) &#123;</span><br><span class=\"line\">            // position will always range from 0 to getCount() - 1.</span><br><span class=\"line\">            // Construct a RemoteViews item based on the app widget item XML file, and set the</span><br><span class=\"line\">            // text based on the position.</span><br><span class=\"line\">            RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.widget_item);</span><br><span class=\"line\">            rv.setTextViewText(R.id.widget_item, mWidgetItems.get(position).text);</span><br><span class=\"line\">            // Next, set a fill-intent, which will be used to fill in the pending intent template</span><br><span class=\"line\">            // that is set on the collection view in StackWidgetProvider.</span><br><span class=\"line\">            Bundle extras = new Bundle();</span><br><span class=\"line\">            extras.putInt(StackWidgetProvider.EXTRA_ITEM, position);</span><br><span class=\"line\">            Intent fillInIntent = new Intent();</span><br><span class=\"line\">            fillInIntent.putExtras(extras);</span><br><span class=\"line\">            // Make it possible to distinguish the individual on-click</span><br><span class=\"line\">            // action of a given item</span><br><span class=\"line\">            rv.setOnClickFillInIntent(R.id.widget_item, fillInIntent);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            // Return the RemoteViews object.</span><br><span class=\"line\">            return rv;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"保持集合数据最新\"><a href=\"#保持集合数据最新\" class=\"headerlink\" title=\"保持集合数据最新\"></a>保持集合数据最新</h2><p>下面的流程图发生在一个使用了集合的App Widget更新数据时。它展示了App Widget代码与RemoteViewsFactory的交互，以及你如何触发更新。</p>\n<p><img src=\"http://developer.android.com/images/appwidgets/appwidget_collections.png\" alt=\"fresh data\"></p>\n<p>使用了集合的App Widgets的其中一个特性就是可以为用户提供最新的内容。例如，Android 3.0 Gmail app widget，可以为用户提供他们收件箱的一个快照。为了做到这一点，你需要能触发你的RemoteViewsFactory和集合view,去获得并且显示新数据。你可以通过使用AppWidgetManager调用notifyAppWidgetViewDataChanged()来实现这一点。然后在你的RemoteViewsFactory的OnDataChanged()获得一个回调结果，一个你有机会可以获取任何新数据的回调接口。注意，你可以在onDataSetChanged()回调方法中执行密集的同步操作(processing-intensive operations synchronously)。回调方法在元数据或者视图数据从RemoteViewsFactory那里获取之前以及被执行完成，所以你可以放心。此外，你也可以在getViewAt()方法内执行密集的同步操作。<strong>如果这个回调函数执行了很长时间，那么加载视图(RemoteViewsFactory中指定的getLoadingView()方法)将被显示在集合视图中正确的位置，直到它返回结果.</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>App Widgets是一种能嵌入到其他应用程序(如Home screen)的小型应用程序界面，并且能接收定时的更新。这些视图被称为用户界面中的窗口小部件，需要App Widget provider才能发布.能持有其他App Widgets的应用组件叫做App Widget host.下面显示了一张Music App Widget的图。</p>\n<p><img src=\"http://developer.android.com/images/appwidgets/appwidget.png\" alt=\"music app widget\"></p>\n<p>本文档将描述如何使用App Widget provider发布一个App Widget。</p>\n<blockquote>\n<p>####Widget Design<br>更多关于如何设计你的app widget,你可以阅读这篇 <a href=\"http://developer.android.com/design/patterns/widgets.html\" target=\"_blank\" rel=\"noopener\">窗口小部件设计指导</a>.</p>\n</blockquote>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"##基础\"></a>##基础</h2><p>创建一个App Widget ，你需要以下条件:</p>\n<ol>\n<li>AppWidgetProviderInfo 对象。用来描述App Widget的元数据，比如App Widget的布局，更新频率，AppWidgetProvider类。也可以使用xml定义。</li>\n<li>AppWidgetProvider 类实例。定义了一些基本方法，需要你去实现这些接口，是基于广播(broadcast)事件的。通过它，你可以接收到什么时候App Widget被更新了，可使用，不可使用和被删除了等状态。</li>\n<li>界面布局。定义了为App Widget初始化的布局，定义在XML中。</li>\n</ol>\n<p>此外，你可以实现一个App Widget配置Activity。这个可选的Activity的主要作用是，当用户在启动器(launches)中添加了你的App Widget时允许他在创建的时候就修改App Widget的设置。</p>\n<p>以下各节描述了如何设置每个组件</p>\n<h2 id=\"在Manifest中声明一个App-Widget\"><a href=\"#在Manifest中声明一个App-Widget\" class=\"headerlink\" title=\"##在Manifest中声明一个App Widget\"></a>##在Manifest中声明一个App Widget</h2><p>首先，在你应用程序的AndroidManifest.xml文件中声明AppWidgetProvider类，像这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver android:name=&quot;ExampleAppWidgetProvider&quot; &gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">    &lt;meta-data android:name=&quot;android.appwidget.provider&quot;</span><br><span class=\"line\">               android:resource=&quot;@xml/example_appwidget_info&quot; /&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>\n<p><code>&lt;receiver&gt;</code>元素需要android:name属性，用来指定App Widget所使用的AppWidgetProvider。</p>\n<p><code>&lt;intent-filter&gt;</code>元素必须包含一个带有android:name属性的<code>&lt;action&gt;</code>元素。这个属性指定了AppWidgetProvider接收<code>ACTION_APPWIDGET_UPDATE</code>广播。这是你必须要显示声明的广播。AppWidgetManager会自动发生其他所有的App Widget广播到AppWidgetProvider中，如果有必要的话。</p>\n<p><code>&lt;meta-data&gt;</code>元素指定了AppWidgetProviderInfo的来源并且要求有以下属性：</p>\n<ul>\n<li>android:name-指定元数据名称。使用<code>android.appwidget.provider</code>作为AppWidgetProviderInfo的描述来识别数据</li>\n<li>android:resource-指定AppWidgetProviderInfo的本地来源</li>\n</ul>\n<h2 id=\"添加AppWidgetProviderInfo-元数据\"><a href=\"#添加AppWidgetProviderInfo-元数据\" class=\"headerlink\" title=\"##添加AppWidgetProviderInfo 元数据\"></a>##添加AppWidgetProviderInfo 元数据</h2><p>AppWidgetProviderInfo定义了一个App Widget必要的特性（qualities），例如最小的布局尺寸，初始布局资源，多久更新一次App Widget，创建时调用的配置Activity。可以使用单个<code>&lt;appwidget-provider&gt;</code>元素的XML资源来定义AppWidgetProviderInfo对象，然后保持到项目的<code>res/xml/</code>文件夹下。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:minWidth=&quot;294dp&quot;</span><br><span class=\"line\">    android:minHeight=&quot;72dp&quot;</span><br><span class=\"line\">    android:updatePeriodMillis=&quot;86400000&quot;</span><br><span class=\"line\">    android:previewImage=&quot;@drawable/preview&quot;</span><br><span class=\"line\">    android:initialLayout=&quot;@layout/example_appwidget&quot;</span><br><span class=\"line\">    android:configure=&quot;com.example.android.ExampleAppWidgetConfigure&quot;</span><br><span class=\"line\">    android:resizeMode=&quot;horizontal|vertical&quot;</span><br><span class=\"line\">    android:widgetCategory=&quot;home_screen|keyguard&quot;</span><br><span class=\"line\">    android:initialKeyguardLayout=&quot;@layout/example_keyguard&quot;&gt;</span><br><span class=\"line\">&lt;/appwidget-provider&gt;</span><br></pre></td></tr></table></figure>\n<p>关于<code>&lt;appwidget-provider&gt;</code>属性的一些总结:</p>\n<ul>\n<li><code>miniWidth</code>和<code>minHeight</code></li>\n<li><code>minResizeWidth</code>和<code>minResizeHeight</code></li>\n<li><code>updatePeriodMillis</code></li>\n<li><code>initialLayout</code></li>\n<li><code>configure</code></li>\n<li><code>perviewImage</code></li>\n<li><code>autoAdvanceViewId</code></li>\n<li><code>resizeMode</code></li>\n<li><code>widgetCategory</code></li>\n<li><code>initialKeyguardLayout</code></li>\n</ul>\n<p>关于更多`<appwidget-provider>可以接收的属性的相关信息，可以查看<a href=\"http://developer.android.com/reference/android/appwidget/AppWidgetProviderInfo.html\" target=\"_blank\" rel=\"noopener\">AppWidgetProviderInfo</a>类。</appwidget-provider></p>\n<h2 id=\"创建App-Widget布局\"><a href=\"#创建App-Widget布局\" class=\"headerlink\" title=\"创建App Widget布局\"></a>创建App Widget布局</h2><hr>\n<p>你必须将你的App Widget初始化布局定义在XML中，并且将它保存在项目的<code>res/layout/</code>目录下。你可以使用下面列表列出的视图对象来设计你的App Widget,但是在你设计你的App Widget前，请先阅读并理解<a href=\"http://developer.android.com/guide/practices/ui_guidelines/widget_design.html\" target=\"_blank\" rel=\"noopener\">App Widget Design Guidelines</a>。</p>\n<p>创建一个App Widget布局是很简单的，如果你很了解<a href=\"http://developer.android.com/guide/topics/ui/declaring-layout.html\" target=\"_blank\" rel=\"noopener\">Layouts</a>的话。但是你应该意识到App Widget是基于<a href=\"http://developer.android.com/reference/android/widget/RemoteViews.html\" target=\"_blank\" rel=\"noopener\">RemoteViews</a>的，它不支持所有类型的布局和控件(view widget)。</p>\n<p>一个RemoteViews对象(consequently 一个App Widget)可以支持以下的布局类:</p>\n<ul>\n<li>FrameLayout</li>\n<li>LinearLayout</li>\n<li>RelativeLayout</li>\n<li>GridLayout</li>\n</ul>\n<p>和以下控件类:</p>\n<ul>\n<li>AnalogClock</li>\n<li>Button</li>\n<li>Chronometer</li>\n<li>ImageButton</li>\n<li>ImageView</li>\n<li>ProgressBar</li>\n<li>TextView</li>\n<li>ViewFlipper</li>\n<li>ListView</li>\n<li>GridView</li>\n<li>StackView</li>\n<li>AdapterViewFlipper</li>\n</ul>\n<p>这些类的派生类(Descendants)是不支持的。</p>\n<p>RemoteViews 也支持 ViewStub,一种不可见，不占大小的视图，你可以在运行时延迟<code>inflate</code>布局资源</p>\n<h3 id=\"为App-Widget添加margins\"><a href=\"#为App-Widget添加margins\" class=\"headerlink\" title=\"为App Widget添加margins\"></a>为App Widget添加margins</h3><h2 id=\"使用AppWidgetProvider类\"><a href=\"#使用AppWidgetProvider类\" class=\"headerlink\" title=\"使用AppWidgetProvider类\"></a>使用AppWidgetProvider类</h2><hr>\n<p>###接收App Widget广播意图 (broadcast intents)</p>\n<h2 id=\"创建一个App-Widget配置Activity\"><a href=\"#创建一个App-Widget配置Activity\" class=\"headerlink\" title=\"创建一个App Widget配置Activity\"></a>创建一个App Widget配置Activity</h2><hr>\n<p>###从配置Activity更新App Widget</p>\n<h2 id=\"设置预览图片\"><a href=\"#设置预览图片\" class=\"headerlink\" title=\"设置预览图片\"></a>设置预览图片</h2><hr>\n<h2 id=\"使App-Widget在锁屏上可用\"><a href=\"#使App-Widget在锁屏上可用\" class=\"headerlink\" title=\"##使App Widget在锁屏上可用\"></a>##使App Widget在锁屏上可用</h2><p>###改变大小指导</p>\n<h2 id=\"使用带有集合的App-Widget\"><a href=\"#使用带有集合的App-Widget\" class=\"headerlink\" title=\"##使用带有集合的App Widget\"></a>##使用带有集合的App Widget</h2><p>Android 3.0引进了带有集合的App Widget。这种App Widget使用RemoteViewService去显示那些支持远程数据的集合,例如从content provider。由RemoteViewsService提供的数据展示在App Widget中使用了以下视图类型中的一种,我们称之为”collections views”</p>\n<ul>\n<li>ListView:A view that shows items in a vertically scrolling list. For an example, see the Gmail app widget.</li>\n<li>GridView:A view that shows items in two-dimensional scrolling grid. For an example, see the Bookmarks app widget.</li>\n<li>StackView:A stacked card view (kind of like a rolodex), where the user can flick the front card up/down to see the previous/next card, respectively. Examples include the YouTube and Books app widgets.</li>\n<li>AdapterViewFlipper:An adapter-backed simple ViewAnimator that animates between two or more views. Only one child is shown at a time.</li>\n</ul>\n<p>正如上文所述,这些collections views显示支持远程数据的集合。这意味着他们使用Adpater将接口和数据<br>绑定一起。Adapter绑定将特殊items从一些集合的数据绑定到特殊的视图对象上。因为这些collection views被adapters支持，所以Android框架必须包含额外的体系结构去支持他们在app widget中使用。在app widget的上下文中，adapter被代替为RemoteViewsFactory,仅仅是简单的对Adapter接口进行了薄封装。当请求在集合中一个具体的item，RemoteViewsFactory会为集合创建并返回RemoteViews对象作为Item。为了能在你的app widget中使用collection view，你必须实现RemoteViewService和RemoteViewsFactory。</p>\n<p>RemoteViewsService是一种允许一个远程adapter请求RemoteViews对象的service。<br>RemoteViewsFactory是一种为collections view（如ListView,GridView等）和视图中潜在数据做适配的接口。下面这段模板代码,你可以用实现service和interface，从StackView Widget sample中提取出来的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StackWidgetService extends RemoteViewsService &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public RemoteViewsFactory onGetViewFactory(Intent intent) &#123;</span><br><span class=\"line\">        return new StackRemoteViewsFactory(this.getApplicationContext(), intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory &#123;</span><br><span class=\"line\">//... include adapter-like methods here. See the StackView Widget sample.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"例子应用\"><a href=\"#例子应用\" class=\"headerlink\" title=\"例子应用\"></a>例子应用</h3><p>本节的代码片段取材至StackView Widget sample:</p>\n<p><img src=\"http://developer.android.com/images/appwidgets/StackWidget.png\" alt=\"sample\"></p>\n<p>例子有十个栈视图组成，从”0!”显示到”9!”。这个例子app widget有以下主要行为：</p>\n<ul>\n<li>用户可以垂直方向甩动在app widget的顶部View，来显示上一个或者下一个view。这是内建在StackView的行为。</li>\n<li>Without any user interaction, the app widget automatically advances through its views in sequence, like a slide show. This is due to the setting android:autoAdvanceViewId=”@id/stack_view” in the res/xml/stackwidgetinfo.xml file. This setting applies to the view ID, which in this case is the view ID of the stack view.</li>\n<li>If the user touches the top view, the app widget displays the Toast message “Touched view n,” where n is the index (position) of the touched view. For more discussion of how this is implemented, see Adding behavior to individual items.</li>\n</ul>\n<h3 id=\"实现带有集合的App-Widget\"><a href=\"#实现带有集合的App-Widget\" class=\"headerlink\" title=\"实现带有集合的App Widget\"></a>实现带有集合的App Widget</h3><p>To implement an App Widget with collections, you follow the same basic steps you would use to implement any app widget. The following sections describe the additional steps you need to perform to implement an App Widget with collections.</p>\n<h3 id=\"带有集合的App-Widget的清单\"><a href=\"#带有集合的App-Widget的清单\" class=\"headerlink\" title=\"带有集合的App Widget的清单\"></a>带有集合的App Widget的清单</h3><p>In addition to the requirements listed in Declaring an App Widget in the Manifest, to make it possible for App Widgets with collections to bind to your RemoteViewsService, you must declare the service in your manifest file with the permission BIND_REMOTEVIEWS. This prevents other applications from freely accessing your app widget’s data. For example, when creating an App Widget that uses RemoteViewsService to populate a collection view, the manifest entry may look like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;service android:name=&quot;MyWidgetService&quot;</span><br><span class=\"line\">...</span><br><span class=\"line\">android:permission=&quot;android.permission.BIND_REMOTEVIEWS&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>The line <code>android:name=&quot;MyWidgetService&quot;</code> refers to your subclass of RemoteViewsService.</p>\n<h3 id=\"带有集合的App-Widget的布局\"><a href=\"#带有集合的App-Widget的布局\" class=\"headerlink\" title=\"带有集合的App Widget的布局\"></a>带有集合的App Widget的布局</h3><p>The main requirement for your app widget layout XML file is that it include one of the collection views: ListView, GridView, StackView, or AdapterViewFlipper. Here is the widget_layout.xml for the StackView Widget sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class=\"line\">    &lt;StackView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">        android:id=&quot;@+id/stack_view&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">        android:gravity=&quot;center&quot;</span><br><span class=\"line\">        android:loopViews=&quot;true&quot; /&gt;</span><br><span class=\"line\">    &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">        android:id=&quot;@+id/empty_view&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">        android:gravity=&quot;center&quot;</span><br><span class=\"line\">        android:background=&quot;@drawable/widget_item_background&quot;</span><br><span class=\"line\">        android:textColor=&quot;#ffffff&quot;</span><br><span class=\"line\">        android:textStyle=&quot;bold&quot;</span><br><span class=\"line\">        android:text=&quot;@string/empty_view_text&quot;</span><br><span class=\"line\">        android:textSize=&quot;20sp&quot; /&gt;</span><br><span class=\"line\">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>Note that empty views must be siblings of the collection view for which the empty view represents empty state.</p>\n<p>In addition to the layout file for your entire app widget, you must create another layout file that defines the layout for each item in the collection (for example, a layout for each book in a collection of books). For example, the StackView Widget sample only has one layout file, widget_item.xml, since all items use the same layout. But the WeatherListWidget sample has two layout files: dark_widget_item.xml and light_widget_item.xml.</p>\n<h3 id=\"带有集合的App-Widget的AppWidgetProvider\"><a href=\"#带有集合的App-Widget的AppWidgetProvider\" class=\"headerlink\" title=\"带有集合的App Widget的AppWidgetProvider\"></a>带有集合的App Widget的AppWidgetProvider</h3><p>As with a regular app widget, the bulk of your code in your AppWidgetProvider subclass typically goes in onUpdate(). The major difference in your implementation for onUpdate() when creating an app widget with collections is that you must call setRemoteAdapter(). This tells the collection view where to get its data. The RemoteViewsService can then return your implementation of RemoteViewsFactory, and the widget can serve up the appropriate data. When you call this method, you must pass an intent that points to your implementation of RemoteViewsService and the App Widget ID that specifies the app widget to update.</p>\n<p>For example, here’s how the StackView Widget sample implements the onUpdate() callback method to set the RemoteViewsService as the remote adapter for the app widget collection:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onUpdate(Context context, AppWidgetManager appWidgetManager,</span><br><span class=\"line\">int[] appWidgetIds) &#123;</span><br><span class=\"line\">    // update each of the app widgets with the remote adapter</span><br><span class=\"line\">    for (int i = 0; i &lt; appWidgetIds.length; ++i) &#123;     </span><br><span class=\"line\">        // Set up the intent that starts the StackViewService, which will</span><br><span class=\"line\">        // provide the views for this collection.</span><br><span class=\"line\">        Intent intent = new Intent(context, StackWidgetService.class);</span><br><span class=\"line\">        // Add the app widget ID to the intent extras.</span><br><span class=\"line\">        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);</span><br><span class=\"line\">        intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));</span><br><span class=\"line\">        // Instantiate the RemoteViews object for the App Widget layout.</span><br><span class=\"line\">        RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_layout);</span><br><span class=\"line\">        // Set up the RemoteViews object to use a RemoteViews adapter.</span><br><span class=\"line\">        // This adapter connects</span><br><span class=\"line\">        // to a RemoteViewsService  through the specified intent.</span><br><span class=\"line\">        // This is how you populate the data.</span><br><span class=\"line\">        rv.setRemoteAdapter(appWidgetIds[i], R.id.stack_view, intent);       </span><br><span class=\"line\">        // The empty view is displayed when the collection has no items.</span><br><span class=\"line\">        // It should be in the same layout used to instantiate the RemoteViews</span><br><span class=\"line\">        // object above.</span><br><span class=\"line\">        rv.setEmptyView(R.id.stack_view, R.id.empty_view);</span><br><span class=\"line\">        //</span><br><span class=\"line\">        // Do additional processing specific to this app widget...</span><br><span class=\"line\">        //     </span><br><span class=\"line\">        appWidgetManager.updateAppWidget(appWidgetIds[i], rv);   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    super.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RemoteViewsService类\"><a href=\"#RemoteViewsService类\" class=\"headerlink\" title=\"RemoteViewsService类\"></a>RemoteViewsService类</h3><p>As described above, your RemoteViewsService subclass provides the RemoteViewsFactory used to populate the remote collection view.</p>\n<p>Specifically, you need to perform these steps:</p>\n<ol>\n<li>Subclass RemoteViewsService. RemoteViewsService is the service through which a remote adapter can request RemoteViews.</li>\n<li>In your RemoteViewsService subclass, include a class that implements the RemoteViewsFactory interface. RemoteViewsFactory is an interface for an adapter between a remote collection view (such as ListView, GridView, and so on) and the underlying data for that view. Your implementation is responsible for making a RemoteViews object for each item in the data set. This interface is a thin wrapper around Adapter.</li>\n</ol>\n<p>The primary contents of the RemoteViewsService implementation is its RemoteViewsFactory, described below.</p>\n<h3 id=\"RemoteViewsFactory接口\"><a href=\"#RemoteViewsFactory接口\" class=\"headerlink\" title=\"RemoteViewsFactory接口\"></a>RemoteViewsFactory接口</h3><p>Your custom class that implements the RemoteViewsFactory interface provides the app widget with the data for the items in its collection. To do this, it combines your app widget item XML layout file with a source of data. This source of data could be anything from a database to a simple array. In the StackView Widget sample, the data source is an array of WidgetItems. The RemoteViewsFactory functions as an adapter to glue the data to the remote collection view.</p>\n<p>The two most important methods you need to implement for your RemoteViewsFactory subclass are onCreate() and getViewAt() .</p>\n<p>The system calls onCreate() when creating your factory for the first time. This is where you set up any connections and/or cursors to your data source. For example, the StackView Widget sample uses onCreate() to initialize an array of WidgetItem objects. When your app widget is active, the system accesses these objects using their index position in the array and the text they contain is displayed</p>\n<p>Here is an excerpt from the StackView Widget sample’s RemoteViewsFactory implementation that shows portions of the onCreate() method:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StackRemoteViewsFactory implements</span><br><span class=\"line\">RemoteViewsService.RemoteViewsFactory &#123;</span><br><span class=\"line\">    private static final int mCount = 10;</span><br><span class=\"line\">    private List&lt;WidgetItem&gt; mWidgetItems = new ArrayList&lt;WidgetItem&gt;();</span><br><span class=\"line\">    private Context mContext;</span><br><span class=\"line\">    private int mAppWidgetId;</span><br><span class=\"line\">    public StackRemoteViewsFactory(Context context, Intent intent) &#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,</span><br><span class=\"line\">                AppWidgetManager.INVALID_APPWIDGET_ID);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void onCreate() &#123;</span><br><span class=\"line\">        // In onCreate() you setup any connections / cursors to your data source. Heavy lifting,</span><br><span class=\"line\">        // for example downloading or creating content etc, should be deferred to onDataSetChanged()</span><br><span class=\"line\">        // or getViewAt(). Taking more than 20 seconds in this call will result in an ANR.</span><br><span class=\"line\">        for (int i = 0; i &lt; mCount; i++) &#123;</span><br><span class=\"line\">            mWidgetItems.add(new WidgetItem(i + &quot;!&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>The RemoteViewsFactory method getViewAt() returns a RemoteViews object corresponding to the data at the specified position in the data set. Here is an excerpt from the StackView Widget sample’s RemoteViewsFactory implementation:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public RemoteViews getViewAt(int position) &#123;</span><br><span class=\"line\">    // Construct a remote views item based on the app widget item XML file,</span><br><span class=\"line\">    // and set the text based on the position.</span><br><span class=\"line\">    RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.widget_item);</span><br><span class=\"line\">    rv.setTextViewText(R.id.widget_item, mWidgetItems.get(position).text);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // Return the remote views object.</span><br><span class=\"line\">    return rv;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为个别Item添加行为\"><a href=\"#为个别Item添加行为\" class=\"headerlink\" title=\"为个别Item添加行为\"></a>为个别Item添加行为</h3><p>The above sections show you how to bind your data to your app widget collection. But what if you want to add dynamic behavior to the individual items in your collection view?</p>\n<p>As described in Using the AppWidgetProvider Class, you normally use setOnClickPendingIntent() to set an object’s click behavior—such as to cause a button to launch an Activity. But this approach is not allowed for child views in an individual collection item (to clarify, you could use setOnClickPendingIntent() to set up a global button in the Gmail app widget that launches the app, for example, but not on the individual list items). Instead, to add click behavior to individual items in a collection, you use setOnClickFillInIntent(). This entails setting up up a pending intent template for your collection view, and then setting a fill-in intent on each item in the collection via your RemoteViewsFactory.</p>\n<p>This section uses the StackView Widget sample to describe how to add behavior to individual items. In the StackView Widget sample, if the user touches the top view, the app widget displays the Toast message “Touched view n,” where n is the index (position) of the touched view. This is how it works:</p>\n<ul>\n<li>The StackWidgetProvider (an AppWidgetProvider subclass) creates a pending intent that has a custom action called TOAST_ACTION.</li>\n<li>When the user touches a view, the intent is fired and it broadcasts TOAST_ACTION.</li>\n<li>This broadcast is intercepted by the StackWidgetProvider’s onReceive() method, and the app widget displays the Toast message for the touched view. The data for the collection items is provided by the RemoteViewsFactory, via the RemoteViewsService.</li>\n</ul>\n<blockquote>\n<p>Note: The StackView Widget sample uses a broadcast, but typically an app widget would simply launch an activity in a scenario like this one.</p>\n</blockquote>\n<h4 id=\"设置待定意图模板-pending-intent-template\"><a href=\"#设置待定意图模板-pending-intent-template\" class=\"headerlink\" title=\"设置待定意图模板(pending intent template)\"></a>设置待定意图模板(pending intent template)</h4><p>StackWidgetProvider（AppWidgetProvider子类）设置了一个待定意图.集合中具体的Item不能单独设置属于他们自己的待定意图。(注：性能原因) 取而代之的，集合作为一个整体设置一个待定意图模板，然后具体的Item设置填充意图(fill-in intent)来创建在item-by-item<br>The StackWidgetProvider (AppWidgetProvider subclass) sets up a pending intent. Individuals items of a collection cannot set up their own pending intents. Instead, the collection as a whole sets up a pending intent template, and the individual items set a fill-in intent to create unique behavior on an item-by-item basis.</p>\n<p>This class also receives the broadcast that is sent when the user touches a view. It processes this event in its onReceive() method. If the intent’s action is TOAST_ACTION, the app widget displays a Toast message for the current view.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StackWidgetProvider extends AppWidgetProvider &#123;</span><br><span class=\"line\">    public static final String TOAST_ACTION = &quot;com.example.android.stackwidget.TOAST_ACTION&quot;;</span><br><span class=\"line\">    public static final String EXTRA_ITEM = &quot;com.example.android.stackwidget.EXTRA_ITEM&quot;;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // Called when the BroadcastReceiver receives an Intent broadcast.</span><br><span class=\"line\">    // Checks to see whether the intent&apos;s action is TOAST_ACTION. If it is, the app widget</span><br><span class=\"line\">    // displays a Toast message for the current item.</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class=\"line\">        AppWidgetManager mgr = AppWidgetManager.getInstance(context);</span><br><span class=\"line\">        if (intent.getAction().equals(TOAST_ACTION)) &#123;</span><br><span class=\"line\">            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,</span><br><span class=\"line\">                AppWidgetManager.INVALID_APPWIDGET_ID);</span><br><span class=\"line\">            int viewIndex = intent.getIntExtra(EXTRA_ITEM, 0);</span><br><span class=\"line\">            Toast.makeText(context, &quot;Touched view &quot; + viewIndex, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        super.onReceive(context, intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123;</span><br><span class=\"line\">        // update each of the app widgets with the remote adapter</span><br><span class=\"line\">        for (int i = 0; i &lt; appWidgetIds.length; ++i) &#123;</span><br><span class=\"line\">            // Sets up the intent that points to the StackViewService that will</span><br><span class=\"line\">            // provide the views for this collection.</span><br><span class=\"line\">            Intent intent = new Intent(context, StackWidgetService.class);</span><br><span class=\"line\">            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);</span><br><span class=\"line\">            // When intents are compared, the extras are ignored, so we need to embed the extras</span><br><span class=\"line\">            // into the data so that the extras will not be ignored.</span><br><span class=\"line\">            intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));</span><br><span class=\"line\">            RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_layout);</span><br><span class=\"line\">            rv.setRemoteAdapter(appWidgetIds[i], R.id.stack_view, intent);</span><br><span class=\"line\">            // The empty view is displayed when the collection has no items. It should be a sibling</span><br><span class=\"line\">            // of the collection view.</span><br><span class=\"line\">            rv.setEmptyView(R.id.stack_view, R.id.empty_view);</span><br><span class=\"line\">            // This section makes it possible for items to have individualized behavior.</span><br><span class=\"line\">            // It does this by setting up a pending intent template. Individuals items of a collection</span><br><span class=\"line\">            // cannot set up their own pending intents. Instead, the collection as a whole sets</span><br><span class=\"line\">            // up a pending intent template, and the individual items set a fillInIntent</span><br><span class=\"line\">            // to create unique behavior on an item-by-item basis.</span><br><span class=\"line\">            Intent toastIntent = new Intent(context, StackWidgetProvider.class);</span><br><span class=\"line\">            // Set the action for the intent.</span><br><span class=\"line\">            // When the user touches a particular view, it will have the effect of</span><br><span class=\"line\">            // broadcasting TOAST_ACTION.</span><br><span class=\"line\">            toastIntent.setAction(StackWidgetProvider.TOAST_ACTION);</span><br><span class=\"line\">            toastIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);</span><br><span class=\"line\">            intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));</span><br><span class=\"line\">            PendingIntent toastPendingIntent = PendingIntent.getBroadcast(context, 0, toastIntent,</span><br><span class=\"line\">                PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class=\"line\">            rv.setPendingIntentTemplate(R.id.stack_view, toastPendingIntent);</span><br><span class=\"line\">            appWidgetManager.updateAppWidget(appWidgetIds[i], rv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    super.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"设置填充意图-fill-in-intent\"><a href=\"#设置填充意图-fill-in-intent\" class=\"headerlink\" title=\"设置填充意图(fill-in intent)\"></a>设置填充意图(fill-in intent)</h4><p>你的RemoteViewsFactory必须为每一个在集合中的item设置一个填充意图(fill-in intent)。这样才可能做到区分给定的Item单独的点击动作。填充意图然后与待定意图模板(PendingItent template)结合一起，确定了当item被点击时将执行的最终意图。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StackWidgetService extends RemoteViewsService &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public RemoteViewsFactory onGetViewFactory(Intent intent) &#123;</span><br><span class=\"line\">        return new StackRemoteViewsFactory(this.getApplicationContext(), intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory &#123;</span><br><span class=\"line\">    private static final int mCount = 10;</span><br><span class=\"line\">    private List&lt;WidgetItem&gt; mWidgetItems = new ArrayList&lt;WidgetItem&gt;();</span><br><span class=\"line\">    private Context mContext;</span><br><span class=\"line\">    private int mAppWidgetId;</span><br><span class=\"line\">    public StackRemoteViewsFactory(Context context, Intent intent) &#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,</span><br><span class=\"line\">                AppWidgetManager.INVALID_APPWIDGET_ID);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 初始化数据</span><br><span class=\"line\">        public void onCreate() &#123;</span><br><span class=\"line\">            // 在 onCreate()你可以建立任何连接/游标 到你的源数据中.Heavy lifting.</span><br><span class=\"line\">            // 如下载或者创建内容等，应该延迟到onDataSetChanged()方法中</span><br><span class=\"line\">            // 或者 getViewAt(), 在这个回调中耗时超过20秒，将会引起ANR.</span><br><span class=\"line\">            for (int i = 0; i &lt; mCount; i++) &#123;</span><br><span class=\"line\">                mWidgetItems.add(new WidgetItem(i + &quot;!&quot;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        // Given the position (index) of a WidgetItem in the array, use the item&apos;s text value in</span><br><span class=\"line\">        // combination with the app widget item XML file to construct a RemoteViews object.</span><br><span class=\"line\">        public RemoteViews getViewAt(int position) &#123;</span><br><span class=\"line\">            // position will always range from 0 to getCount() - 1.</span><br><span class=\"line\">            // Construct a RemoteViews item based on the app widget item XML file, and set the</span><br><span class=\"line\">            // text based on the position.</span><br><span class=\"line\">            RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.widget_item);</span><br><span class=\"line\">            rv.setTextViewText(R.id.widget_item, mWidgetItems.get(position).text);</span><br><span class=\"line\">            // Next, set a fill-intent, which will be used to fill in the pending intent template</span><br><span class=\"line\">            // that is set on the collection view in StackWidgetProvider.</span><br><span class=\"line\">            Bundle extras = new Bundle();</span><br><span class=\"line\">            extras.putInt(StackWidgetProvider.EXTRA_ITEM, position);</span><br><span class=\"line\">            Intent fillInIntent = new Intent();</span><br><span class=\"line\">            fillInIntent.putExtras(extras);</span><br><span class=\"line\">            // Make it possible to distinguish the individual on-click</span><br><span class=\"line\">            // action of a given item</span><br><span class=\"line\">            rv.setOnClickFillInIntent(R.id.widget_item, fillInIntent);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            // Return the RemoteViews object.</span><br><span class=\"line\">            return rv;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"保持集合数据最新\"><a href=\"#保持集合数据最新\" class=\"headerlink\" title=\"保持集合数据最新\"></a>保持集合数据最新</h2><p>下面的流程图发生在一个使用了集合的App Widget更新数据时。它展示了App Widget代码与RemoteViewsFactory的交互，以及你如何触发更新。</p>\n<p><img src=\"http://developer.android.com/images/appwidgets/appwidget_collections.png\" alt=\"fresh data\"></p>\n<p>使用了集合的App Widgets的其中一个特性就是可以为用户提供最新的内容。例如，Android 3.0 Gmail app widget，可以为用户提供他们收件箱的一个快照。为了做到这一点，你需要能触发你的RemoteViewsFactory和集合view,去获得并且显示新数据。你可以通过使用AppWidgetManager调用notifyAppWidgetViewDataChanged()来实现这一点。然后在你的RemoteViewsFactory的OnDataChanged()获得一个回调结果，一个你有机会可以获取任何新数据的回调接口。注意，你可以在onDataSetChanged()回调方法中执行密集的同步操作(processing-intensive operations synchronously)。回调方法在元数据或者视图数据从RemoteViewsFactory那里获取之前以及被执行完成，所以你可以放心。此外，你也可以在getViewAt()方法内执行密集的同步操作。<strong>如果这个回调函数执行了很长时间，那么加载视图(RemoteViewsFactory中指定的getLoadingView()方法)将被显示在集合视图中正确的位置，直到它返回结果.</strong></p>\n"},{"date":"2013-05-16T16:00:00.000Z","layout":"post","title":"ActiveAndroid--Android轻量级ORM框架","_content":"\nGithub:[ActiveAndroid](https://github.com/pardom/ActiveAndroid)\n\nActiveAndroid算是一个轻量级的ORM框架，简单地通过如save()和delete()等方法来做到增删改查等操作。配置起来也还算简单。\n\n下面是作者的原话：\n\n\n>ActiveAndroid is an active record style ORM (object relational mapper). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like save() and delete().\n\n>ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.\n\n\n## 开始\n---\n\n在AndroidManifest.xml中我们需要添加这两个<meta-data>\n\n- `AA_DB_NAME` (这个name不能改，但是是可选的，如果不写的话 是默认的\"Application.db\"这个值）\n- `AA_DB_VERSION` (optional – defaults to 1)\n\n\n```\n<manifest ...>\n\t<application android:name=\"com.activeandroid.app.Application\" ...>\n\t\t...\n\t\t<meta-data android:name=\"AA_DB_NAME\" android:value=\"your.db\" />\n\t\t<meta-data android:name=\"AA_DB_VERSION\" android:value=\"5\" />\n\t</application>\n</manifest>\n```\n\n这个`<application>`是必须指定的，但你也可以使用自己的Application,继承自`com.activeandroid.app.Application`\n\n```\npublic class MyApplication extends com.activeandroid.app.Application { ...\n```\n\n如果你不想或者不能继承`com.activeandroid.app.Application`的话，那么就这样\n\n```\npublic class MyApplication extends SomeLibraryApplication {\n\t@Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\t\tActiveAndroid.initialize(this);\n\t}\n\t@Override\n\tpublic void onTerminate() {\n\t\tsuper.onTerminate();\n\t\tActiveAndroid.dispose();\n\t}\n}\n```\n\n`ActiveAndroid.initialize(this)；`做初始化工作，`ActiveAndroid.dispose();`做清理工作\n\n##创建数据库模型\n---\n\n我们使用`@Table(name = \"Items\")`来表示表，使用`@Column(name = \"Name\")`来表示列，ActiveAndroid会使用自增长的ID作为主键，然后按照注解描述，将类对应映射为数据库表。\n\n```\n@Table(name = \"Items\")\npublic class Item extends Model {\n\t@Column(name = \"Name\")\n\tpublic String name;\n\t@Column(name = \"Category\")\n\tpublic Category category;\n        public Item(){\n                super();\n        }\n        public Item(String name, Category category){\n                super();\n                this.name = name;\n                this.category = category;\n        }\n}\n```\n### 依赖关系的数据库表\n假如Item和Category是多对一的关系，那么我们可以这样子创建他们的类\n\n```\n@Table(name = \"Items\")\npublic class Item extends Model {\n\t@Column(name = \"Name\")\n\tpublic String name;\n\t@Column(name = \"Category\")\n\tpublic Category category;\n}\n```\n\n```\n@Table(name = \"Categories\")\npublic class Category extends Model {\n\t@Column(name = \"Name\")\n\tpublic String name;\n\tpublic List<Item> items() {\n\t\treturn getMany(Item.class, \"Category\");\n\t}\n}\n```\n\n## 如何保存和更新数据到数据库\n---\n\n###单挑插入\n\n保存Category对象\n\n```\nCategory restaurants = new Category();\nrestaurants.name = \"Restaurants\";\nrestaurants.save();\n```\n\n分配了一个category并且保存到数据库\n```\nItem item = new Item();\nitem.category = restaurants;\nitem.name = \"Outback Steakhouse\";\nitem.save();\n```\n###批量插入\n\n如果你要批量插入数据，最好使用事务(transaction)。\n\n```\nActiveAndroid.beginTransaction();\ntry {\n        for (int i = 0; i < 100; i++) {\n            Item item = new Item();\n            item.name = \"Example \" + i;\n            item.save();\n        }\n        ActiveAndroid.setTransactionSuccessful();\n}\nfinally {\n        ActiveAndroid.endTransaction();\n}\n```\n使用事务的话只用了 40ms，不然的话需要4秒。\n\n###删除记录\n\n我们有三种方式删除一条记录\n\n```\nItem item = Item.load(Item.class, 1);\nitem.delete();\n```\n\n```\nItem.delete(Item.class, 1);\n```\n\n```\nnew Delete().from(Item.class).where(\"Id = ?\", 1).execute();\n```\n很简单吧\n\n## 查询数据库\n---\n\n作者将查询做的非常像SQLite的原生查询语句，几乎涵盖了所有的指令\ncom.activeandroid.query包下有以下类\n\n- Delete\n- From\n- Join\n- Select\n- Set\n- Update\n\n我们举例说明吧\n\n```\npublic static Item getRandom(Category category) {\n\treturn new Select()\n\t\t.from(Item.class)\n\t\t.where(\"Category = ?\", category.getId())\n\t\t.orderBy(\"RANDOM()\")\n\t\t.executeSingle();\n}\n```\n对应的sqlite查询语句就是 `select * from Item where Category = ? order by RANDOM() `\n当然还支持其他非常多的指令\n\n- limit\n- offset\n- as\n- desc/asc\n- inner/outer/cross join\n- group by\n- having\n等等\n\n大家可以在**ActiveAndroid项目下的tests工程**找到测试用例，有非常多详细的描述。\n","source":"_posts/2013-05-17-about-activeandroid.md","raw":"---\ncategory: Android\ndate: 2013-05-17\nlayout: post\ntitle: ActiveAndroid--Android轻量级ORM框架\n---\n\nGithub:[ActiveAndroid](https://github.com/pardom/ActiveAndroid)\n\nActiveAndroid算是一个轻量级的ORM框架，简单地通过如save()和delete()等方法来做到增删改查等操作。配置起来也还算简单。\n\n下面是作者的原话：\n\n\n>ActiveAndroid is an active record style ORM (object relational mapper). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like save() and delete().\n\n>ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.\n\n\n## 开始\n---\n\n在AndroidManifest.xml中我们需要添加这两个<meta-data>\n\n- `AA_DB_NAME` (这个name不能改，但是是可选的，如果不写的话 是默认的\"Application.db\"这个值）\n- `AA_DB_VERSION` (optional – defaults to 1)\n\n\n```\n<manifest ...>\n\t<application android:name=\"com.activeandroid.app.Application\" ...>\n\t\t...\n\t\t<meta-data android:name=\"AA_DB_NAME\" android:value=\"your.db\" />\n\t\t<meta-data android:name=\"AA_DB_VERSION\" android:value=\"5\" />\n\t</application>\n</manifest>\n```\n\n这个`<application>`是必须指定的，但你也可以使用自己的Application,继承自`com.activeandroid.app.Application`\n\n```\npublic class MyApplication extends com.activeandroid.app.Application { ...\n```\n\n如果你不想或者不能继承`com.activeandroid.app.Application`的话，那么就这样\n\n```\npublic class MyApplication extends SomeLibraryApplication {\n\t@Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\t\tActiveAndroid.initialize(this);\n\t}\n\t@Override\n\tpublic void onTerminate() {\n\t\tsuper.onTerminate();\n\t\tActiveAndroid.dispose();\n\t}\n}\n```\n\n`ActiveAndroid.initialize(this)；`做初始化工作，`ActiveAndroid.dispose();`做清理工作\n\n##创建数据库模型\n---\n\n我们使用`@Table(name = \"Items\")`来表示表，使用`@Column(name = \"Name\")`来表示列，ActiveAndroid会使用自增长的ID作为主键，然后按照注解描述，将类对应映射为数据库表。\n\n```\n@Table(name = \"Items\")\npublic class Item extends Model {\n\t@Column(name = \"Name\")\n\tpublic String name;\n\t@Column(name = \"Category\")\n\tpublic Category category;\n        public Item(){\n                super();\n        }\n        public Item(String name, Category category){\n                super();\n                this.name = name;\n                this.category = category;\n        }\n}\n```\n### 依赖关系的数据库表\n假如Item和Category是多对一的关系，那么我们可以这样子创建他们的类\n\n```\n@Table(name = \"Items\")\npublic class Item extends Model {\n\t@Column(name = \"Name\")\n\tpublic String name;\n\t@Column(name = \"Category\")\n\tpublic Category category;\n}\n```\n\n```\n@Table(name = \"Categories\")\npublic class Category extends Model {\n\t@Column(name = \"Name\")\n\tpublic String name;\n\tpublic List<Item> items() {\n\t\treturn getMany(Item.class, \"Category\");\n\t}\n}\n```\n\n## 如何保存和更新数据到数据库\n---\n\n###单挑插入\n\n保存Category对象\n\n```\nCategory restaurants = new Category();\nrestaurants.name = \"Restaurants\";\nrestaurants.save();\n```\n\n分配了一个category并且保存到数据库\n```\nItem item = new Item();\nitem.category = restaurants;\nitem.name = \"Outback Steakhouse\";\nitem.save();\n```\n###批量插入\n\n如果你要批量插入数据，最好使用事务(transaction)。\n\n```\nActiveAndroid.beginTransaction();\ntry {\n        for (int i = 0; i < 100; i++) {\n            Item item = new Item();\n            item.name = \"Example \" + i;\n            item.save();\n        }\n        ActiveAndroid.setTransactionSuccessful();\n}\nfinally {\n        ActiveAndroid.endTransaction();\n}\n```\n使用事务的话只用了 40ms，不然的话需要4秒。\n\n###删除记录\n\n我们有三种方式删除一条记录\n\n```\nItem item = Item.load(Item.class, 1);\nitem.delete();\n```\n\n```\nItem.delete(Item.class, 1);\n```\n\n```\nnew Delete().from(Item.class).where(\"Id = ?\", 1).execute();\n```\n很简单吧\n\n## 查询数据库\n---\n\n作者将查询做的非常像SQLite的原生查询语句，几乎涵盖了所有的指令\ncom.activeandroid.query包下有以下类\n\n- Delete\n- From\n- Join\n- Select\n- Set\n- Update\n\n我们举例说明吧\n\n```\npublic static Item getRandom(Category category) {\n\treturn new Select()\n\t\t.from(Item.class)\n\t\t.where(\"Category = ?\", category.getId())\n\t\t.orderBy(\"RANDOM()\")\n\t\t.executeSingle();\n}\n```\n对应的sqlite查询语句就是 `select * from Item where Category = ? order by RANDOM() `\n当然还支持其他非常多的指令\n\n- limit\n- offset\n- as\n- desc/asc\n- inner/outer/cross join\n- group by\n- having\n等等\n\n大家可以在**ActiveAndroid项目下的tests工程**找到测试用例，有非常多详细的描述。\n","slug":"2013-05-17-about-activeandroid","published":1,"updated":"2018-02-14T21:36:14.833Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tli000mrpfypfz1ikkv","content":"<p>Github:<a href=\"https://github.com/pardom/ActiveAndroid\" target=\"_blank\" rel=\"noopener\">ActiveAndroid</a></p>\n<p>ActiveAndroid算是一个轻量级的ORM框架，简单地通过如save()和delete()等方法来做到增删改查等操作。配置起来也还算简单。</p>\n<p>下面是作者的原话：</p>\n<blockquote>\n<p>ActiveAndroid is an active record style ORM (object relational mapper). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like save() and delete().</p>\n<p>ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.</p>\n</blockquote>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><hr>\n<p>在AndroidManifest.xml中我们需要添加这两个<meta-data></meta-data></p>\n<ul>\n<li><code>AA_DB_NAME</code> (这个name不能改，但是是可选的，如果不写的话 是默认的”Application.db”这个值）</li>\n<li><code>AA_DB_VERSION</code> (optional – defaults to 1)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest ...&gt;</span><br><span class=\"line\">\t&lt;application android:name=&quot;com.activeandroid.app.Application&quot; ...&gt;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t\t&lt;meta-data android:name=&quot;AA_DB_NAME&quot; android:value=&quot;your.db&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;meta-data android:name=&quot;AA_DB_VERSION&quot; android:value=&quot;5&quot; /&gt;</span><br><span class=\"line\">\t&lt;/application&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>\n<p>这个<code>&lt;application&gt;</code>是必须指定的，但你也可以使用自己的Application,继承自<code>com.activeandroid.app.Application</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyApplication extends com.activeandroid.app.Application &#123; ...</span><br></pre></td></tr></table></figure>\n<p>如果你不想或者不能继承<code>com.activeandroid.app.Application</code>的话，那么就这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyApplication extends SomeLibraryApplication &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onCreate() &#123;</span><br><span class=\"line\">\t\tsuper.onCreate();</span><br><span class=\"line\">\t\tActiveAndroid.initialize(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onTerminate() &#123;</span><br><span class=\"line\">\t\tsuper.onTerminate();</span><br><span class=\"line\">\t\tActiveAndroid.dispose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ActiveAndroid.initialize(this)；</code>做初始化工作，<code>ActiveAndroid.dispose();</code>做清理工作</p>\n<h2 id=\"创建数据库模型\"><a href=\"#创建数据库模型\" class=\"headerlink\" title=\"##创建数据库模型\"></a>##创建数据库模型</h2><p>我们使用<code>@Table(name = &quot;Items&quot;)</code>来表示表，使用<code>@Column(name = &quot;Name&quot;)</code>来表示列，ActiveAndroid会使用自增长的ID作为主键，然后按照注解描述，将类对应映射为数据库表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Table(name = &quot;Items&quot;)</span><br><span class=\"line\">public class Item extends Model &#123;</span><br><span class=\"line\">\t@Column(name = &quot;Name&quot;)</span><br><span class=\"line\">\tpublic String name;</span><br><span class=\"line\">\t@Column(name = &quot;Category&quot;)</span><br><span class=\"line\">\tpublic Category category;</span><br><span class=\"line\">        public Item()&#123;</span><br><span class=\"line\">                super();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public Item(String name, Category category)&#123;</span><br><span class=\"line\">                super();</span><br><span class=\"line\">                this.name = name;</span><br><span class=\"line\">                this.category = category;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"依赖关系的数据库表\"><a href=\"#依赖关系的数据库表\" class=\"headerlink\" title=\"依赖关系的数据库表\"></a>依赖关系的数据库表</h3><p>假如Item和Category是多对一的关系，那么我们可以这样子创建他们的类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Table(name = &quot;Items&quot;)</span><br><span class=\"line\">public class Item extends Model &#123;</span><br><span class=\"line\">\t@Column(name = &quot;Name&quot;)</span><br><span class=\"line\">\tpublic String name;</span><br><span class=\"line\">\t@Column(name = &quot;Category&quot;)</span><br><span class=\"line\">\tpublic Category category;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Table(name = &quot;Categories&quot;)</span><br><span class=\"line\">public class Category extends Model &#123;</span><br><span class=\"line\">\t@Column(name = &quot;Name&quot;)</span><br><span class=\"line\">\tpublic String name;</span><br><span class=\"line\">\tpublic List&lt;Item&gt; items() &#123;</span><br><span class=\"line\">\t\treturn getMany(Item.class, &quot;Category&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何保存和更新数据到数据库\"><a href=\"#如何保存和更新数据到数据库\" class=\"headerlink\" title=\"如何保存和更新数据到数据库\"></a>如何保存和更新数据到数据库</h2><hr>\n<p>###单挑插入</p>\n<p>保存Category对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Category restaurants = new Category();</span><br><span class=\"line\">restaurants.name = &quot;Restaurants&quot;;</span><br><span class=\"line\">restaurants.save();</span><br></pre></td></tr></table></figure>\n<p>分配了一个category并且保存到数据库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Item item = new Item();</span><br><span class=\"line\">item.category = restaurants;</span><br><span class=\"line\">item.name = &quot;Outback Steakhouse&quot;;</span><br><span class=\"line\">item.save();</span><br></pre></td></tr></table></figure></p>\n<p>###批量插入</p>\n<p>如果你要批量插入数据，最好使用事务(transaction)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActiveAndroid.beginTransaction();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">            Item item = new Item();</span><br><span class=\"line\">            item.name = &quot;Example &quot; + i;</span><br><span class=\"line\">            item.save();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ActiveAndroid.setTransactionSuccessful();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">finally &#123;</span><br><span class=\"line\">        ActiveAndroid.endTransaction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用事务的话只用了 40ms，不然的话需要4秒。</p>\n<p>###删除记录</p>\n<p>我们有三种方式删除一条记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Item item = Item.load(Item.class, 1);</span><br><span class=\"line\">item.delete();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Item.delete(Item.class, 1);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Delete().from(Item.class).where(&quot;Id = ?&quot;, 1).execute();</span><br></pre></td></tr></table></figure>\n<p>很简单吧</p>\n<h2 id=\"查询数据库\"><a href=\"#查询数据库\" class=\"headerlink\" title=\"查询数据库\"></a>查询数据库</h2><hr>\n<p>作者将查询做的非常像SQLite的原生查询语句，几乎涵盖了所有的指令<br>com.activeandroid.query包下有以下类</p>\n<ul>\n<li>Delete</li>\n<li>From</li>\n<li>Join</li>\n<li>Select</li>\n<li>Set</li>\n<li>Update</li>\n</ul>\n<p>我们举例说明吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Item getRandom(Category category) &#123;</span><br><span class=\"line\">\treturn new Select()</span><br><span class=\"line\">\t\t.from(Item.class)</span><br><span class=\"line\">\t\t.where(&quot;Category = ?&quot;, category.getId())</span><br><span class=\"line\">\t\t.orderBy(&quot;RANDOM()&quot;)</span><br><span class=\"line\">\t\t.executeSingle();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对应的sqlite查询语句就是 <code>select * from Item where Category = ? order by RANDOM()</code><br>当然还支持其他非常多的指令</p>\n<ul>\n<li>limit</li>\n<li>offset</li>\n<li>as</li>\n<li>desc/asc</li>\n<li>inner/outer/cross join</li>\n<li>group by</li>\n<li>having<br>等等</li>\n</ul>\n<p>大家可以在<strong>ActiveAndroid项目下的tests工程</strong>找到测试用例，有非常多详细的描述。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Github:<a href=\"https://github.com/pardom/ActiveAndroid\" target=\"_blank\" rel=\"noopener\">ActiveAndroid</a></p>\n<p>ActiveAndroid算是一个轻量级的ORM框架，简单地通过如save()和delete()等方法来做到增删改查等操作。配置起来也还算简单。</p>\n<p>下面是作者的原话：</p>\n<blockquote>\n<p>ActiveAndroid is an active record style ORM (object relational mapper). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like save() and delete().</p>\n<p>ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.</p>\n</blockquote>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><hr>\n<p>在AndroidManifest.xml中我们需要添加这两个<meta-data></meta-data></p>\n<ul>\n<li><code>AA_DB_NAME</code> (这个name不能改，但是是可选的，如果不写的话 是默认的”Application.db”这个值）</li>\n<li><code>AA_DB_VERSION</code> (optional – defaults to 1)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest ...&gt;</span><br><span class=\"line\">\t&lt;application android:name=&quot;com.activeandroid.app.Application&quot; ...&gt;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t\t&lt;meta-data android:name=&quot;AA_DB_NAME&quot; android:value=&quot;your.db&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;meta-data android:name=&quot;AA_DB_VERSION&quot; android:value=&quot;5&quot; /&gt;</span><br><span class=\"line\">\t&lt;/application&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>\n<p>这个<code>&lt;application&gt;</code>是必须指定的，但你也可以使用自己的Application,继承自<code>com.activeandroid.app.Application</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyApplication extends com.activeandroid.app.Application &#123; ...</span><br></pre></td></tr></table></figure>\n<p>如果你不想或者不能继承<code>com.activeandroid.app.Application</code>的话，那么就这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyApplication extends SomeLibraryApplication &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onCreate() &#123;</span><br><span class=\"line\">\t\tsuper.onCreate();</span><br><span class=\"line\">\t\tActiveAndroid.initialize(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onTerminate() &#123;</span><br><span class=\"line\">\t\tsuper.onTerminate();</span><br><span class=\"line\">\t\tActiveAndroid.dispose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ActiveAndroid.initialize(this)；</code>做初始化工作，<code>ActiveAndroid.dispose();</code>做清理工作</p>\n<h2 id=\"创建数据库模型\"><a href=\"#创建数据库模型\" class=\"headerlink\" title=\"##创建数据库模型\"></a>##创建数据库模型</h2><p>我们使用<code>@Table(name = &quot;Items&quot;)</code>来表示表，使用<code>@Column(name = &quot;Name&quot;)</code>来表示列，ActiveAndroid会使用自增长的ID作为主键，然后按照注解描述，将类对应映射为数据库表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Table(name = &quot;Items&quot;)</span><br><span class=\"line\">public class Item extends Model &#123;</span><br><span class=\"line\">\t@Column(name = &quot;Name&quot;)</span><br><span class=\"line\">\tpublic String name;</span><br><span class=\"line\">\t@Column(name = &quot;Category&quot;)</span><br><span class=\"line\">\tpublic Category category;</span><br><span class=\"line\">        public Item()&#123;</span><br><span class=\"line\">                super();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public Item(String name, Category category)&#123;</span><br><span class=\"line\">                super();</span><br><span class=\"line\">                this.name = name;</span><br><span class=\"line\">                this.category = category;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"依赖关系的数据库表\"><a href=\"#依赖关系的数据库表\" class=\"headerlink\" title=\"依赖关系的数据库表\"></a>依赖关系的数据库表</h3><p>假如Item和Category是多对一的关系，那么我们可以这样子创建他们的类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Table(name = &quot;Items&quot;)</span><br><span class=\"line\">public class Item extends Model &#123;</span><br><span class=\"line\">\t@Column(name = &quot;Name&quot;)</span><br><span class=\"line\">\tpublic String name;</span><br><span class=\"line\">\t@Column(name = &quot;Category&quot;)</span><br><span class=\"line\">\tpublic Category category;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Table(name = &quot;Categories&quot;)</span><br><span class=\"line\">public class Category extends Model &#123;</span><br><span class=\"line\">\t@Column(name = &quot;Name&quot;)</span><br><span class=\"line\">\tpublic String name;</span><br><span class=\"line\">\tpublic List&lt;Item&gt; items() &#123;</span><br><span class=\"line\">\t\treturn getMany(Item.class, &quot;Category&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何保存和更新数据到数据库\"><a href=\"#如何保存和更新数据到数据库\" class=\"headerlink\" title=\"如何保存和更新数据到数据库\"></a>如何保存和更新数据到数据库</h2><hr>\n<p>###单挑插入</p>\n<p>保存Category对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Category restaurants = new Category();</span><br><span class=\"line\">restaurants.name = &quot;Restaurants&quot;;</span><br><span class=\"line\">restaurants.save();</span><br></pre></td></tr></table></figure>\n<p>分配了一个category并且保存到数据库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Item item = new Item();</span><br><span class=\"line\">item.category = restaurants;</span><br><span class=\"line\">item.name = &quot;Outback Steakhouse&quot;;</span><br><span class=\"line\">item.save();</span><br></pre></td></tr></table></figure></p>\n<p>###批量插入</p>\n<p>如果你要批量插入数据，最好使用事务(transaction)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActiveAndroid.beginTransaction();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">            Item item = new Item();</span><br><span class=\"line\">            item.name = &quot;Example &quot; + i;</span><br><span class=\"line\">            item.save();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ActiveAndroid.setTransactionSuccessful();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">finally &#123;</span><br><span class=\"line\">        ActiveAndroid.endTransaction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用事务的话只用了 40ms，不然的话需要4秒。</p>\n<p>###删除记录</p>\n<p>我们有三种方式删除一条记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Item item = Item.load(Item.class, 1);</span><br><span class=\"line\">item.delete();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Item.delete(Item.class, 1);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Delete().from(Item.class).where(&quot;Id = ?&quot;, 1).execute();</span><br></pre></td></tr></table></figure>\n<p>很简单吧</p>\n<h2 id=\"查询数据库\"><a href=\"#查询数据库\" class=\"headerlink\" title=\"查询数据库\"></a>查询数据库</h2><hr>\n<p>作者将查询做的非常像SQLite的原生查询语句，几乎涵盖了所有的指令<br>com.activeandroid.query包下有以下类</p>\n<ul>\n<li>Delete</li>\n<li>From</li>\n<li>Join</li>\n<li>Select</li>\n<li>Set</li>\n<li>Update</li>\n</ul>\n<p>我们举例说明吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Item getRandom(Category category) &#123;</span><br><span class=\"line\">\treturn new Select()</span><br><span class=\"line\">\t\t.from(Item.class)</span><br><span class=\"line\">\t\t.where(&quot;Category = ?&quot;, category.getId())</span><br><span class=\"line\">\t\t.orderBy(&quot;RANDOM()&quot;)</span><br><span class=\"line\">\t\t.executeSingle();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对应的sqlite查询语句就是 <code>select * from Item where Category = ? order by RANDOM()</code><br>当然还支持其他非常多的指令</p>\n<ul>\n<li>limit</li>\n<li>offset</li>\n<li>as</li>\n<li>desc/asc</li>\n<li>inner/outer/cross join</li>\n<li>group by</li>\n<li>having<br>等等</li>\n</ul>\n<p>大家可以在<strong>ActiveAndroid项目下的tests工程</strong>找到测试用例，有非常多详细的描述。</p>\n"},{"date":"2013-05-21T16:00:00.000Z","layout":"post","title":"Android中制作有景深视差的ScrollView","_content":"\n<img src=\"http://pic.yupoo.com/wsyanligang_v/CSz7cQTh/UZ5XO.png\" width=330 />\n\n首先我们需要创建一个类继承ViewGroup，用来包含前景(ForgroundView)和后景(BackgourdView)。\n\n```\npublic class ParallaxScrollView extends ViewGroup{}\n```\n\n接着是一个继承自ScrollView的类，每当`onScrollChanged()`触发时，都反馈给ParallaxScrollView。\n\n```\npublic class ObservableScrollView extends ScrollView{\n\tprivate ScrollCallbacks mCallbacks;\n\t@Override\n    protected void onScrollChanged(int l, int t, int oldl, int oldt) {\n        super.onScrollChanged(l, t, oldl, oldt);\n        if (mCallbacks != null) {\n            mCallbacks.onScrollChanged(l, t, oldl, oldt);\n        }\n    }\n    static interface ScrollCallbacks {\n        public void onScrollChanged(int l, int t, int oldl, int oldt);\n    }\n}\n```\n\n然后如何使用呢？我们需要在xml中这样定义\n\n```\n<couk.jenxsol.parallaxscrollview.views.ParallaxScrollView>\n\t<!--Background-->\n\t<ImageView\n\t    android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:gravity=\"center\"\n        android:scaleType=\"fitXY\"\n        android:src=\"...\"/>\n\t<!--Foreground-->\n\t<couk.jenxsol.parallaxscrollview.views.ObservableScrollView>\n\t\t<LinearLayout>\n\t\t</LinearLayout>\n\t<couk.jenxsol.parallaxscrollview.views.ObservableScrollView/>\n</couk.jenxsol.parallaxscrollview.views.ParallaxScrollView>\n```\n\n做到前后景视差，就需要当ScrollView滑动时，前景和后景滑动的距离不同，例如：前景正常向上滑动了10px,但是后景这时候只向上滑动3px，我们将这个变量定义为`mScrollDiff`,那么`mScrollDiff`等于0.3f。\n\n`ScrollView`的高度可以分为两部分，一个是`ScrollContentHeight`，ScrollView中包含的LinearLayout的高度，通常这个内容是很长的，一个是`ScollViewHeight`，通常就是我们屏幕的高再减去状态栏或者标题栏，即可见范围。以上我们称为前景。\n\n后景就是我们的背景了，我们需要在每当前景滚动时，就动态改变后景的布局。\n\n那我们就一步步解析如果做到前后景视差的ScrollView吧，首先在ParallaxScrollView完成布局填充后，我们完成一些初始化工作:\n\n```\nprotected void onFinishInflate() {\n    super.onFinishInflate();\n    if (getChildCount() > 2) {\n        throw new IllegalStateException(\"ParallaxScrollView can host only two direct children\");\n    }\n    organiseViews();\n}\n```\n\n作者考虑到了如果开发者没有按照使用说明来编写xml的话的一些意外情况，我们现在暂时忽略。\n\n```\nprivate void organiseViews() {\n    if (getChildCount() <= 0)\n        return;\n   // 将第一个子元素作为背景，第二个子元素作为前景\n       final View background = getChildAt(0);\n       final View foreground = getChildAt(1);\n       organiseBackgroundView(background);\n       organiseForgroundView(foreground);\n    }\nprivate void organiseBackgroundView(final View background) {\n    mBackground = background;\n}\nprivate void organiseForgroundView(final View forground) {\n\t…\n    mScrollView = (ObservableScrollView) forground;\n\t…\n    if (mScrollView != null) {\n        mScrollView.setLayoutParams(forground.getLayoutParams());\n        mScrollView.setCallbacks(mScrollCallbacks);\n        mScrollView.setFillViewport(true);\n    }\n}\n```\n\n每当ObservaleScrollView触发`onScrollChanged()`时，ParallaxScrollView都调用\n`requestLayout()`\n\n```\nprivate final ScrollCallbacks mScrollCallbacks = new ScrollCallbacks() {\n   @Override\n   public void onScrollChanged(int l, int t, int oldl, int oldt) {\n       requestLayout();\n    }\n};\n```\n\n接着就是最重要的`onMeasure()`和`onLayout()`函数了,他们分别计算出前景和后景的宽和高，以及每次调用`requestLayout()`时,`onLayout()`函数将视图放置在正确的位置上。首先看看`onMeasure()`函数做了什么事情：\n\n```\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    if (mScrollView != null) {\n      \tmeasureChild(mScrollView,\n       \t\tMeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.AT_MOST),\n           MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.AT_MOST));\n        mScrollContentHeight = mScrollView.getChildAt(0).getMeasuredHeight();\n        mScrollViewHeight = mScrollView.getMeasuredHeight();\n    }\n    if (mBackground != null) {\n        int minHeight = 0;\n        minHeight = (int) (mScrollViewHeight +\n                mParallaxOffset * (mScrollContentHeight - mScrollViewHeight));\n        minHeight = Math.max(minHeight, MeasureSpec.getSize(heightMeasureSpec));\n        measureChild(mBackground,\n            MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY),\n            MeasureSpec.makeMeasureSpec(minHeight, MeasureSpec.EXACTLY));\n        mBackgroundRight = getLeft() + mBackground.getMeasuredWidth();\n        mBackgroundBottom = getTop() + mBackground.getMeasuredHeight();\n        mScrollDiff = (float) (mBackground.getMeasuredHeight() - mScrollViewHeight)/(float) (mScrollContentHeight - mScrollViewHeight);\n    }\n}\n```\n通过调用`measureChild()`函数，我们就可以从`getMeasureHeight()`函数得到被计算之后的视图的高度。计算背景的minHeight时，使用了`Math.max()`进行了一次比较，这是因为有可能我们提供的背景原图的高度比拉伸后的背景还要高，这时候就需要选一个高度数值比较大的minHeight了。\n\n`mParallaxOffset`是对背景图片拉伸比例的变量，默认值为0.2f。`mScrollDiff`就是前景和后景的滑动比了。\n\n```\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    final int parentLeft = getPaddingLeft();\n    final int parentRight = right - left - getPaddingRight();\n    final int parentTop = getPaddingTop();\n    final int parentBottom = bottom - top - getPaddingBottom();\n    if (mScrollView != null && mScrollView.getVisibility() != GONE) {\n    \tfinal int width = mScrollView.getMeasuredWidth();\n        final int height = mScrollView.getMeasuredHeight();\n        int childLeft=0;\n        int childTop=0;\n        //暂时省略gravity参数\n        mScrollView.layout(childLeft, childTop, childLeft + width, childTop + height);\n    }\n    if (mBackground != null) {\n        final int scrollYCenterOffset = -mScrollView.getScrollY();\n        final int offset = (int) (scrollYCenterOffset * mScrollDiff);\n        mBackground.layout(getLeft(), offset, mBackgroundRight, offset + mBackgroundBottom);\n    }\n}\n```\n\n至此所有要点都介绍完毕，你可以从[Github:ParallaxScrollView](https://github.com/chrisjenx/ParallaxScrollView)这个项目下载到全部详细的源码。\n","source":"_posts/2013-05-22-parallaxscrollview.md","raw":"---\ncategory: Android\ndate: 2013-05-22\nlayout: post\ntitle: Android中制作有景深视差的ScrollView\n---\n\n<img src=\"http://pic.yupoo.com/wsyanligang_v/CSz7cQTh/UZ5XO.png\" width=330 />\n\n首先我们需要创建一个类继承ViewGroup，用来包含前景(ForgroundView)和后景(BackgourdView)。\n\n```\npublic class ParallaxScrollView extends ViewGroup{}\n```\n\n接着是一个继承自ScrollView的类，每当`onScrollChanged()`触发时，都反馈给ParallaxScrollView。\n\n```\npublic class ObservableScrollView extends ScrollView{\n\tprivate ScrollCallbacks mCallbacks;\n\t@Override\n    protected void onScrollChanged(int l, int t, int oldl, int oldt) {\n        super.onScrollChanged(l, t, oldl, oldt);\n        if (mCallbacks != null) {\n            mCallbacks.onScrollChanged(l, t, oldl, oldt);\n        }\n    }\n    static interface ScrollCallbacks {\n        public void onScrollChanged(int l, int t, int oldl, int oldt);\n    }\n}\n```\n\n然后如何使用呢？我们需要在xml中这样定义\n\n```\n<couk.jenxsol.parallaxscrollview.views.ParallaxScrollView>\n\t<!--Background-->\n\t<ImageView\n\t    android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:gravity=\"center\"\n        android:scaleType=\"fitXY\"\n        android:src=\"...\"/>\n\t<!--Foreground-->\n\t<couk.jenxsol.parallaxscrollview.views.ObservableScrollView>\n\t\t<LinearLayout>\n\t\t</LinearLayout>\n\t<couk.jenxsol.parallaxscrollview.views.ObservableScrollView/>\n</couk.jenxsol.parallaxscrollview.views.ParallaxScrollView>\n```\n\n做到前后景视差，就需要当ScrollView滑动时，前景和后景滑动的距离不同，例如：前景正常向上滑动了10px,但是后景这时候只向上滑动3px，我们将这个变量定义为`mScrollDiff`,那么`mScrollDiff`等于0.3f。\n\n`ScrollView`的高度可以分为两部分，一个是`ScrollContentHeight`，ScrollView中包含的LinearLayout的高度，通常这个内容是很长的，一个是`ScollViewHeight`，通常就是我们屏幕的高再减去状态栏或者标题栏，即可见范围。以上我们称为前景。\n\n后景就是我们的背景了，我们需要在每当前景滚动时，就动态改变后景的布局。\n\n那我们就一步步解析如果做到前后景视差的ScrollView吧，首先在ParallaxScrollView完成布局填充后，我们完成一些初始化工作:\n\n```\nprotected void onFinishInflate() {\n    super.onFinishInflate();\n    if (getChildCount() > 2) {\n        throw new IllegalStateException(\"ParallaxScrollView can host only two direct children\");\n    }\n    organiseViews();\n}\n```\n\n作者考虑到了如果开发者没有按照使用说明来编写xml的话的一些意外情况，我们现在暂时忽略。\n\n```\nprivate void organiseViews() {\n    if (getChildCount() <= 0)\n        return;\n   // 将第一个子元素作为背景，第二个子元素作为前景\n       final View background = getChildAt(0);\n       final View foreground = getChildAt(1);\n       organiseBackgroundView(background);\n       organiseForgroundView(foreground);\n    }\nprivate void organiseBackgroundView(final View background) {\n    mBackground = background;\n}\nprivate void organiseForgroundView(final View forground) {\n\t…\n    mScrollView = (ObservableScrollView) forground;\n\t…\n    if (mScrollView != null) {\n        mScrollView.setLayoutParams(forground.getLayoutParams());\n        mScrollView.setCallbacks(mScrollCallbacks);\n        mScrollView.setFillViewport(true);\n    }\n}\n```\n\n每当ObservaleScrollView触发`onScrollChanged()`时，ParallaxScrollView都调用\n`requestLayout()`\n\n```\nprivate final ScrollCallbacks mScrollCallbacks = new ScrollCallbacks() {\n   @Override\n   public void onScrollChanged(int l, int t, int oldl, int oldt) {\n       requestLayout();\n    }\n};\n```\n\n接着就是最重要的`onMeasure()`和`onLayout()`函数了,他们分别计算出前景和后景的宽和高，以及每次调用`requestLayout()`时,`onLayout()`函数将视图放置在正确的位置上。首先看看`onMeasure()`函数做了什么事情：\n\n```\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    if (mScrollView != null) {\n      \tmeasureChild(mScrollView,\n       \t\tMeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.AT_MOST),\n           MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.AT_MOST));\n        mScrollContentHeight = mScrollView.getChildAt(0).getMeasuredHeight();\n        mScrollViewHeight = mScrollView.getMeasuredHeight();\n    }\n    if (mBackground != null) {\n        int minHeight = 0;\n        minHeight = (int) (mScrollViewHeight +\n                mParallaxOffset * (mScrollContentHeight - mScrollViewHeight));\n        minHeight = Math.max(minHeight, MeasureSpec.getSize(heightMeasureSpec));\n        measureChild(mBackground,\n            MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY),\n            MeasureSpec.makeMeasureSpec(minHeight, MeasureSpec.EXACTLY));\n        mBackgroundRight = getLeft() + mBackground.getMeasuredWidth();\n        mBackgroundBottom = getTop() + mBackground.getMeasuredHeight();\n        mScrollDiff = (float) (mBackground.getMeasuredHeight() - mScrollViewHeight)/(float) (mScrollContentHeight - mScrollViewHeight);\n    }\n}\n```\n通过调用`measureChild()`函数，我们就可以从`getMeasureHeight()`函数得到被计算之后的视图的高度。计算背景的minHeight时，使用了`Math.max()`进行了一次比较，这是因为有可能我们提供的背景原图的高度比拉伸后的背景还要高，这时候就需要选一个高度数值比较大的minHeight了。\n\n`mParallaxOffset`是对背景图片拉伸比例的变量，默认值为0.2f。`mScrollDiff`就是前景和后景的滑动比了。\n\n```\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    final int parentLeft = getPaddingLeft();\n    final int parentRight = right - left - getPaddingRight();\n    final int parentTop = getPaddingTop();\n    final int parentBottom = bottom - top - getPaddingBottom();\n    if (mScrollView != null && mScrollView.getVisibility() != GONE) {\n    \tfinal int width = mScrollView.getMeasuredWidth();\n        final int height = mScrollView.getMeasuredHeight();\n        int childLeft=0;\n        int childTop=0;\n        //暂时省略gravity参数\n        mScrollView.layout(childLeft, childTop, childLeft + width, childTop + height);\n    }\n    if (mBackground != null) {\n        final int scrollYCenterOffset = -mScrollView.getScrollY();\n        final int offset = (int) (scrollYCenterOffset * mScrollDiff);\n        mBackground.layout(getLeft(), offset, mBackgroundRight, offset + mBackgroundBottom);\n    }\n}\n```\n\n至此所有要点都介绍完毕，你可以从[Github:ParallaxScrollView](https://github.com/chrisjenx/ParallaxScrollView)这个项目下载到全部详细的源码。\n","slug":"2013-05-22-parallaxscrollview","published":1,"updated":"2018-02-14T21:36:14.833Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlj000orpfyarrfsn9s","content":"<p><img src=\"http://pic.yupoo.com/wsyanligang_v/CSz7cQTh/UZ5XO.png\" width=\"330\"></p>\n<p>首先我们需要创建一个类继承ViewGroup，用来包含前景(ForgroundView)和后景(BackgourdView)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ParallaxScrollView extends ViewGroup&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接着是一个继承自ScrollView的类，每当<code>onScrollChanged()</code>触发时，都反馈给ParallaxScrollView。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ObservableScrollView extends ScrollView&#123;</span><br><span class=\"line\">\tprivate ScrollCallbacks mCallbacks;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">    protected void onScrollChanged(int l, int t, int oldl, int oldt) &#123;</span><br><span class=\"line\">        super.onScrollChanged(l, t, oldl, oldt);</span><br><span class=\"line\">        if (mCallbacks != null) &#123;</span><br><span class=\"line\">            mCallbacks.onScrollChanged(l, t, oldl, oldt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static interface ScrollCallbacks &#123;</span><br><span class=\"line\">        public void onScrollChanged(int l, int t, int oldl, int oldt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后如何使用呢？我们需要在xml中这样定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;couk.jenxsol.parallaxscrollview.views.ParallaxScrollView&gt;</span><br><span class=\"line\">\t&lt;!--Background--&gt;</span><br><span class=\"line\">\t&lt;ImageView</span><br><span class=\"line\">\t    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">        android:gravity=&quot;center&quot;</span><br><span class=\"line\">        android:scaleType=&quot;fitXY&quot;</span><br><span class=\"line\">        android:src=&quot;...&quot;/&gt;</span><br><span class=\"line\">\t&lt;!--Foreground--&gt;</span><br><span class=\"line\">\t&lt;couk.jenxsol.parallaxscrollview.views.ObservableScrollView&gt;</span><br><span class=\"line\">\t\t&lt;LinearLayout&gt;</span><br><span class=\"line\">\t\t&lt;/LinearLayout&gt;</span><br><span class=\"line\">\t&lt;couk.jenxsol.parallaxscrollview.views.ObservableScrollView/&gt;</span><br><span class=\"line\">&lt;/couk.jenxsol.parallaxscrollview.views.ParallaxScrollView&gt;</span><br></pre></td></tr></table></figure>\n<p>做到前后景视差，就需要当ScrollView滑动时，前景和后景滑动的距离不同，例如：前景正常向上滑动了10px,但是后景这时候只向上滑动3px，我们将这个变量定义为<code>mScrollDiff</code>,那么<code>mScrollDiff</code>等于0.3f。</p>\n<p><code>ScrollView</code>的高度可以分为两部分，一个是<code>ScrollContentHeight</code>，ScrollView中包含的LinearLayout的高度，通常这个内容是很长的，一个是<code>ScollViewHeight</code>，通常就是我们屏幕的高再减去状态栏或者标题栏，即可见范围。以上我们称为前景。</p>\n<p>后景就是我们的背景了，我们需要在每当前景滚动时，就动态改变后景的布局。</p>\n<p>那我们就一步步解析如果做到前后景视差的ScrollView吧，首先在ParallaxScrollView完成布局填充后，我们完成一些初始化工作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onFinishInflate() &#123;</span><br><span class=\"line\">    super.onFinishInflate();</span><br><span class=\"line\">    if (getChildCount() &gt; 2) &#123;</span><br><span class=\"line\">        throw new IllegalStateException(&quot;ParallaxScrollView can host only two direct children&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    organiseViews();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>作者考虑到了如果开发者没有按照使用说明来编写xml的话的一些意外情况，我们现在暂时忽略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void organiseViews() &#123;</span><br><span class=\"line\">    if (getChildCount() &lt;= 0)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">   // 将第一个子元素作为背景，第二个子元素作为前景</span><br><span class=\"line\">       final View background = getChildAt(0);</span><br><span class=\"line\">       final View foreground = getChildAt(1);</span><br><span class=\"line\">       organiseBackgroundView(background);</span><br><span class=\"line\">       organiseForgroundView(foreground);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private void organiseBackgroundView(final View background) &#123;</span><br><span class=\"line\">    mBackground = background;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private void organiseForgroundView(final View forground) &#123;</span><br><span class=\"line\">\t…</span><br><span class=\"line\">    mScrollView = (ObservableScrollView) forground;</span><br><span class=\"line\">\t…</span><br><span class=\"line\">    if (mScrollView != null) &#123;</span><br><span class=\"line\">        mScrollView.setLayoutParams(forground.getLayoutParams());</span><br><span class=\"line\">        mScrollView.setCallbacks(mScrollCallbacks);</span><br><span class=\"line\">        mScrollView.setFillViewport(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每当ObservaleScrollView触发<code>onScrollChanged()</code>时，ParallaxScrollView都调用<br><code>requestLayout()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final ScrollCallbacks mScrollCallbacks = new ScrollCallbacks() &#123;</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   public void onScrollChanged(int l, int t, int oldl, int oldt) &#123;</span><br><span class=\"line\">       requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>接着就是最重要的<code>onMeasure()</code>和<code>onLayout()</code>函数了,他们分别计算出前景和后景的宽和高，以及每次调用<code>requestLayout()</code>时,<code>onLayout()</code>函数将视图放置在正确的位置上。首先看看<code>onMeasure()</code>函数做了什么事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">    if (mScrollView != null) &#123;</span><br><span class=\"line\">      \tmeasureChild(mScrollView,</span><br><span class=\"line\">       \t\tMeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.AT_MOST),</span><br><span class=\"line\">           MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.AT_MOST));</span><br><span class=\"line\">        mScrollContentHeight = mScrollView.getChildAt(0).getMeasuredHeight();</span><br><span class=\"line\">        mScrollViewHeight = mScrollView.getMeasuredHeight();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (mBackground != null) &#123;</span><br><span class=\"line\">        int minHeight = 0;</span><br><span class=\"line\">        minHeight = (int) (mScrollViewHeight +</span><br><span class=\"line\">                mParallaxOffset * (mScrollContentHeight - mScrollViewHeight));</span><br><span class=\"line\">        minHeight = Math.max(minHeight, MeasureSpec.getSize(heightMeasureSpec));</span><br><span class=\"line\">        measureChild(mBackground,</span><br><span class=\"line\">            MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY),</span><br><span class=\"line\">            MeasureSpec.makeMeasureSpec(minHeight, MeasureSpec.EXACTLY));</span><br><span class=\"line\">        mBackgroundRight = getLeft() + mBackground.getMeasuredWidth();</span><br><span class=\"line\">        mBackgroundBottom = getTop() + mBackground.getMeasuredHeight();</span><br><span class=\"line\">        mScrollDiff = (float) (mBackground.getMeasuredHeight() - mScrollViewHeight)/(float) (mScrollContentHeight - mScrollViewHeight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过调用<code>measureChild()</code>函数，我们就可以从<code>getMeasureHeight()</code>函数得到被计算之后的视图的高度。计算背景的minHeight时，使用了<code>Math.max()</code>进行了一次比较，这是因为有可能我们提供的背景原图的高度比拉伸后的背景还要高，这时候就需要选一个高度数值比较大的minHeight了。</p>\n<p><code>mParallaxOffset</code>是对背景图片拉伸比例的变量，默认值为0.2f。<code>mScrollDiff</code>就是前景和后景的滑动比了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class=\"line\">    final int parentLeft = getPaddingLeft();</span><br><span class=\"line\">    final int parentRight = right - left - getPaddingRight();</span><br><span class=\"line\">    final int parentTop = getPaddingTop();</span><br><span class=\"line\">    final int parentBottom = bottom - top - getPaddingBottom();</span><br><span class=\"line\">    if (mScrollView != null &amp;&amp; mScrollView.getVisibility() != GONE) &#123;</span><br><span class=\"line\">    \tfinal int width = mScrollView.getMeasuredWidth();</span><br><span class=\"line\">        final int height = mScrollView.getMeasuredHeight();</span><br><span class=\"line\">        int childLeft=0;</span><br><span class=\"line\">        int childTop=0;</span><br><span class=\"line\">        //暂时省略gravity参数</span><br><span class=\"line\">        mScrollView.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (mBackground != null) &#123;</span><br><span class=\"line\">        final int scrollYCenterOffset = -mScrollView.getScrollY();</span><br><span class=\"line\">        final int offset = (int) (scrollYCenterOffset * mScrollDiff);</span><br><span class=\"line\">        mBackground.layout(getLeft(), offset, mBackgroundRight, offset + mBackgroundBottom);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此所有要点都介绍完毕，你可以从<a href=\"https://github.com/chrisjenx/ParallaxScrollView\" target=\"_blank\" rel=\"noopener\">Github:ParallaxScrollView</a>这个项目下载到全部详细的源码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.yupoo.com/wsyanligang_v/CSz7cQTh/UZ5XO.png\" width=\"330\"></p>\n<p>首先我们需要创建一个类继承ViewGroup，用来包含前景(ForgroundView)和后景(BackgourdView)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ParallaxScrollView extends ViewGroup&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接着是一个继承自ScrollView的类，每当<code>onScrollChanged()</code>触发时，都反馈给ParallaxScrollView。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ObservableScrollView extends ScrollView&#123;</span><br><span class=\"line\">\tprivate ScrollCallbacks mCallbacks;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">    protected void onScrollChanged(int l, int t, int oldl, int oldt) &#123;</span><br><span class=\"line\">        super.onScrollChanged(l, t, oldl, oldt);</span><br><span class=\"line\">        if (mCallbacks != null) &#123;</span><br><span class=\"line\">            mCallbacks.onScrollChanged(l, t, oldl, oldt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static interface ScrollCallbacks &#123;</span><br><span class=\"line\">        public void onScrollChanged(int l, int t, int oldl, int oldt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后如何使用呢？我们需要在xml中这样定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;couk.jenxsol.parallaxscrollview.views.ParallaxScrollView&gt;</span><br><span class=\"line\">\t&lt;!--Background--&gt;</span><br><span class=\"line\">\t&lt;ImageView</span><br><span class=\"line\">\t    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">        android:gravity=&quot;center&quot;</span><br><span class=\"line\">        android:scaleType=&quot;fitXY&quot;</span><br><span class=\"line\">        android:src=&quot;...&quot;/&gt;</span><br><span class=\"line\">\t&lt;!--Foreground--&gt;</span><br><span class=\"line\">\t&lt;couk.jenxsol.parallaxscrollview.views.ObservableScrollView&gt;</span><br><span class=\"line\">\t\t&lt;LinearLayout&gt;</span><br><span class=\"line\">\t\t&lt;/LinearLayout&gt;</span><br><span class=\"line\">\t&lt;couk.jenxsol.parallaxscrollview.views.ObservableScrollView/&gt;</span><br><span class=\"line\">&lt;/couk.jenxsol.parallaxscrollview.views.ParallaxScrollView&gt;</span><br></pre></td></tr></table></figure>\n<p>做到前后景视差，就需要当ScrollView滑动时，前景和后景滑动的距离不同，例如：前景正常向上滑动了10px,但是后景这时候只向上滑动3px，我们将这个变量定义为<code>mScrollDiff</code>,那么<code>mScrollDiff</code>等于0.3f。</p>\n<p><code>ScrollView</code>的高度可以分为两部分，一个是<code>ScrollContentHeight</code>，ScrollView中包含的LinearLayout的高度，通常这个内容是很长的，一个是<code>ScollViewHeight</code>，通常就是我们屏幕的高再减去状态栏或者标题栏，即可见范围。以上我们称为前景。</p>\n<p>后景就是我们的背景了，我们需要在每当前景滚动时，就动态改变后景的布局。</p>\n<p>那我们就一步步解析如果做到前后景视差的ScrollView吧，首先在ParallaxScrollView完成布局填充后，我们完成一些初始化工作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onFinishInflate() &#123;</span><br><span class=\"line\">    super.onFinishInflate();</span><br><span class=\"line\">    if (getChildCount() &gt; 2) &#123;</span><br><span class=\"line\">        throw new IllegalStateException(&quot;ParallaxScrollView can host only two direct children&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    organiseViews();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>作者考虑到了如果开发者没有按照使用说明来编写xml的话的一些意外情况，我们现在暂时忽略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void organiseViews() &#123;</span><br><span class=\"line\">    if (getChildCount() &lt;= 0)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">   // 将第一个子元素作为背景，第二个子元素作为前景</span><br><span class=\"line\">       final View background = getChildAt(0);</span><br><span class=\"line\">       final View foreground = getChildAt(1);</span><br><span class=\"line\">       organiseBackgroundView(background);</span><br><span class=\"line\">       organiseForgroundView(foreground);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private void organiseBackgroundView(final View background) &#123;</span><br><span class=\"line\">    mBackground = background;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private void organiseForgroundView(final View forground) &#123;</span><br><span class=\"line\">\t…</span><br><span class=\"line\">    mScrollView = (ObservableScrollView) forground;</span><br><span class=\"line\">\t…</span><br><span class=\"line\">    if (mScrollView != null) &#123;</span><br><span class=\"line\">        mScrollView.setLayoutParams(forground.getLayoutParams());</span><br><span class=\"line\">        mScrollView.setCallbacks(mScrollCallbacks);</span><br><span class=\"line\">        mScrollView.setFillViewport(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每当ObservaleScrollView触发<code>onScrollChanged()</code>时，ParallaxScrollView都调用<br><code>requestLayout()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final ScrollCallbacks mScrollCallbacks = new ScrollCallbacks() &#123;</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   public void onScrollChanged(int l, int t, int oldl, int oldt) &#123;</span><br><span class=\"line\">       requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>接着就是最重要的<code>onMeasure()</code>和<code>onLayout()</code>函数了,他们分别计算出前景和后景的宽和高，以及每次调用<code>requestLayout()</code>时,<code>onLayout()</code>函数将视图放置在正确的位置上。首先看看<code>onMeasure()</code>函数做了什么事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">    if (mScrollView != null) &#123;</span><br><span class=\"line\">      \tmeasureChild(mScrollView,</span><br><span class=\"line\">       \t\tMeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.AT_MOST),</span><br><span class=\"line\">           MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.AT_MOST));</span><br><span class=\"line\">        mScrollContentHeight = mScrollView.getChildAt(0).getMeasuredHeight();</span><br><span class=\"line\">        mScrollViewHeight = mScrollView.getMeasuredHeight();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (mBackground != null) &#123;</span><br><span class=\"line\">        int minHeight = 0;</span><br><span class=\"line\">        minHeight = (int) (mScrollViewHeight +</span><br><span class=\"line\">                mParallaxOffset * (mScrollContentHeight - mScrollViewHeight));</span><br><span class=\"line\">        minHeight = Math.max(minHeight, MeasureSpec.getSize(heightMeasureSpec));</span><br><span class=\"line\">        measureChild(mBackground,</span><br><span class=\"line\">            MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY),</span><br><span class=\"line\">            MeasureSpec.makeMeasureSpec(minHeight, MeasureSpec.EXACTLY));</span><br><span class=\"line\">        mBackgroundRight = getLeft() + mBackground.getMeasuredWidth();</span><br><span class=\"line\">        mBackgroundBottom = getTop() + mBackground.getMeasuredHeight();</span><br><span class=\"line\">        mScrollDiff = (float) (mBackground.getMeasuredHeight() - mScrollViewHeight)/(float) (mScrollContentHeight - mScrollViewHeight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过调用<code>measureChild()</code>函数，我们就可以从<code>getMeasureHeight()</code>函数得到被计算之后的视图的高度。计算背景的minHeight时，使用了<code>Math.max()</code>进行了一次比较，这是因为有可能我们提供的背景原图的高度比拉伸后的背景还要高，这时候就需要选一个高度数值比较大的minHeight了。</p>\n<p><code>mParallaxOffset</code>是对背景图片拉伸比例的变量，默认值为0.2f。<code>mScrollDiff</code>就是前景和后景的滑动比了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class=\"line\">    final int parentLeft = getPaddingLeft();</span><br><span class=\"line\">    final int parentRight = right - left - getPaddingRight();</span><br><span class=\"line\">    final int parentTop = getPaddingTop();</span><br><span class=\"line\">    final int parentBottom = bottom - top - getPaddingBottom();</span><br><span class=\"line\">    if (mScrollView != null &amp;&amp; mScrollView.getVisibility() != GONE) &#123;</span><br><span class=\"line\">    \tfinal int width = mScrollView.getMeasuredWidth();</span><br><span class=\"line\">        final int height = mScrollView.getMeasuredHeight();</span><br><span class=\"line\">        int childLeft=0;</span><br><span class=\"line\">        int childTop=0;</span><br><span class=\"line\">        //暂时省略gravity参数</span><br><span class=\"line\">        mScrollView.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (mBackground != null) &#123;</span><br><span class=\"line\">        final int scrollYCenterOffset = -mScrollView.getScrollY();</span><br><span class=\"line\">        final int offset = (int) (scrollYCenterOffset * mScrollDiff);</span><br><span class=\"line\">        mBackground.layout(getLeft(), offset, mBackgroundRight, offset + mBackgroundBottom);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此所有要点都介绍完毕，你可以从<a href=\"https://github.com/chrisjenx/ParallaxScrollView\" target=\"_blank\" rel=\"noopener\">Github:ParallaxScrollView</a>这个项目下载到全部详细的源码。</p>\n"},{"date":"2013-05-30T16:00:00.000Z","layout":"post","title":"Java并发之CyclicBarrier","_content":"书摘：\n\n`CyclicBarrier`适用于这样的情况：你希望创建一组任务,他们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成(看起来有些像join())。 它使得所有的并行任务都将在栅栏处列队，因此可以一致地向钱移动。这非常像CountDownLatch,只是CountDownLatch是只触发一次的事件，而CyclicBarrier可以多次重用。\n\n刚开始接触计算机时开始，我就对仿真着了迷，而并发是使仿真成为可能的一个关键因素。记得我最开始编写的一个程序就是一个仿真：一个用BASIC编写的（由于文件名的限制而命名为HOSRAC.BAS的赛马游戏）。下面是那个程序的面向对象的多线程版本，其中使用了`CyclicBarrier`：\n\n```\npackage cn.link.example;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.*;\n\nclass Horse implements Runnable {\n    private static int counter = 0;\n    private final int id = counter++;\n    private int strides = 0;\n    private static Random rand = new Random(47);\n    private static CyclicBarrier barrier;\n\n    public Horse(CyclicBarrier b) {\n        barrier = b;\n    }\n\n    public synchronized int getStrides() {\n        return strides;\n    }\n\n    @Override\n    public void run() {\n        //ToDo\n        while (!Thread.interrupted()) {\n            synchronized (this) {\n                strides += rand.nextInt(3);\n            }\n            try {\n                barrier.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n            }\n\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"Horse \" + id + \" \";\n    }\n\n    public String tracks() {\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < getStrides(); i++) {\n            s.append(\"*\");\n        }\n        s.append(id);\n        return s.toString();\n    }\n}\n\npublic class HorseRace {\n    static final int FINISH_LINE = 80;\n    private List<Horse> horses = new ArrayList<Horse>();\n    private ExecutorService exec = Executors.newCachedThreadPool();\n    private CyclicBarrier barrier;\n\n    public HorseRace(int nHorses, final int pause) {\n        barrier = new CyclicBarrier(nHorses, new Runnable() {\n            @Override\n            public void run() {\n                //ToDo\n                StringBuilder s = new StringBuilder();\n                for (int i = 0; i < FINISH_LINE; i++) {\n                    s.append(\"=\");\n                }\n                System.out.println(s);\n                for (Horse horse : horses) {\n                    System.out.println(horse.tracks());\n                }\n\n                for (Horse horse : horses) {\n                    if (horse.getStrides() >= FINISH_LINE) {\n                        System.out.println(horse + \"won!\");\n                        exec.shutdownNow();\n                        return;\n                    }\n                }\n\n                try {\n                    TimeUnit.MILLISECONDS.sleep(pause);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n                }\n\n            }\n        });\n\n        for (int i = 0; i < nHorses; i++) {\n            Horse horse = new Horse(barrier);\n            horses.add(horse);\n            exec.execute(horse);\n        }\n    }\n\n    public static void main(String[] args) {\n        int nHorses = 7;\n        int pause = 200;\n\n//        if (args.length > 0) {\n//            int n = new Integer(args[0]);\n//            nHorses = n > 0 ? n : nHorses;\n//        }\n        new HorseRace(nHorses, pause);\n\n    }\n}\n```\n\n可以向CyclicBarrier提供一个“栅栏动作”，他是一个Runnable,当计数值到达0时自动执行--这是CyclicBarrier和CountDownLatch之间的另一个区别。这里，栅栏动作是作为匿名内部类创建的，它被提交给了CyclicBarrier的构造器。\n\n我试图让每匹马都打印自己，但是之后的显示顺序取决于任务管理器。CyclicBarrier使得每匹马都要执行为了向前移动所必需执行的所有工作，然后必须在栅栏处等待其他所有的马都准备完毕。当所有的马都向前移动时，CyclicBarrier将自动调用Runnable栅栏动作任务，按顺序显示马和终点线的位置。\n\n一旦所有的任务都越过了栅栏，它就会自动的为下一回合的比赛做好准备。\n\n为了展示这个非常简单的动画效果，你需要将控制台视窗的尺寸调整为小到只有马时，才会展示出来。\n\n[链接:Java并发之CountDownLatch](http://linkyan.com/2013/05/countdownlatch/)\n","source":"_posts/2013-05-31-cyclicbarrier.md","raw":"---\ncategory: Android\ndate: 2013-05-31\nlayout: post\ntitle: Java并发之CyclicBarrier\n---\n书摘：\n\n`CyclicBarrier`适用于这样的情况：你希望创建一组任务,他们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成(看起来有些像join())。 它使得所有的并行任务都将在栅栏处列队，因此可以一致地向钱移动。这非常像CountDownLatch,只是CountDownLatch是只触发一次的事件，而CyclicBarrier可以多次重用。\n\n刚开始接触计算机时开始，我就对仿真着了迷，而并发是使仿真成为可能的一个关键因素。记得我最开始编写的一个程序就是一个仿真：一个用BASIC编写的（由于文件名的限制而命名为HOSRAC.BAS的赛马游戏）。下面是那个程序的面向对象的多线程版本，其中使用了`CyclicBarrier`：\n\n```\npackage cn.link.example;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.*;\n\nclass Horse implements Runnable {\n    private static int counter = 0;\n    private final int id = counter++;\n    private int strides = 0;\n    private static Random rand = new Random(47);\n    private static CyclicBarrier barrier;\n\n    public Horse(CyclicBarrier b) {\n        barrier = b;\n    }\n\n    public synchronized int getStrides() {\n        return strides;\n    }\n\n    @Override\n    public void run() {\n        //ToDo\n        while (!Thread.interrupted()) {\n            synchronized (this) {\n                strides += rand.nextInt(3);\n            }\n            try {\n                barrier.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n            }\n\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"Horse \" + id + \" \";\n    }\n\n    public String tracks() {\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < getStrides(); i++) {\n            s.append(\"*\");\n        }\n        s.append(id);\n        return s.toString();\n    }\n}\n\npublic class HorseRace {\n    static final int FINISH_LINE = 80;\n    private List<Horse> horses = new ArrayList<Horse>();\n    private ExecutorService exec = Executors.newCachedThreadPool();\n    private CyclicBarrier barrier;\n\n    public HorseRace(int nHorses, final int pause) {\n        barrier = new CyclicBarrier(nHorses, new Runnable() {\n            @Override\n            public void run() {\n                //ToDo\n                StringBuilder s = new StringBuilder();\n                for (int i = 0; i < FINISH_LINE; i++) {\n                    s.append(\"=\");\n                }\n                System.out.println(s);\n                for (Horse horse : horses) {\n                    System.out.println(horse.tracks());\n                }\n\n                for (Horse horse : horses) {\n                    if (horse.getStrides() >= FINISH_LINE) {\n                        System.out.println(horse + \"won!\");\n                        exec.shutdownNow();\n                        return;\n                    }\n                }\n\n                try {\n                    TimeUnit.MILLISECONDS.sleep(pause);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n                }\n\n            }\n        });\n\n        for (int i = 0; i < nHorses; i++) {\n            Horse horse = new Horse(barrier);\n            horses.add(horse);\n            exec.execute(horse);\n        }\n    }\n\n    public static void main(String[] args) {\n        int nHorses = 7;\n        int pause = 200;\n\n//        if (args.length > 0) {\n//            int n = new Integer(args[0]);\n//            nHorses = n > 0 ? n : nHorses;\n//        }\n        new HorseRace(nHorses, pause);\n\n    }\n}\n```\n\n可以向CyclicBarrier提供一个“栅栏动作”，他是一个Runnable,当计数值到达0时自动执行--这是CyclicBarrier和CountDownLatch之间的另一个区别。这里，栅栏动作是作为匿名内部类创建的，它被提交给了CyclicBarrier的构造器。\n\n我试图让每匹马都打印自己，但是之后的显示顺序取决于任务管理器。CyclicBarrier使得每匹马都要执行为了向前移动所必需执行的所有工作，然后必须在栅栏处等待其他所有的马都准备完毕。当所有的马都向前移动时，CyclicBarrier将自动调用Runnable栅栏动作任务，按顺序显示马和终点线的位置。\n\n一旦所有的任务都越过了栅栏，它就会自动的为下一回合的比赛做好准备。\n\n为了展示这个非常简单的动画效果，你需要将控制台视窗的尺寸调整为小到只有马时，才会展示出来。\n\n[链接:Java并发之CountDownLatch](http://linkyan.com/2013/05/countdownlatch/)\n","slug":"2013-05-31-cyclicbarrier","published":1,"updated":"2018-02-14T21:36:14.833Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tll000qrpfyczwvp4vt","content":"<p>书摘：</p>\n<p><code>CyclicBarrier</code>适用于这样的情况：你希望创建一组任务,他们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成(看起来有些像join())。 它使得所有的并行任务都将在栅栏处列队，因此可以一致地向钱移动。这非常像CountDownLatch,只是CountDownLatch是只触发一次的事件，而CyclicBarrier可以多次重用。</p>\n<p>刚开始接触计算机时开始，我就对仿真着了迷，而并发是使仿真成为可能的一个关键因素。记得我最开始编写的一个程序就是一个仿真：一个用BASIC编写的（由于文件名的限制而命名为HOSRAC.BAS的赛马游戏）。下面是那个程序的面向对象的多线程版本，其中使用了<code>CyclicBarrier</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.link.example;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\">import java.util.Random;</span><br><span class=\"line\">import java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\">class Horse implements Runnable &#123;</span><br><span class=\"line\">    private static int counter = 0;</span><br><span class=\"line\">    private final int id = counter++;</span><br><span class=\"line\">    private int strides = 0;</span><br><span class=\"line\">    private static Random rand = new Random(47);</span><br><span class=\"line\">    private static CyclicBarrier barrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Horse(CyclicBarrier b) &#123;</span><br><span class=\"line\">        barrier = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized int getStrides() &#123;</span><br><span class=\"line\">        return strides;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        while (!Thread.interrupted()) &#123;</span><br><span class=\"line\">            synchronized (this) &#123;</span><br><span class=\"line\">                strides += rand.nextInt(3);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                barrier.await();</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.</span><br><span class=\"line\">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Horse &quot; + id + &quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String tracks() &#123;</span><br><span class=\"line\">        StringBuilder s = new StringBuilder();</span><br><span class=\"line\">        for (int i = 0; i &lt; getStrides(); i++) &#123;</span><br><span class=\"line\">            s.append(&quot;*&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.append(id);</span><br><span class=\"line\">        return s.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class HorseRace &#123;</span><br><span class=\"line\">    static final int FINISH_LINE = 80;</span><br><span class=\"line\">    private List&lt;Horse&gt; horses = new ArrayList&lt;Horse&gt;();</span><br><span class=\"line\">    private ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">    private CyclicBarrier barrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    public HorseRace(int nHorses, final int pause) &#123;</span><br><span class=\"line\">        barrier = new CyclicBarrier(nHorses, new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                //ToDo</span><br><span class=\"line\">                StringBuilder s = new StringBuilder();</span><br><span class=\"line\">                for (int i = 0; i &lt; FINISH_LINE; i++) &#123;</span><br><span class=\"line\">                    s.append(&quot;=&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(s);</span><br><span class=\"line\">                for (Horse horse : horses) &#123;</span><br><span class=\"line\">                    System.out.println(horse.tracks());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                for (Horse horse : horses) &#123;</span><br><span class=\"line\">                    if (horse.getStrides() &gt;= FINISH_LINE) &#123;</span><br><span class=\"line\">                        System.out.println(horse + &quot;won!&quot;);</span><br><span class=\"line\">                        exec.shutdownNow();</span><br><span class=\"line\">                        return;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(pause);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; nHorses; i++) &#123;</span><br><span class=\"line\">            Horse horse = new Horse(barrier);</span><br><span class=\"line\">            horses.add(horse);</span><br><span class=\"line\">            exec.execute(horse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int nHorses = 7;</span><br><span class=\"line\">        int pause = 200;</span><br><span class=\"line\"></span><br><span class=\"line\">//        if (args.length &gt; 0) &#123;</span><br><span class=\"line\">//            int n = new Integer(args[0]);</span><br><span class=\"line\">//            nHorses = n &gt; 0 ? n : nHorses;</span><br><span class=\"line\">//        &#125;</span><br><span class=\"line\">        new HorseRace(nHorses, pause);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以向CyclicBarrier提供一个“栅栏动作”，他是一个Runnable,当计数值到达0时自动执行–这是CyclicBarrier和CountDownLatch之间的另一个区别。这里，栅栏动作是作为匿名内部类创建的，它被提交给了CyclicBarrier的构造器。</p>\n<p>我试图让每匹马都打印自己，但是之后的显示顺序取决于任务管理器。CyclicBarrier使得每匹马都要执行为了向前移动所必需执行的所有工作，然后必须在栅栏处等待其他所有的马都准备完毕。当所有的马都向前移动时，CyclicBarrier将自动调用Runnable栅栏动作任务，按顺序显示马和终点线的位置。</p>\n<p>一旦所有的任务都越过了栅栏，它就会自动的为下一回合的比赛做好准备。</p>\n<p>为了展示这个非常简单的动画效果，你需要将控制台视窗的尺寸调整为小到只有马时，才会展示出来。</p>\n<p><a href=\"http://linkyan.com/2013/05/countdownlatch/\" target=\"_blank\" rel=\"noopener\">链接:Java并发之CountDownLatch</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>书摘：</p>\n<p><code>CyclicBarrier</code>适用于这样的情况：你希望创建一组任务,他们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成(看起来有些像join())。 它使得所有的并行任务都将在栅栏处列队，因此可以一致地向钱移动。这非常像CountDownLatch,只是CountDownLatch是只触发一次的事件，而CyclicBarrier可以多次重用。</p>\n<p>刚开始接触计算机时开始，我就对仿真着了迷，而并发是使仿真成为可能的一个关键因素。记得我最开始编写的一个程序就是一个仿真：一个用BASIC编写的（由于文件名的限制而命名为HOSRAC.BAS的赛马游戏）。下面是那个程序的面向对象的多线程版本，其中使用了<code>CyclicBarrier</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.link.example;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\">import java.util.Random;</span><br><span class=\"line\">import java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\">class Horse implements Runnable &#123;</span><br><span class=\"line\">    private static int counter = 0;</span><br><span class=\"line\">    private final int id = counter++;</span><br><span class=\"line\">    private int strides = 0;</span><br><span class=\"line\">    private static Random rand = new Random(47);</span><br><span class=\"line\">    private static CyclicBarrier barrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Horse(CyclicBarrier b) &#123;</span><br><span class=\"line\">        barrier = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized int getStrides() &#123;</span><br><span class=\"line\">        return strides;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        while (!Thread.interrupted()) &#123;</span><br><span class=\"line\">            synchronized (this) &#123;</span><br><span class=\"line\">                strides += rand.nextInt(3);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                barrier.await();</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.</span><br><span class=\"line\">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Horse &quot; + id + &quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String tracks() &#123;</span><br><span class=\"line\">        StringBuilder s = new StringBuilder();</span><br><span class=\"line\">        for (int i = 0; i &lt; getStrides(); i++) &#123;</span><br><span class=\"line\">            s.append(&quot;*&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.append(id);</span><br><span class=\"line\">        return s.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class HorseRace &#123;</span><br><span class=\"line\">    static final int FINISH_LINE = 80;</span><br><span class=\"line\">    private List&lt;Horse&gt; horses = new ArrayList&lt;Horse&gt;();</span><br><span class=\"line\">    private ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">    private CyclicBarrier barrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    public HorseRace(int nHorses, final int pause) &#123;</span><br><span class=\"line\">        barrier = new CyclicBarrier(nHorses, new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                //ToDo</span><br><span class=\"line\">                StringBuilder s = new StringBuilder();</span><br><span class=\"line\">                for (int i = 0; i &lt; FINISH_LINE; i++) &#123;</span><br><span class=\"line\">                    s.append(&quot;=&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(s);</span><br><span class=\"line\">                for (Horse horse : horses) &#123;</span><br><span class=\"line\">                    System.out.println(horse.tracks());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                for (Horse horse : horses) &#123;</span><br><span class=\"line\">                    if (horse.getStrides() &gt;= FINISH_LINE) &#123;</span><br><span class=\"line\">                        System.out.println(horse + &quot;won!&quot;);</span><br><span class=\"line\">                        exec.shutdownNow();</span><br><span class=\"line\">                        return;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(pause);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; nHorses; i++) &#123;</span><br><span class=\"line\">            Horse horse = new Horse(barrier);</span><br><span class=\"line\">            horses.add(horse);</span><br><span class=\"line\">            exec.execute(horse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int nHorses = 7;</span><br><span class=\"line\">        int pause = 200;</span><br><span class=\"line\"></span><br><span class=\"line\">//        if (args.length &gt; 0) &#123;</span><br><span class=\"line\">//            int n = new Integer(args[0]);</span><br><span class=\"line\">//            nHorses = n &gt; 0 ? n : nHorses;</span><br><span class=\"line\">//        &#125;</span><br><span class=\"line\">        new HorseRace(nHorses, pause);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以向CyclicBarrier提供一个“栅栏动作”，他是一个Runnable,当计数值到达0时自动执行–这是CyclicBarrier和CountDownLatch之间的另一个区别。这里，栅栏动作是作为匿名内部类创建的，它被提交给了CyclicBarrier的构造器。</p>\n<p>我试图让每匹马都打印自己，但是之后的显示顺序取决于任务管理器。CyclicBarrier使得每匹马都要执行为了向前移动所必需执行的所有工作，然后必须在栅栏处等待其他所有的马都准备完毕。当所有的马都向前移动时，CyclicBarrier将自动调用Runnable栅栏动作任务，按顺序显示马和终点线的位置。</p>\n<p>一旦所有的任务都越过了栅栏，它就会自动的为下一回合的比赛做好准备。</p>\n<p>为了展示这个非常简单的动画效果，你需要将控制台视窗的尺寸调整为小到只有马时，才会展示出来。</p>\n<p><a href=\"http://linkyan.com/2013/05/countdownlatch/\" target=\"_blank\" rel=\"noopener\">链接:Java并发之CountDownLatch</a></p>\n"},{"date":"2013-05-30T16:00:00.000Z","layout":"post","title":"Android框架设计之ExceptionCenter","_content":"\n##What's up?\n---\n我们可能常常遇到这样的问题：\n\n1. http请求异常很多种，我们或者将他们归类包装，或者将他们一一抛到上层去处理，通常我们的应用会有很多层，API层,Cache层，业务层，界面层等等，层次越多需要将异常抛的层就越多，最终到达界面了再根据不同的异常渲染不同的页面效果。\n2. 某些异常不单单是提示用户就可以了的，还需要处理特定的业务或者与用户进行交互的，比如某用户被禁用了我们除了提示还需要将用户登出，清理数据等。\n3. 除了去处理异常，我们还需要对得到的异常分析，保存等定制操作，在哪里做比较合适，比较优雅？\n\n## So,How to solvoe it?\n---\n我们可以将需要在界面渲染的异常，跟踪保存的异常等统统扔到 ExceptionCenter中，通过`public boolean      fileter(Exception e)`函数过滤每一个异常，进行匹配。如果返回`true` 则在`public void handleException(Context ctx,Exception e)`函数中进行对应的逻辑处理，大概如此：\n\n```\npublic abstract class LKException implements Serializable {\n\n    public abstract boolean filter(Exception e);\n\n    public abstract void handleException(Context ctx, Exception e);\n\n    public abstract void handleTargetException(Context ctx);\n\n}\n\n```\n\n`implements Serializable`是为了能在Intent中传递。\n\n`ExceptionCenter`采用继承`BroadcastReceiver`异步来处理事件，大致是这样的：\n\n```\npublic class ExceptionCenter extends BroadcastReceiver {\n\n    public static final String ACTION_EXCEPTION = \"com.huaban.exceptioncenter\";\n    public static final String EXTRA_EXCEPTION = \"exception\";\n    public static final String EXTRA_LKEXCEPTION = \"lkexception\";\n\n    private ExceptionCenterFactory mFactory;\n\n    List<Class<? extends LKException>> mClazz = new ArrayList<Class<? extends LKException>>();\n\n    public ExceptionCenter(ExceptionCenterFactory factory) {\n        super();\n        factory.onAddExceptionList(mClazz);\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        //ToDo\n        Exception exception = (Exception) intent.getSerializableExtra(EXTRA_EXCEPTION);\n        LKException lkException = (LKException) intent.getSerializableExtra(EXTRA_LKEXCEPTION);\n        if (lkException != null) {\n            lkException.handleTargetException(context);\n        } else if (exception != null) {\n            try {\n                for (Class<? extends LKException> item : mClazz) {\n                    LKException lk = item.newInstance();\n                    if (lk.filter(exception)) {\n                        lk.handleException(context, exception);\n                    }\n                }\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n可以看到`onReceive()`函数中 处理异常有两种模式，一种是不需要进行过滤判断的，直接进行handle，一种是通过循环执行`lk.filter(exception)`判断是否需要进行处理。这是考虑到了开发者可以在ExceptionCenter先在外部进行判断再传进来处理，也可以在内部进行判断同时处理。\n\n同时提供了几个类函数方便使用:\n\n```\nprivate static BroadcastReceiver mBr;\n\npublic static void start(Context ctx, ExceptionCenterFactory factory) {\n\tmBr = new ExceptionCenter(factory);\n    IntentFilter intentFilter = new IntentFilter(ACTION_EXCEPTION);\n    LocalBroadcastManager.getInstance(ctx).registerReceiver(mBr, intentFilter);\n}\n\npublic static void stop(Context ctx) {\n\tLocalBroadcastManager.getInstance(ctx).unregisterReceiver(mBr);\n    mBr = null;\n}\n\npublic static void recevieLKException(Context ctx, LKException exception) {\n    Intent intent = new Intent(ACTION_EXCEPTION);\n    intent.putExtra(EXTRA_LKEXCEPTION, exception);\n    LocalBroadcastManager.getInstance(ctx).sendBroadcast(intent);\n}\n\npublic static void recevieException(Context ctx, Exception exception) {\n    Intent intent = new Intent(ACTION_EXCEPTION);\n    intent.putExtra(EXTRA_EXCEPTION, exception);\n    LocalBroadcastManager.getInstance(ctx).sendBroadcast(intent);\n}\n```\n\n`start(Context ctx,ExceptionCenterFactroy factory)`在你的MainActivity的onCreate()中使用，\n\n`stop(context ctx)`在onDestory()中使用，因为使用了support.v4包中的[LocalBroadcatManager](http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html)类，所以这种方式比正常的BroadcastReceiver更加效率,Google原话：\n\n\n>If you don't need to send broadcasts across applications, consider using\nthis class with {@link android.support.v4.content.LocalBroadcastManager} instead\nof the more general facilities described below.  This will give you a much\nmore efficient implementation (no cross-process communication needed) and allow\nyou to avoid thinking about any security issues related to other applications\nbeing able to receive or send your broadcasts.\n\n\n`ExceptionCenterFactory`只有一个抽象函数\n\n```\npublic abstract class ExceptionCenterFactory {\n    public abstract void onAddExceptionList(List<Class<? extends LKException>> filterList);\n}\n```\n开发者将需要过滤处理的类添加到队列中。\n\n类似这中实现：\n\n```\npublic class WallpaperExceptionFactory extends ExceptionCenterFactory {\n    @Override\n    public void onAddExceptionList(List<Class<? extends LKException>> exceptionList) {\n        //ToDo\n        exceptionList.add(AccountDisableException.class);\n        exceptionList.add(LKJSONException.class);\n    }\n}\n```\n\n好的 来个简单的处理异常的类：\n\n```\npublic class AccountDisableException extends LKException {\n    private static final String ACCOUNT_DISABLE = \"account_disable\";\n\n    private String mMessage;\n\n    public AccountDisableException() {\n    }\n\n    public AccountDisableException(String msg) {\n        this.mMessage = msg;\n\n    }\n\n    @Override\n    public boolean filter(Exception e) {\n        if (e.getMessage().equals(\"account_disabled\")) {\n            return true;\n        }\n        return false;  //ToDo\n    }\n\n    @Override\n    public void handleException(Context ctx, Exception e) {\n        //ToDo\n        Toast.makeText(ctx, \"account disable \" + e.getMessage(), Toast.LENGTH_SHORT).show();\n\n    }\n\n    @Override\n    public void handleTargetException(Context ctx) {\n        //ToDo\n        Toast.makeText(ctx, \"account disable target\" + mMessage, Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n由于我们传进了`Context ctx`参数，实际上我们可以做任何有关Android的事情了。就看你怎么去做了。\n\n## Last word\n---\n多稚嫩的框架，这只是alpha版而已。慢慢来，先这么看看\n","source":"_posts/2013-05-31-exceptioncenter.md","raw":"---\ncategory: Android\ndate: 2013-05-31\nlayout: post\ntitle: Android框架设计之ExceptionCenter\n---\n\n##What's up?\n---\n我们可能常常遇到这样的问题：\n\n1. http请求异常很多种，我们或者将他们归类包装，或者将他们一一抛到上层去处理，通常我们的应用会有很多层，API层,Cache层，业务层，界面层等等，层次越多需要将异常抛的层就越多，最终到达界面了再根据不同的异常渲染不同的页面效果。\n2. 某些异常不单单是提示用户就可以了的，还需要处理特定的业务或者与用户进行交互的，比如某用户被禁用了我们除了提示还需要将用户登出，清理数据等。\n3. 除了去处理异常，我们还需要对得到的异常分析，保存等定制操作，在哪里做比较合适，比较优雅？\n\n## So,How to solvoe it?\n---\n我们可以将需要在界面渲染的异常，跟踪保存的异常等统统扔到 ExceptionCenter中，通过`public boolean      fileter(Exception e)`函数过滤每一个异常，进行匹配。如果返回`true` 则在`public void handleException(Context ctx,Exception e)`函数中进行对应的逻辑处理，大概如此：\n\n```\npublic abstract class LKException implements Serializable {\n\n    public abstract boolean filter(Exception e);\n\n    public abstract void handleException(Context ctx, Exception e);\n\n    public abstract void handleTargetException(Context ctx);\n\n}\n\n```\n\n`implements Serializable`是为了能在Intent中传递。\n\n`ExceptionCenter`采用继承`BroadcastReceiver`异步来处理事件，大致是这样的：\n\n```\npublic class ExceptionCenter extends BroadcastReceiver {\n\n    public static final String ACTION_EXCEPTION = \"com.huaban.exceptioncenter\";\n    public static final String EXTRA_EXCEPTION = \"exception\";\n    public static final String EXTRA_LKEXCEPTION = \"lkexception\";\n\n    private ExceptionCenterFactory mFactory;\n\n    List<Class<? extends LKException>> mClazz = new ArrayList<Class<? extends LKException>>();\n\n    public ExceptionCenter(ExceptionCenterFactory factory) {\n        super();\n        factory.onAddExceptionList(mClazz);\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        //ToDo\n        Exception exception = (Exception) intent.getSerializableExtra(EXTRA_EXCEPTION);\n        LKException lkException = (LKException) intent.getSerializableExtra(EXTRA_LKEXCEPTION);\n        if (lkException != null) {\n            lkException.handleTargetException(context);\n        } else if (exception != null) {\n            try {\n                for (Class<? extends LKException> item : mClazz) {\n                    LKException lk = item.newInstance();\n                    if (lk.filter(exception)) {\n                        lk.handleException(context, exception);\n                    }\n                }\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n可以看到`onReceive()`函数中 处理异常有两种模式，一种是不需要进行过滤判断的，直接进行handle，一种是通过循环执行`lk.filter(exception)`判断是否需要进行处理。这是考虑到了开发者可以在ExceptionCenter先在外部进行判断再传进来处理，也可以在内部进行判断同时处理。\n\n同时提供了几个类函数方便使用:\n\n```\nprivate static BroadcastReceiver mBr;\n\npublic static void start(Context ctx, ExceptionCenterFactory factory) {\n\tmBr = new ExceptionCenter(factory);\n    IntentFilter intentFilter = new IntentFilter(ACTION_EXCEPTION);\n    LocalBroadcastManager.getInstance(ctx).registerReceiver(mBr, intentFilter);\n}\n\npublic static void stop(Context ctx) {\n\tLocalBroadcastManager.getInstance(ctx).unregisterReceiver(mBr);\n    mBr = null;\n}\n\npublic static void recevieLKException(Context ctx, LKException exception) {\n    Intent intent = new Intent(ACTION_EXCEPTION);\n    intent.putExtra(EXTRA_LKEXCEPTION, exception);\n    LocalBroadcastManager.getInstance(ctx).sendBroadcast(intent);\n}\n\npublic static void recevieException(Context ctx, Exception exception) {\n    Intent intent = new Intent(ACTION_EXCEPTION);\n    intent.putExtra(EXTRA_EXCEPTION, exception);\n    LocalBroadcastManager.getInstance(ctx).sendBroadcast(intent);\n}\n```\n\n`start(Context ctx,ExceptionCenterFactroy factory)`在你的MainActivity的onCreate()中使用，\n\n`stop(context ctx)`在onDestory()中使用，因为使用了support.v4包中的[LocalBroadcatManager](http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html)类，所以这种方式比正常的BroadcastReceiver更加效率,Google原话：\n\n\n>If you don't need to send broadcasts across applications, consider using\nthis class with {@link android.support.v4.content.LocalBroadcastManager} instead\nof the more general facilities described below.  This will give you a much\nmore efficient implementation (no cross-process communication needed) and allow\nyou to avoid thinking about any security issues related to other applications\nbeing able to receive or send your broadcasts.\n\n\n`ExceptionCenterFactory`只有一个抽象函数\n\n```\npublic abstract class ExceptionCenterFactory {\n    public abstract void onAddExceptionList(List<Class<? extends LKException>> filterList);\n}\n```\n开发者将需要过滤处理的类添加到队列中。\n\n类似这中实现：\n\n```\npublic class WallpaperExceptionFactory extends ExceptionCenterFactory {\n    @Override\n    public void onAddExceptionList(List<Class<? extends LKException>> exceptionList) {\n        //ToDo\n        exceptionList.add(AccountDisableException.class);\n        exceptionList.add(LKJSONException.class);\n    }\n}\n```\n\n好的 来个简单的处理异常的类：\n\n```\npublic class AccountDisableException extends LKException {\n    private static final String ACCOUNT_DISABLE = \"account_disable\";\n\n    private String mMessage;\n\n    public AccountDisableException() {\n    }\n\n    public AccountDisableException(String msg) {\n        this.mMessage = msg;\n\n    }\n\n    @Override\n    public boolean filter(Exception e) {\n        if (e.getMessage().equals(\"account_disabled\")) {\n            return true;\n        }\n        return false;  //ToDo\n    }\n\n    @Override\n    public void handleException(Context ctx, Exception e) {\n        //ToDo\n        Toast.makeText(ctx, \"account disable \" + e.getMessage(), Toast.LENGTH_SHORT).show();\n\n    }\n\n    @Override\n    public void handleTargetException(Context ctx) {\n        //ToDo\n        Toast.makeText(ctx, \"account disable target\" + mMessage, Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n由于我们传进了`Context ctx`参数，实际上我们可以做任何有关Android的事情了。就看你怎么去做了。\n\n## Last word\n---\n多稚嫩的框架，这只是alpha版而已。慢慢来，先这么看看\n","slug":"2013-05-31-exceptioncenter","published":1,"updated":"2018-02-14T21:36:14.834Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlm000srpfy3xgm2atq","content":"<h2 id=\"What’s-up\"><a href=\"#What’s-up\" class=\"headerlink\" title=\"##What’s up?\"></a>##What’s up?</h2><p>我们可能常常遇到这样的问题：</p>\n<ol>\n<li>http请求异常很多种，我们或者将他们归类包装，或者将他们一一抛到上层去处理，通常我们的应用会有很多层，API层,Cache层，业务层，界面层等等，层次越多需要将异常抛的层就越多，最终到达界面了再根据不同的异常渲染不同的页面效果。</li>\n<li>某些异常不单单是提示用户就可以了的，还需要处理特定的业务或者与用户进行交互的，比如某用户被禁用了我们除了提示还需要将用户登出，清理数据等。</li>\n<li>除了去处理异常，我们还需要对得到的异常分析，保存等定制操作，在哪里做比较合适，比较优雅？</li>\n</ol>\n<h2 id=\"So-How-to-solvoe-it\"><a href=\"#So-How-to-solvoe-it\" class=\"headerlink\" title=\"So,How to solvoe it?\"></a>So,How to solvoe it?</h2><hr>\n<p>我们可以将需要在界面渲染的异常，跟踪保存的异常等统统扔到 ExceptionCenter中，通过<code>public boolean      fileter(Exception e)</code>函数过滤每一个异常，进行匹配。如果返回<code>true</code> 则在<code>public void handleException(Context ctx,Exception e)</code>函数中进行对应的逻辑处理，大概如此：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class LKException implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract boolean filter(Exception e);</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract void handleException(Context ctx, Exception e);</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract void handleTargetException(Context ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>implements Serializable</code>是为了能在Intent中传递。</p>\n<p><code>ExceptionCenter</code>采用继承<code>BroadcastReceiver</code>异步来处理事件，大致是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ExceptionCenter extends BroadcastReceiver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static final String ACTION_EXCEPTION = &quot;com.huaban.exceptioncenter&quot;;</span><br><span class=\"line\">    public static final String EXTRA_EXCEPTION = &quot;exception&quot;;</span><br><span class=\"line\">    public static final String EXTRA_LKEXCEPTION = &quot;lkexception&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ExceptionCenterFactory mFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Class&lt;? extends LKException&gt;&gt; mClazz = new ArrayList&lt;Class&lt;? extends LKException&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public ExceptionCenter(ExceptionCenterFactory factory) &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">        factory.onAddExceptionList(mClazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        Exception exception = (Exception) intent.getSerializableExtra(EXTRA_EXCEPTION);</span><br><span class=\"line\">        LKException lkException = (LKException) intent.getSerializableExtra(EXTRA_LKEXCEPTION);</span><br><span class=\"line\">        if (lkException != null) &#123;</span><br><span class=\"line\">            lkException.handleTargetException(context);</span><br><span class=\"line\">        &#125; else if (exception != null) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                for (Class&lt;? extends LKException&gt; item : mClazz) &#123;</span><br><span class=\"line\">                    LKException lk = item.newInstance();</span><br><span class=\"line\">                    if (lk.filter(exception)) &#123;</span><br><span class=\"line\">                        lk.handleException(context, exception);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (InstantiationException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>onReceive()</code>函数中 处理异常有两种模式，一种是不需要进行过滤判断的，直接进行handle，一种是通过循环执行<code>lk.filter(exception)</code>判断是否需要进行处理。这是考虑到了开发者可以在ExceptionCenter先在外部进行判断再传进来处理，也可以在内部进行判断同时处理。</p>\n<p>同时提供了几个类函数方便使用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static BroadcastReceiver mBr;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void start(Context ctx, ExceptionCenterFactory factory) &#123;</span><br><span class=\"line\">\tmBr = new ExceptionCenter(factory);</span><br><span class=\"line\">    IntentFilter intentFilter = new IntentFilter(ACTION_EXCEPTION);</span><br><span class=\"line\">    LocalBroadcastManager.getInstance(ctx).registerReceiver(mBr, intentFilter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void stop(Context ctx) &#123;</span><br><span class=\"line\">\tLocalBroadcastManager.getInstance(ctx).unregisterReceiver(mBr);</span><br><span class=\"line\">    mBr = null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void recevieLKException(Context ctx, LKException exception) &#123;</span><br><span class=\"line\">    Intent intent = new Intent(ACTION_EXCEPTION);</span><br><span class=\"line\">    intent.putExtra(EXTRA_LKEXCEPTION, exception);</span><br><span class=\"line\">    LocalBroadcastManager.getInstance(ctx).sendBroadcast(intent);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void recevieException(Context ctx, Exception exception) &#123;</span><br><span class=\"line\">    Intent intent = new Intent(ACTION_EXCEPTION);</span><br><span class=\"line\">    intent.putExtra(EXTRA_EXCEPTION, exception);</span><br><span class=\"line\">    LocalBroadcastManager.getInstance(ctx).sendBroadcast(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>start(Context ctx,ExceptionCenterFactroy factory)</code>在你的MainActivity的onCreate()中使用，</p>\n<p><code>stop(context ctx)</code>在onDestory()中使用，因为使用了support.v4包中的<a href=\"http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html\" target=\"_blank\" rel=\"noopener\">LocalBroadcatManager</a>类，所以这种方式比正常的BroadcastReceiver更加效率,Google原话：</p>\n<blockquote>\n<p>If you don’t need to send broadcasts across applications, consider using<br>this class with {@link android.support.v4.content.LocalBroadcastManager} instead<br>of the more general facilities described below.  This will give you a much<br>more efficient implementation (no cross-process communication needed) and allow<br>you to avoid thinking about any security issues related to other applications<br>being able to receive or send your broadcasts.</p>\n</blockquote>\n<p><code>ExceptionCenterFactory</code>只有一个抽象函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class ExceptionCenterFactory &#123;</span><br><span class=\"line\">    public abstract void onAddExceptionList(List&lt;Class&lt;? extends LKException&gt;&gt; filterList);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开发者将需要过滤处理的类添加到队列中。</p>\n<p>类似这中实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WallpaperExceptionFactory extends ExceptionCenterFactory &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onAddExceptionList(List&lt;Class&lt;? extends LKException&gt;&gt; exceptionList) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        exceptionList.add(AccountDisableException.class);</span><br><span class=\"line\">        exceptionList.add(LKJSONException.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好的 来个简单的处理异常的类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AccountDisableException extends LKException &#123;</span><br><span class=\"line\">    private static final String ACCOUNT_DISABLE = &quot;account_disable&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String mMessage;</span><br><span class=\"line\"></span><br><span class=\"line\">    public AccountDisableException() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public AccountDisableException(String msg) &#123;</span><br><span class=\"line\">        this.mMessage = msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean filter(Exception e) &#123;</span><br><span class=\"line\">        if (e.getMessage().equals(&quot;account_disabled&quot;)) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;  //ToDo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handleException(Context ctx, Exception e) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        Toast.makeText(ctx, &quot;account disable &quot; + e.getMessage(), Toast.LENGTH_SHORT).show();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handleTargetException(Context ctx) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        Toast.makeText(ctx, &quot;account disable target&quot; + mMessage, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于我们传进了<code>Context ctx</code>参数，实际上我们可以做任何有关Android的事情了。就看你怎么去做了。</p>\n<h2 id=\"Last-word\"><a href=\"#Last-word\" class=\"headerlink\" title=\"Last word\"></a>Last word</h2><hr>\n<p>多稚嫩的框架，这只是alpha版而已。慢慢来，先这么看看</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"What’s-up\"><a href=\"#What’s-up\" class=\"headerlink\" title=\"##What’s up?\"></a>##What’s up?</h2><p>我们可能常常遇到这样的问题：</p>\n<ol>\n<li>http请求异常很多种，我们或者将他们归类包装，或者将他们一一抛到上层去处理，通常我们的应用会有很多层，API层,Cache层，业务层，界面层等等，层次越多需要将异常抛的层就越多，最终到达界面了再根据不同的异常渲染不同的页面效果。</li>\n<li>某些异常不单单是提示用户就可以了的，还需要处理特定的业务或者与用户进行交互的，比如某用户被禁用了我们除了提示还需要将用户登出，清理数据等。</li>\n<li>除了去处理异常，我们还需要对得到的异常分析，保存等定制操作，在哪里做比较合适，比较优雅？</li>\n</ol>\n<h2 id=\"So-How-to-solvoe-it\"><a href=\"#So-How-to-solvoe-it\" class=\"headerlink\" title=\"So,How to solvoe it?\"></a>So,How to solvoe it?</h2><hr>\n<p>我们可以将需要在界面渲染的异常，跟踪保存的异常等统统扔到 ExceptionCenter中，通过<code>public boolean      fileter(Exception e)</code>函数过滤每一个异常，进行匹配。如果返回<code>true</code> 则在<code>public void handleException(Context ctx,Exception e)</code>函数中进行对应的逻辑处理，大概如此：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class LKException implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract boolean filter(Exception e);</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract void handleException(Context ctx, Exception e);</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract void handleTargetException(Context ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>implements Serializable</code>是为了能在Intent中传递。</p>\n<p><code>ExceptionCenter</code>采用继承<code>BroadcastReceiver</code>异步来处理事件，大致是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ExceptionCenter extends BroadcastReceiver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static final String ACTION_EXCEPTION = &quot;com.huaban.exceptioncenter&quot;;</span><br><span class=\"line\">    public static final String EXTRA_EXCEPTION = &quot;exception&quot;;</span><br><span class=\"line\">    public static final String EXTRA_LKEXCEPTION = &quot;lkexception&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ExceptionCenterFactory mFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Class&lt;? extends LKException&gt;&gt; mClazz = new ArrayList&lt;Class&lt;? extends LKException&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public ExceptionCenter(ExceptionCenterFactory factory) &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">        factory.onAddExceptionList(mClazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        Exception exception = (Exception) intent.getSerializableExtra(EXTRA_EXCEPTION);</span><br><span class=\"line\">        LKException lkException = (LKException) intent.getSerializableExtra(EXTRA_LKEXCEPTION);</span><br><span class=\"line\">        if (lkException != null) &#123;</span><br><span class=\"line\">            lkException.handleTargetException(context);</span><br><span class=\"line\">        &#125; else if (exception != null) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                for (Class&lt;? extends LKException&gt; item : mClazz) &#123;</span><br><span class=\"line\">                    LKException lk = item.newInstance();</span><br><span class=\"line\">                    if (lk.filter(exception)) &#123;</span><br><span class=\"line\">                        lk.handleException(context, exception);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (InstantiationException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>onReceive()</code>函数中 处理异常有两种模式，一种是不需要进行过滤判断的，直接进行handle，一种是通过循环执行<code>lk.filter(exception)</code>判断是否需要进行处理。这是考虑到了开发者可以在ExceptionCenter先在外部进行判断再传进来处理，也可以在内部进行判断同时处理。</p>\n<p>同时提供了几个类函数方便使用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static BroadcastReceiver mBr;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void start(Context ctx, ExceptionCenterFactory factory) &#123;</span><br><span class=\"line\">\tmBr = new ExceptionCenter(factory);</span><br><span class=\"line\">    IntentFilter intentFilter = new IntentFilter(ACTION_EXCEPTION);</span><br><span class=\"line\">    LocalBroadcastManager.getInstance(ctx).registerReceiver(mBr, intentFilter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void stop(Context ctx) &#123;</span><br><span class=\"line\">\tLocalBroadcastManager.getInstance(ctx).unregisterReceiver(mBr);</span><br><span class=\"line\">    mBr = null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void recevieLKException(Context ctx, LKException exception) &#123;</span><br><span class=\"line\">    Intent intent = new Intent(ACTION_EXCEPTION);</span><br><span class=\"line\">    intent.putExtra(EXTRA_LKEXCEPTION, exception);</span><br><span class=\"line\">    LocalBroadcastManager.getInstance(ctx).sendBroadcast(intent);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void recevieException(Context ctx, Exception exception) &#123;</span><br><span class=\"line\">    Intent intent = new Intent(ACTION_EXCEPTION);</span><br><span class=\"line\">    intent.putExtra(EXTRA_EXCEPTION, exception);</span><br><span class=\"line\">    LocalBroadcastManager.getInstance(ctx).sendBroadcast(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>start(Context ctx,ExceptionCenterFactroy factory)</code>在你的MainActivity的onCreate()中使用，</p>\n<p><code>stop(context ctx)</code>在onDestory()中使用，因为使用了support.v4包中的<a href=\"http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html\" target=\"_blank\" rel=\"noopener\">LocalBroadcatManager</a>类，所以这种方式比正常的BroadcastReceiver更加效率,Google原话：</p>\n<blockquote>\n<p>If you don’t need to send broadcasts across applications, consider using<br>this class with {@link android.support.v4.content.LocalBroadcastManager} instead<br>of the more general facilities described below.  This will give you a much<br>more efficient implementation (no cross-process communication needed) and allow<br>you to avoid thinking about any security issues related to other applications<br>being able to receive or send your broadcasts.</p>\n</blockquote>\n<p><code>ExceptionCenterFactory</code>只有一个抽象函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class ExceptionCenterFactory &#123;</span><br><span class=\"line\">    public abstract void onAddExceptionList(List&lt;Class&lt;? extends LKException&gt;&gt; filterList);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开发者将需要过滤处理的类添加到队列中。</p>\n<p>类似这中实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WallpaperExceptionFactory extends ExceptionCenterFactory &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onAddExceptionList(List&lt;Class&lt;? extends LKException&gt;&gt; exceptionList) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        exceptionList.add(AccountDisableException.class);</span><br><span class=\"line\">        exceptionList.add(LKJSONException.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好的 来个简单的处理异常的类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AccountDisableException extends LKException &#123;</span><br><span class=\"line\">    private static final String ACCOUNT_DISABLE = &quot;account_disable&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String mMessage;</span><br><span class=\"line\"></span><br><span class=\"line\">    public AccountDisableException() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public AccountDisableException(String msg) &#123;</span><br><span class=\"line\">        this.mMessage = msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean filter(Exception e) &#123;</span><br><span class=\"line\">        if (e.getMessage().equals(&quot;account_disabled&quot;)) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;  //ToDo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handleException(Context ctx, Exception e) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        Toast.makeText(ctx, &quot;account disable &quot; + e.getMessage(), Toast.LENGTH_SHORT).show();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handleTargetException(Context ctx) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">        Toast.makeText(ctx, &quot;account disable target&quot; + mMessage, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于我们传进了<code>Context ctx</code>参数，实际上我们可以做任何有关Android的事情了。就看你怎么去做了。</p>\n<h2 id=\"Last-word\"><a href=\"#Last-word\" class=\"headerlink\" title=\"Last word\"></a>Last word</h2><hr>\n<p>多稚嫩的框架，这只是alpha版而已。慢慢来，先这么看看</p>\n"},{"date":"2013-06-02T16:00:00.000Z","layout":"post","title":"Android屏幕分辨率占有率分析及应用","_content":"\nAndroid屏幕分辨率各种各样，碎片化严重，开发者苦不堪言，转身看看iOS开发同学，只要适配2个尺寸的屏幕就好了，= =！\n\n但我们总是能克服的对不，假如我们现在有这么一个需求：\n###我们将满屏显示一张网络图片，希望它不要失真或者被裁剪！\n\n怎么做？先看看[友盟的统计](http://www.umindex.com/#android_resolution):\n\n<table>\n    <tr>\n        <td>排名</td>\n        <td>分辨率</td>\n        <td>高宽比</td>\n        <td>占有率</td>\n    </tr>\n     <tr>\n        <td>1</td>\n        <td>800*480</td>\n        <td>1.66</td>\n        <td>37.7%</td>\n    </tr>\n     <tr>\n        <td>2</td>\n        <td>480*320</td>\n        <td>1.5</td>\n        <td>25.4%</td>\n    </tr>\n     <tr>\n        <td>3</td>\n        <td>854*480</td>\n        <td>1.779</td>\n        <td>9.5%</td>\n    </tr>\n      <tr>\n        <td>4</td>\n        <td>1280*720</td>\n        <td>1.777 </td>\n        <td>5.6%</td>\n    </tr>\n      <tr>\n        <td>5</td>\n        <td>960*540 </td>\n        <td>1.777</td>\n        <td>5.6%</td>\n    </tr>\n      <tr>\n        <td>6</td>\n        <td>320*240</td>\n        <td>1.333</td>\n        <td>3.1%</td>\n    </tr>\n    <tr>\n        <td>7</td>\n        <td>1280*800</td>\n        <td>1.6</td>\n        <td>2.5%</td>\n    </tr>\n    <tr>\n        <td>8</td>\n        <td>1024*600</td>\n        <td>1.706</td>\n        <td>1.3%</td>\n    </tr>\n    <tr>\n        <td>9</td>\n        <td>960*640</td>\n        <td>1.5</td>\n        <td>0.9%</td>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>1024*768</td>\n        <td>1.3</td>\n        <td>0.5%</td>\n    </tr>\n    <tr>\n        <td>11</td>\n        <td>other</td>\n        <td>?</td>\n        <td>4.7%</td>\n    </tr>\n</table>\n\n让我们合并下高宽比约等项，再排名：\n\n<table>\n    <tr>\n        <td>排名</td>\n        <td>高宽比</td>\n        <td>占有率</td>\n    </tr>\n     <tr>\n        <td>1</td>\n        <td>1.6~1.66</td>\n        <td>2.5%+37.7%=40.2%</td>\n    </tr>\n     <tr>\n        <td>2</td>\n        <td>1.5</td>\n        <td>25.4%+0.9%=26.3%</td>\n    </tr>\n     <tr>\n        <td>3</td>\n        <td>1.706~1.779</td>\n        <td>1.3%+8.8%+5.6%+9.5%=25.2%</td>\n    </tr>\n     <tr>\n        <td>4</td>\n        <td>1.3~1.333</td>\n        <td>0.5%~3.1%=3.6%</td>\n    </tr>\n     <tr>\n        <td>5</td>\n        <td>?</td>\n        <td>4.7%</td>\n    </tr>\n</table>\n\n可以看出前三项占了91%!!!,况且1.333的屏幕是320*240这种小屏幕，好古董的屏幕，而且未知项中可能还包含前三项中的可能，所以如果我们忽略一些细节的话，最终情况是这样的：\n\n<table>\n    <tr>\n        <td>排名</td>\n        <td>分辨率</td>\n        <td>高宽比</td>\n        <td>占有率</td>\n    </tr>\n     <tr>\n        <td>1</td>\n        <td>800*480</td>\n        <td>1.66</td>\n        <td>40.2%</td>\n    </tr>\n     <tr>\n        <td>2</td>\n        <td>480*320</td>\n        <td>1.5</td>\n        <td>26.3%</td>\n    </tr>\n     <tr>\n        <td>3</td>\n        <td>1280*720</td>\n        <td>1.777</td>\n        <td>25.2%</td>\n    </tr>\n</table>\n\n\n有什么用呢?\n\n###结论：假如这张网络请求下来的图片是设计师给出的，就请设计师对应着表3给出3套图，程序中我们动态算出手机屏幕的高宽比，根据高宽比对应选出最合适的图片，将scaleType设置为fitXY，这样就能做到最大程度的不失真了。\n\n给一个写好的枚举类\n\n```\nenum AspectRatio {\n    SCALE_15, SCALE_166, SCALE_177;\n\n    public static AspectRatio getAspectRatio(float h2w) {\n        if (h2w <= 1.5f) {\n            return AspectRatio.SCALE_15;\n        } else if (h2w > 1.5 && h2w <= 1.67) {\n           return AspectRatio.SCALE_166;\n        } else if (h2w > 1.67) {\n            return AspectRatio.SCALE_177;\n        } else {\n             return AspectRatio.SCALE_166;\n        }\n    }\n}\n```\n","source":"_posts/2013-06-03-android-screen.md","raw":"---\ncategory: Android\ndate: 2013-06-03\nlayout: post\ntitle: Android屏幕分辨率占有率分析及应用\n---\n\nAndroid屏幕分辨率各种各样，碎片化严重，开发者苦不堪言，转身看看iOS开发同学，只要适配2个尺寸的屏幕就好了，= =！\n\n但我们总是能克服的对不，假如我们现在有这么一个需求：\n###我们将满屏显示一张网络图片，希望它不要失真或者被裁剪！\n\n怎么做？先看看[友盟的统计](http://www.umindex.com/#android_resolution):\n\n<table>\n    <tr>\n        <td>排名</td>\n        <td>分辨率</td>\n        <td>高宽比</td>\n        <td>占有率</td>\n    </tr>\n     <tr>\n        <td>1</td>\n        <td>800*480</td>\n        <td>1.66</td>\n        <td>37.7%</td>\n    </tr>\n     <tr>\n        <td>2</td>\n        <td>480*320</td>\n        <td>1.5</td>\n        <td>25.4%</td>\n    </tr>\n     <tr>\n        <td>3</td>\n        <td>854*480</td>\n        <td>1.779</td>\n        <td>9.5%</td>\n    </tr>\n      <tr>\n        <td>4</td>\n        <td>1280*720</td>\n        <td>1.777 </td>\n        <td>5.6%</td>\n    </tr>\n      <tr>\n        <td>5</td>\n        <td>960*540 </td>\n        <td>1.777</td>\n        <td>5.6%</td>\n    </tr>\n      <tr>\n        <td>6</td>\n        <td>320*240</td>\n        <td>1.333</td>\n        <td>3.1%</td>\n    </tr>\n    <tr>\n        <td>7</td>\n        <td>1280*800</td>\n        <td>1.6</td>\n        <td>2.5%</td>\n    </tr>\n    <tr>\n        <td>8</td>\n        <td>1024*600</td>\n        <td>1.706</td>\n        <td>1.3%</td>\n    </tr>\n    <tr>\n        <td>9</td>\n        <td>960*640</td>\n        <td>1.5</td>\n        <td>0.9%</td>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>1024*768</td>\n        <td>1.3</td>\n        <td>0.5%</td>\n    </tr>\n    <tr>\n        <td>11</td>\n        <td>other</td>\n        <td>?</td>\n        <td>4.7%</td>\n    </tr>\n</table>\n\n让我们合并下高宽比约等项，再排名：\n\n<table>\n    <tr>\n        <td>排名</td>\n        <td>高宽比</td>\n        <td>占有率</td>\n    </tr>\n     <tr>\n        <td>1</td>\n        <td>1.6~1.66</td>\n        <td>2.5%+37.7%=40.2%</td>\n    </tr>\n     <tr>\n        <td>2</td>\n        <td>1.5</td>\n        <td>25.4%+0.9%=26.3%</td>\n    </tr>\n     <tr>\n        <td>3</td>\n        <td>1.706~1.779</td>\n        <td>1.3%+8.8%+5.6%+9.5%=25.2%</td>\n    </tr>\n     <tr>\n        <td>4</td>\n        <td>1.3~1.333</td>\n        <td>0.5%~3.1%=3.6%</td>\n    </tr>\n     <tr>\n        <td>5</td>\n        <td>?</td>\n        <td>4.7%</td>\n    </tr>\n</table>\n\n可以看出前三项占了91%!!!,况且1.333的屏幕是320*240这种小屏幕，好古董的屏幕，而且未知项中可能还包含前三项中的可能，所以如果我们忽略一些细节的话，最终情况是这样的：\n\n<table>\n    <tr>\n        <td>排名</td>\n        <td>分辨率</td>\n        <td>高宽比</td>\n        <td>占有率</td>\n    </tr>\n     <tr>\n        <td>1</td>\n        <td>800*480</td>\n        <td>1.66</td>\n        <td>40.2%</td>\n    </tr>\n     <tr>\n        <td>2</td>\n        <td>480*320</td>\n        <td>1.5</td>\n        <td>26.3%</td>\n    </tr>\n     <tr>\n        <td>3</td>\n        <td>1280*720</td>\n        <td>1.777</td>\n        <td>25.2%</td>\n    </tr>\n</table>\n\n\n有什么用呢?\n\n###结论：假如这张网络请求下来的图片是设计师给出的，就请设计师对应着表3给出3套图，程序中我们动态算出手机屏幕的高宽比，根据高宽比对应选出最合适的图片，将scaleType设置为fitXY，这样就能做到最大程度的不失真了。\n\n给一个写好的枚举类\n\n```\nenum AspectRatio {\n    SCALE_15, SCALE_166, SCALE_177;\n\n    public static AspectRatio getAspectRatio(float h2w) {\n        if (h2w <= 1.5f) {\n            return AspectRatio.SCALE_15;\n        } else if (h2w > 1.5 && h2w <= 1.67) {\n           return AspectRatio.SCALE_166;\n        } else if (h2w > 1.67) {\n            return AspectRatio.SCALE_177;\n        } else {\n             return AspectRatio.SCALE_166;\n        }\n    }\n}\n```\n","slug":"2013-06-03-android-screen","published":1,"updated":"2018-02-14T21:36:14.834Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tln000urpfygwy02tdw","content":"<p>Android屏幕分辨率各种各样，碎片化严重，开发者苦不堪言，转身看看iOS开发同学，只要适配2个尺寸的屏幕就好了，= =！</p>\n<p>但我们总是能克服的对不，假如我们现在有这么一个需求：</p>\n<p>###我们将满屏显示一张网络图片，希望它不要失真或者被裁剪！</p>\n<p>怎么做？先看看<a href=\"http://www.umindex.com/#android_resolution\" target=\"_blank\" rel=\"noopener\">友盟的统计</a>:</p>\n<table><br>    <tr><br>        <td>排名</td><br>        <td>分辨率</td><br>        <td>高宽比</td><br>        <td>占有率</td><br>    </tr><br>     <tr><br>        <td>1</td><br>        <td>800<em>480</em></td><br>        <td>1.66</td><br>        <td>37.7%</td><br>    </tr><br>     <tr><br>        <td>2</td><br>        <td>480320</td><br>        <td>1.5</td><br>        <td>25.4%</td><br>    </tr><br>     <tr><br>        <td>3</td><br>        <td>854<em>480</em></td><br>        <td>1.779</td><br>        <td>9.5%</td><br>    </tr><br>      <tr><br>        <td>4</td><br>        <td>1280720</td><br>        <td>1.777 </td><br>        <td>5.6%</td><br>    </tr><br>      <tr><br>        <td>5</td><br>        <td>960<em>540 </em></td><br>        <td>1.777</td><br>        <td>5.6%</td><br>    </tr><br>      <tr><br>        <td>6</td><br>        <td>320240</td><br>        <td>1.333</td><br>        <td>3.1%</td><br>    </tr><br>    <tr><br>        <td>7</td><br>        <td>1280<em>800</em></td><br>        <td>1.6</td><br>        <td>2.5%</td><br>    </tr><br>    <tr><br>        <td>8</td><br>        <td>1024600</td><br>        <td>1.706</td><br>        <td>1.3%</td><br>    </tr><br>    <tr><br>        <td>9</td><br>        <td>960<em>640</em></td><br>        <td>1.5</td><br>        <td>0.9%</td><br>    </tr><br>    <tr><br>        <td>10</td><br>        <td>1024768</td><br>        <td>1.3</td><br>        <td>0.5%</td><br>    </tr><br>    <tr><br>        <td>11</td><br>        <td>other</td><br>        <td>?</td><br>        <td>4.7%</td><br>    </tr><br></table>\n\n<p>让我们合并下高宽比约等项，再排名：</p>\n<table><br>    <tr><br>        <td>排名</td><br>        <td>高宽比</td><br>        <td>占有率</td><br>    </tr><br>     <tr><br>        <td>1</td><br>        <td>1.6~1.66</td><br>        <td>2.5%+37.7%=40.2%</td><br>    </tr><br>     <tr><br>        <td>2</td><br>        <td>1.5</td><br>        <td>25.4%+0.9%=26.3%</td><br>    </tr><br>     <tr><br>        <td>3</td><br>        <td>1.706~1.779</td><br>        <td>1.3%+8.8%+5.6%+9.5%=25.2%</td><br>    </tr><br>     <tr><br>        <td>4</td><br>        <td>1.3~1.333</td><br>        <td>0.5%~3.1%=3.6%</td><br>    </tr><br>     <tr><br>        <td>5</td><br>        <td>?</td><br>        <td>4.7%</td><br>    </tr><br></table>\n\n<p>可以看出前三项占了91%!!!,况且1.333的屏幕是320*240这种小屏幕，好古董的屏幕，而且未知项中可能还包含前三项中的可能，所以如果我们忽略一些细节的话，最终情况是这样的：</p>\n<table><br>    <tr><br>        <td>排名</td><br>        <td>分辨率</td><br>        <td>高宽比</td><br>        <td>占有率</td><br>    </tr><br>     <tr><br>        <td>1</td><br>        <td>800<em>480</em></td><br>        <td>1.66</td><br>        <td>40.2%</td><br>    </tr><br>     <tr><br>        <td>2</td><br>        <td>480320</td><br>        <td>1.5</td><br>        <td>26.3%</td><br>    </tr><br>     <tr><br>        <td>3</td><br>        <td>1280*720</td><br>        <td>1.777</td><br>        <td>25.2%</td><br>    </tr><br></table>\n\n\n<p>有什么用呢?</p>\n<p>###结论：假如这张网络请求下来的图片是设计师给出的，就请设计师对应着表3给出3套图，程序中我们动态算出手机屏幕的高宽比，根据高宽比对应选出最合适的图片，将scaleType设置为fitXY，这样就能做到最大程度的不失真了。</p>\n<p>给一个写好的枚举类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum AspectRatio &#123;</span><br><span class=\"line\">    SCALE_15, SCALE_166, SCALE_177;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static AspectRatio getAspectRatio(float h2w) &#123;</span><br><span class=\"line\">        if (h2w &lt;= 1.5f) &#123;</span><br><span class=\"line\">            return AspectRatio.SCALE_15;</span><br><span class=\"line\">        &#125; else if (h2w &gt; 1.5 &amp;&amp; h2w &lt;= 1.67) &#123;</span><br><span class=\"line\">           return AspectRatio.SCALE_166;</span><br><span class=\"line\">        &#125; else if (h2w &gt; 1.67) &#123;</span><br><span class=\"line\">            return AspectRatio.SCALE_177;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">             return AspectRatio.SCALE_166;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Android屏幕分辨率各种各样，碎片化严重，开发者苦不堪言，转身看看iOS开发同学，只要适配2个尺寸的屏幕就好了，= =！</p>\n<p>但我们总是能克服的对不，假如我们现在有这么一个需求：</p>\n<p>###我们将满屏显示一张网络图片，希望它不要失真或者被裁剪！</p>\n<p>怎么做？先看看<a href=\"http://www.umindex.com/#android_resolution\" target=\"_blank\" rel=\"noopener\">友盟的统计</a>:</p>\n<table><br>    <tr><br>        <td>排名</td><br>        <td>分辨率</td><br>        <td>高宽比</td><br>        <td>占有率</td><br>    </tr><br>     <tr><br>        <td>1</td><br>        <td>800<em>480</em></td><br>        <td>1.66</td><br>        <td>37.7%</td><br>    </tr><br>     <tr><br>        <td>2</td><br>        <td>480320</td><br>        <td>1.5</td><br>        <td>25.4%</td><br>    </tr><br>     <tr><br>        <td>3</td><br>        <td>854<em>480</em></td><br>        <td>1.779</td><br>        <td>9.5%</td><br>    </tr><br>      <tr><br>        <td>4</td><br>        <td>1280720</td><br>        <td>1.777 </td><br>        <td>5.6%</td><br>    </tr><br>      <tr><br>        <td>5</td><br>        <td>960<em>540 </em></td><br>        <td>1.777</td><br>        <td>5.6%</td><br>    </tr><br>      <tr><br>        <td>6</td><br>        <td>320240</td><br>        <td>1.333</td><br>        <td>3.1%</td><br>    </tr><br>    <tr><br>        <td>7</td><br>        <td>1280<em>800</em></td><br>        <td>1.6</td><br>        <td>2.5%</td><br>    </tr><br>    <tr><br>        <td>8</td><br>        <td>1024600</td><br>        <td>1.706</td><br>        <td>1.3%</td><br>    </tr><br>    <tr><br>        <td>9</td><br>        <td>960<em>640</em></td><br>        <td>1.5</td><br>        <td>0.9%</td><br>    </tr><br>    <tr><br>        <td>10</td><br>        <td>1024768</td><br>        <td>1.3</td><br>        <td>0.5%</td><br>    </tr><br>    <tr><br>        <td>11</td><br>        <td>other</td><br>        <td>?</td><br>        <td>4.7%</td><br>    </tr><br></table>\n\n<p>让我们合并下高宽比约等项，再排名：</p>\n<table><br>    <tr><br>        <td>排名</td><br>        <td>高宽比</td><br>        <td>占有率</td><br>    </tr><br>     <tr><br>        <td>1</td><br>        <td>1.6~1.66</td><br>        <td>2.5%+37.7%=40.2%</td><br>    </tr><br>     <tr><br>        <td>2</td><br>        <td>1.5</td><br>        <td>25.4%+0.9%=26.3%</td><br>    </tr><br>     <tr><br>        <td>3</td><br>        <td>1.706~1.779</td><br>        <td>1.3%+8.8%+5.6%+9.5%=25.2%</td><br>    </tr><br>     <tr><br>        <td>4</td><br>        <td>1.3~1.333</td><br>        <td>0.5%~3.1%=3.6%</td><br>    </tr><br>     <tr><br>        <td>5</td><br>        <td>?</td><br>        <td>4.7%</td><br>    </tr><br></table>\n\n<p>可以看出前三项占了91%!!!,况且1.333的屏幕是320*240这种小屏幕，好古董的屏幕，而且未知项中可能还包含前三项中的可能，所以如果我们忽略一些细节的话，最终情况是这样的：</p>\n<table><br>    <tr><br>        <td>排名</td><br>        <td>分辨率</td><br>        <td>高宽比</td><br>        <td>占有率</td><br>    </tr><br>     <tr><br>        <td>1</td><br>        <td>800<em>480</em></td><br>        <td>1.66</td><br>        <td>40.2%</td><br>    </tr><br>     <tr><br>        <td>2</td><br>        <td>480320</td><br>        <td>1.5</td><br>        <td>26.3%</td><br>    </tr><br>     <tr><br>        <td>3</td><br>        <td>1280*720</td><br>        <td>1.777</td><br>        <td>25.2%</td><br>    </tr><br></table>\n\n\n<p>有什么用呢?</p>\n<p>###结论：假如这张网络请求下来的图片是设计师给出的，就请设计师对应着表3给出3套图，程序中我们动态算出手机屏幕的高宽比，根据高宽比对应选出最合适的图片，将scaleType设置为fitXY，这样就能做到最大程度的不失真了。</p>\n<p>给一个写好的枚举类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum AspectRatio &#123;</span><br><span class=\"line\">    SCALE_15, SCALE_166, SCALE_177;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static AspectRatio getAspectRatio(float h2w) &#123;</span><br><span class=\"line\">        if (h2w &lt;= 1.5f) &#123;</span><br><span class=\"line\">            return AspectRatio.SCALE_15;</span><br><span class=\"line\">        &#125; else if (h2w &gt; 1.5 &amp;&amp; h2w &lt;= 1.67) &#123;</span><br><span class=\"line\">           return AspectRatio.SCALE_166;</span><br><span class=\"line\">        &#125; else if (h2w &gt; 1.67) &#123;</span><br><span class=\"line\">            return AspectRatio.SCALE_177;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">             return AspectRatio.SCALE_166;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","date":"2013-06-06T16:00:00.000Z","title":"Android ActionBar源码解析之FragmentTab","_content":"\n在Android3.0以上以及android.support.v4包中包含了ActionBar这个控件，十分好用的一个模块就是它的[ActionBar.Tab](http://developer.android.com/reference/android/app/ActionBar.Tab.html).**但是**，它将布局与Fragment的管理耦合在了一起，假如我们想定制的话，还是需要花费一点功夫的，所以我将它们解耦，简化了一下，单独拿了出来。点击查看：[Github：Android-FragmentTab](https://github.com/LinkYan/Android-FragmentTab)\n\n首先让我们看看FragmentTab的实现，不是很复杂：\n\n```\npublic class FragmentTab {\n    FragmentManager mFragmentManager;\n    HashMap<String, TabItem> mTabItems = new HashMap<String, TabItem>();\n    TabItem mSelectedTabItem;\n\n    public FragmentTab(FragmentManager mFragmentManager) {\n        this.mFragmentManager = mFragmentManager;\n    }\n\n    public void addTabItem(TabItem item) {\n        mTabItems.put(item.getTag(), item);\n    }\n\n    public void selectTab(String tag) {\n        selectTab(mTabItems.get(tag));\n    }\n\n    public void selectTab(TabItem tabItem) {\n\n        final FragmentTransaction trans = mFragmentManager.beginTransaction()\n                .disallowAddToBackStack();\n\n        if (mSelectedTabItem == tabItem) {\n            if (mSelectedTabItem != null) {\n                mSelectedTabItem.onTabReselected(mSelectedTabItem, trans);\n            }\n        } else {\n            if (mSelectedTabItem != null) {\n                mSelectedTabItem.onTabUnselected(mSelectedTabItem, trans);\n            }\n            mSelectedTabItem = tabItem;\n            if (mSelectedTabItem != null) {\n                mSelectedTabItem.onTabSelected(mSelectedTabItem, trans);\n            }\n        }\n\n        if (!trans.isEmpty()) {\n            trans.commit();\n        }\n\n    }\n\n}\n```\n\n可以看出我们实际上只有两个方法可以调用`addTabItem(TabItem item)`和`selectTab(TabItem item)` ，一个添加tab和一个选择tab。\n\nTabItem是一个抽象类,构造函数中的`Class<T> mClass`是Fragment的类，以及它的参数`Bundle mArgs`:\n\n```\npublic abstract class TabItem<T> implements TabListener {\n    protected final Context mContext;\n    protected final String mTag;\n    protected final Class<T> mClass;\n    protected final Bundle mArgs;\n    protected Fragment mFragment;\n\n    public TabItem(Context ctx, String mTag, Class<T> mClass) {\n        this(ctx, mTag, mClass, null);\n    }\n\n    public TabItem(Context ctx, String mTag, Class<T> mClass, Bundle mArgs) {\n        this.mContext = ctx;\n        this.mTag = mTag;\n        this.mClass = mClass;\n        this.mArgs = mArgs;\n    }\n\n    public String getTag() {\n        return mTag;\n    }\n}\n```\n\nTabListener接口定义了3个方法，tab选中时，tab从选中切换到未被选中时，以及再次被选中时。\n\n```\npublic interface TabListener {\n    public void onTabSelected(TabItem tab, FragmentTransaction ft);\n\n    public void onTabUnselected(TabItem tab, FragmentTransaction ft);\n\n    public void onTabReselected(TabItem tab, FragmentTransaction ft);\n}\n```\n\n最后就是TabItem的实现了，默认行为与ActionBar.Tab是一致的，更多使用帮助：[Github：Android-FragmentTab](https://github.com/LinkYan/Android-FragmentTab)\n\n```\npublic class TabItemImpl<T> extends TabItem<T> implements TabListener {\n\n\n    public TabItemImpl(Context ctx, String mTag, Class<T> mClass) {\n        super(ctx, mTag, mClass);\n    }\n\n    public TabItemImpl(Context ctx, String mTag, Class<T> mClass, Bundle mArgs) {\n        super(ctx, mTag, mClass, mArgs);\n    }\n\n    @Override\n    public void onTabSelected(TabItem tab, FragmentTransaction ft) {\n        if (mFragment == null) {\n            mFragment = Fragment.instantiate(mContext, mClass.getName(), mArgs);\n            ft.add(R.id.layout_contain, mFragment, mTag);\n        } else {\n            ft.attach(mFragment);\n        }\n    }\n\n    @Override\n    public void onTabUnselected(TabItem tab, FragmentTransaction ft) {\n        if (mFragment != null) {\n            ft.detach(mFragment);\n        }\n    }\n\n    @Override\n    public void onTabReselected(TabItem tab, FragmentTransaction ft) {\n        //ToDo\n    }\n}\n```\n","source":"_posts/2013-06-07-fragmenttab.md","raw":"---\nlayout: post\ncategory: Android\ndate: 2013-06-07\ntitle: Android ActionBar源码解析之FragmentTab\n---\n\n在Android3.0以上以及android.support.v4包中包含了ActionBar这个控件，十分好用的一个模块就是它的[ActionBar.Tab](http://developer.android.com/reference/android/app/ActionBar.Tab.html).**但是**，它将布局与Fragment的管理耦合在了一起，假如我们想定制的话，还是需要花费一点功夫的，所以我将它们解耦，简化了一下，单独拿了出来。点击查看：[Github：Android-FragmentTab](https://github.com/LinkYan/Android-FragmentTab)\n\n首先让我们看看FragmentTab的实现，不是很复杂：\n\n```\npublic class FragmentTab {\n    FragmentManager mFragmentManager;\n    HashMap<String, TabItem> mTabItems = new HashMap<String, TabItem>();\n    TabItem mSelectedTabItem;\n\n    public FragmentTab(FragmentManager mFragmentManager) {\n        this.mFragmentManager = mFragmentManager;\n    }\n\n    public void addTabItem(TabItem item) {\n        mTabItems.put(item.getTag(), item);\n    }\n\n    public void selectTab(String tag) {\n        selectTab(mTabItems.get(tag));\n    }\n\n    public void selectTab(TabItem tabItem) {\n\n        final FragmentTransaction trans = mFragmentManager.beginTransaction()\n                .disallowAddToBackStack();\n\n        if (mSelectedTabItem == tabItem) {\n            if (mSelectedTabItem != null) {\n                mSelectedTabItem.onTabReselected(mSelectedTabItem, trans);\n            }\n        } else {\n            if (mSelectedTabItem != null) {\n                mSelectedTabItem.onTabUnselected(mSelectedTabItem, trans);\n            }\n            mSelectedTabItem = tabItem;\n            if (mSelectedTabItem != null) {\n                mSelectedTabItem.onTabSelected(mSelectedTabItem, trans);\n            }\n        }\n\n        if (!trans.isEmpty()) {\n            trans.commit();\n        }\n\n    }\n\n}\n```\n\n可以看出我们实际上只有两个方法可以调用`addTabItem(TabItem item)`和`selectTab(TabItem item)` ，一个添加tab和一个选择tab。\n\nTabItem是一个抽象类,构造函数中的`Class<T> mClass`是Fragment的类，以及它的参数`Bundle mArgs`:\n\n```\npublic abstract class TabItem<T> implements TabListener {\n    protected final Context mContext;\n    protected final String mTag;\n    protected final Class<T> mClass;\n    protected final Bundle mArgs;\n    protected Fragment mFragment;\n\n    public TabItem(Context ctx, String mTag, Class<T> mClass) {\n        this(ctx, mTag, mClass, null);\n    }\n\n    public TabItem(Context ctx, String mTag, Class<T> mClass, Bundle mArgs) {\n        this.mContext = ctx;\n        this.mTag = mTag;\n        this.mClass = mClass;\n        this.mArgs = mArgs;\n    }\n\n    public String getTag() {\n        return mTag;\n    }\n}\n```\n\nTabListener接口定义了3个方法，tab选中时，tab从选中切换到未被选中时，以及再次被选中时。\n\n```\npublic interface TabListener {\n    public void onTabSelected(TabItem tab, FragmentTransaction ft);\n\n    public void onTabUnselected(TabItem tab, FragmentTransaction ft);\n\n    public void onTabReselected(TabItem tab, FragmentTransaction ft);\n}\n```\n\n最后就是TabItem的实现了，默认行为与ActionBar.Tab是一致的，更多使用帮助：[Github：Android-FragmentTab](https://github.com/LinkYan/Android-FragmentTab)\n\n```\npublic class TabItemImpl<T> extends TabItem<T> implements TabListener {\n\n\n    public TabItemImpl(Context ctx, String mTag, Class<T> mClass) {\n        super(ctx, mTag, mClass);\n    }\n\n    public TabItemImpl(Context ctx, String mTag, Class<T> mClass, Bundle mArgs) {\n        super(ctx, mTag, mClass, mArgs);\n    }\n\n    @Override\n    public void onTabSelected(TabItem tab, FragmentTransaction ft) {\n        if (mFragment == null) {\n            mFragment = Fragment.instantiate(mContext, mClass.getName(), mArgs);\n            ft.add(R.id.layout_contain, mFragment, mTag);\n        } else {\n            ft.attach(mFragment);\n        }\n    }\n\n    @Override\n    public void onTabUnselected(TabItem tab, FragmentTransaction ft) {\n        if (mFragment != null) {\n            ft.detach(mFragment);\n        }\n    }\n\n    @Override\n    public void onTabReselected(TabItem tab, FragmentTransaction ft) {\n        //ToDo\n    }\n}\n```\n","slug":"2013-06-07-fragmenttab","published":1,"updated":"2018-02-14T21:36:14.835Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlo000wrpfy9vbv3v0g","content":"<p>在Android3.0以上以及android.support.v4包中包含了ActionBar这个控件，十分好用的一个模块就是它的<a href=\"http://developer.android.com/reference/android/app/ActionBar.Tab.html\" target=\"_blank\" rel=\"noopener\">ActionBar.Tab</a>.<strong>但是</strong>，它将布局与Fragment的管理耦合在了一起，假如我们想定制的话，还是需要花费一点功夫的，所以我将它们解耦，简化了一下，单独拿了出来。点击查看：<a href=\"https://github.com/LinkYan/Android-FragmentTab\" target=\"_blank\" rel=\"noopener\">Github：Android-FragmentTab</a></p>\n<p>首先让我们看看FragmentTab的实现，不是很复杂：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FragmentTab &#123;</span><br><span class=\"line\">    FragmentManager mFragmentManager;</span><br><span class=\"line\">    HashMap&lt;String, TabItem&gt; mTabItems = new HashMap&lt;String, TabItem&gt;();</span><br><span class=\"line\">    TabItem mSelectedTabItem;</span><br><span class=\"line\"></span><br><span class=\"line\">    public FragmentTab(FragmentManager mFragmentManager) &#123;</span><br><span class=\"line\">        this.mFragmentManager = mFragmentManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void addTabItem(TabItem item) &#123;</span><br><span class=\"line\">        mTabItems.put(item.getTag(), item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void selectTab(String tag) &#123;</span><br><span class=\"line\">        selectTab(mTabItems.get(tag));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void selectTab(TabItem tabItem) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        final FragmentTransaction trans = mFragmentManager.beginTransaction()</span><br><span class=\"line\">                .disallowAddToBackStack();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mSelectedTabItem == tabItem) &#123;</span><br><span class=\"line\">            if (mSelectedTabItem != null) &#123;</span><br><span class=\"line\">                mSelectedTabItem.onTabReselected(mSelectedTabItem, trans);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (mSelectedTabItem != null) &#123;</span><br><span class=\"line\">                mSelectedTabItem.onTabUnselected(mSelectedTabItem, trans);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mSelectedTabItem = tabItem;</span><br><span class=\"line\">            if (mSelectedTabItem != null) &#123;</span><br><span class=\"line\">                mSelectedTabItem.onTabSelected(mSelectedTabItem, trans);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!trans.isEmpty()) &#123;</span><br><span class=\"line\">            trans.commit();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出我们实际上只有两个方法可以调用<code>addTabItem(TabItem item)</code>和<code>selectTab(TabItem item)</code> ，一个添加tab和一个选择tab。</p>\n<p>TabItem是一个抽象类,构造函数中的<code>Class&lt;T&gt; mClass</code>是Fragment的类，以及它的参数<code>Bundle mArgs</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TabItem&lt;T&gt; implements TabListener &#123;</span><br><span class=\"line\">    protected final Context mContext;</span><br><span class=\"line\">    protected final String mTag;</span><br><span class=\"line\">    protected final Class&lt;T&gt; mClass;</span><br><span class=\"line\">    protected final Bundle mArgs;</span><br><span class=\"line\">    protected Fragment mFragment;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TabItem(Context ctx, String mTag, Class&lt;T&gt; mClass) &#123;</span><br><span class=\"line\">        this(ctx, mTag, mClass, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TabItem(Context ctx, String mTag, Class&lt;T&gt; mClass, Bundle mArgs) &#123;</span><br><span class=\"line\">        this.mContext = ctx;</span><br><span class=\"line\">        this.mTag = mTag;</span><br><span class=\"line\">        this.mClass = mClass;</span><br><span class=\"line\">        this.mArgs = mArgs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getTag() &#123;</span><br><span class=\"line\">        return mTag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TabListener接口定义了3个方法，tab选中时，tab从选中切换到未被选中时，以及再次被选中时。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface TabListener &#123;</span><br><span class=\"line\">    public void onTabSelected(TabItem tab, FragmentTransaction ft);</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onTabUnselected(TabItem tab, FragmentTransaction ft);</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onTabReselected(TabItem tab, FragmentTransaction ft);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后就是TabItem的实现了，默认行为与ActionBar.Tab是一致的，更多使用帮助：<a href=\"https://github.com/LinkYan/Android-FragmentTab\" target=\"_blank\" rel=\"noopener\">Github：Android-FragmentTab</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TabItemImpl&lt;T&gt; extends TabItem&lt;T&gt; implements TabListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public TabItemImpl(Context ctx, String mTag, Class&lt;T&gt; mClass) &#123;</span><br><span class=\"line\">        super(ctx, mTag, mClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TabItemImpl(Context ctx, String mTag, Class&lt;T&gt; mClass, Bundle mArgs) &#123;</span><br><span class=\"line\">        super(ctx, mTag, mClass, mArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTabSelected(TabItem tab, FragmentTransaction ft) &#123;</span><br><span class=\"line\">        if (mFragment == null) &#123;</span><br><span class=\"line\">            mFragment = Fragment.instantiate(mContext, mClass.getName(), mArgs);</span><br><span class=\"line\">            ft.add(R.id.layout_contain, mFragment, mTag);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ft.attach(mFragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTabUnselected(TabItem tab, FragmentTransaction ft) &#123;</span><br><span class=\"line\">        if (mFragment != null) &#123;</span><br><span class=\"line\">            ft.detach(mFragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTabReselected(TabItem tab, FragmentTransaction ft) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在Android3.0以上以及android.support.v4包中包含了ActionBar这个控件，十分好用的一个模块就是它的<a href=\"http://developer.android.com/reference/android/app/ActionBar.Tab.html\" target=\"_blank\" rel=\"noopener\">ActionBar.Tab</a>.<strong>但是</strong>，它将布局与Fragment的管理耦合在了一起，假如我们想定制的话，还是需要花费一点功夫的，所以我将它们解耦，简化了一下，单独拿了出来。点击查看：<a href=\"https://github.com/LinkYan/Android-FragmentTab\" target=\"_blank\" rel=\"noopener\">Github：Android-FragmentTab</a></p>\n<p>首先让我们看看FragmentTab的实现，不是很复杂：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FragmentTab &#123;</span><br><span class=\"line\">    FragmentManager mFragmentManager;</span><br><span class=\"line\">    HashMap&lt;String, TabItem&gt; mTabItems = new HashMap&lt;String, TabItem&gt;();</span><br><span class=\"line\">    TabItem mSelectedTabItem;</span><br><span class=\"line\"></span><br><span class=\"line\">    public FragmentTab(FragmentManager mFragmentManager) &#123;</span><br><span class=\"line\">        this.mFragmentManager = mFragmentManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void addTabItem(TabItem item) &#123;</span><br><span class=\"line\">        mTabItems.put(item.getTag(), item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void selectTab(String tag) &#123;</span><br><span class=\"line\">        selectTab(mTabItems.get(tag));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void selectTab(TabItem tabItem) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        final FragmentTransaction trans = mFragmentManager.beginTransaction()</span><br><span class=\"line\">                .disallowAddToBackStack();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mSelectedTabItem == tabItem) &#123;</span><br><span class=\"line\">            if (mSelectedTabItem != null) &#123;</span><br><span class=\"line\">                mSelectedTabItem.onTabReselected(mSelectedTabItem, trans);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (mSelectedTabItem != null) &#123;</span><br><span class=\"line\">                mSelectedTabItem.onTabUnselected(mSelectedTabItem, trans);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mSelectedTabItem = tabItem;</span><br><span class=\"line\">            if (mSelectedTabItem != null) &#123;</span><br><span class=\"line\">                mSelectedTabItem.onTabSelected(mSelectedTabItem, trans);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!trans.isEmpty()) &#123;</span><br><span class=\"line\">            trans.commit();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出我们实际上只有两个方法可以调用<code>addTabItem(TabItem item)</code>和<code>selectTab(TabItem item)</code> ，一个添加tab和一个选择tab。</p>\n<p>TabItem是一个抽象类,构造函数中的<code>Class&lt;T&gt; mClass</code>是Fragment的类，以及它的参数<code>Bundle mArgs</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TabItem&lt;T&gt; implements TabListener &#123;</span><br><span class=\"line\">    protected final Context mContext;</span><br><span class=\"line\">    protected final String mTag;</span><br><span class=\"line\">    protected final Class&lt;T&gt; mClass;</span><br><span class=\"line\">    protected final Bundle mArgs;</span><br><span class=\"line\">    protected Fragment mFragment;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TabItem(Context ctx, String mTag, Class&lt;T&gt; mClass) &#123;</span><br><span class=\"line\">        this(ctx, mTag, mClass, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TabItem(Context ctx, String mTag, Class&lt;T&gt; mClass, Bundle mArgs) &#123;</span><br><span class=\"line\">        this.mContext = ctx;</span><br><span class=\"line\">        this.mTag = mTag;</span><br><span class=\"line\">        this.mClass = mClass;</span><br><span class=\"line\">        this.mArgs = mArgs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getTag() &#123;</span><br><span class=\"line\">        return mTag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TabListener接口定义了3个方法，tab选中时，tab从选中切换到未被选中时，以及再次被选中时。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface TabListener &#123;</span><br><span class=\"line\">    public void onTabSelected(TabItem tab, FragmentTransaction ft);</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onTabUnselected(TabItem tab, FragmentTransaction ft);</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onTabReselected(TabItem tab, FragmentTransaction ft);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后就是TabItem的实现了，默认行为与ActionBar.Tab是一致的，更多使用帮助：<a href=\"https://github.com/LinkYan/Android-FragmentTab\" target=\"_blank\" rel=\"noopener\">Github：Android-FragmentTab</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TabItemImpl&lt;T&gt; extends TabItem&lt;T&gt; implements TabListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public TabItemImpl(Context ctx, String mTag, Class&lt;T&gt; mClass) &#123;</span><br><span class=\"line\">        super(ctx, mTag, mClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TabItemImpl(Context ctx, String mTag, Class&lt;T&gt; mClass, Bundle mArgs) &#123;</span><br><span class=\"line\">        super(ctx, mTag, mClass, mArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTabSelected(TabItem tab, FragmentTransaction ft) &#123;</span><br><span class=\"line\">        if (mFragment == null) &#123;</span><br><span class=\"line\">            mFragment = Fragment.instantiate(mContext, mClass.getName(), mArgs);</span><br><span class=\"line\">            ft.add(R.id.layout_contain, mFragment, mTag);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            ft.attach(mFragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTabUnselected(TabItem tab, FragmentTransaction ft) &#123;</span><br><span class=\"line\">        if (mFragment != null) &#123;</span><br><span class=\"line\">            ft.detach(mFragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onTabReselected(TabItem tab, FragmentTransaction ft) &#123;</span><br><span class=\"line\">        //ToDo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","date":"2013-06-09T16:00:00.000Z","title":"程序员能力矩阵 Programmer Competency Matrix","_content":"\nwow,总结的太棒了，programmer可以对应的在每个项目上打分，再转出一个直观的图表，就是一份好简历\n\n###[原文连接](http://static.icybear.net/%5BCN%5DProgrammer%20competency%20matrix.htm)\n","source":"_posts/2013-06-10-programmer-competency-matrix.md","raw":"---\nlayout: post\ncategory: Android\ndate: 2013-06-10\ntitle: 程序员能力矩阵 Programmer Competency Matrix\n---\n\nwow,总结的太棒了，programmer可以对应的在每个项目上打分，再转出一个直观的图表，就是一份好简历\n\n###[原文连接](http://static.icybear.net/%5BCN%5DProgrammer%20competency%20matrix.htm)\n","slug":"2013-06-10-programmer-competency-matrix","published":1,"updated":"2018-02-14T21:36:14.835Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlp000yrpfyes06fh53","content":"<p>wow,总结的太棒了，programmer可以对应的在每个项目上打分，再转出一个直观的图表，就是一份好简历</p>\n<p>###<a href=\"http://static.icybear.net/%5BCN%5DProgrammer%20competency%20matrix.htm\" target=\"_blank\" rel=\"noopener\">原文连接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>wow,总结的太棒了，programmer可以对应的在每个项目上打分，再转出一个直观的图表，就是一份好简历</p>\n<p>###<a href=\"http://static.icybear.net/%5BCN%5DProgrammer%20competency%20matrix.htm\" target=\"_blank\" rel=\"noopener\">原文连接</a></p>\n"},{"date":"2013-06-12T16:00:00.000Z","layout":"post","title":"Android 四种特殊Interpolator源码解析","_content":"\n今天介绍4种动画插值器\n\n1. OvershootInterpolator： \"Overshoot\" means 冲过头了，模拟了冲过了头回滚一点的效果\n2. AnticipateInterpolator：“Anticipate” means 抢先，模拟了出发前先后退一步再前冲的动画效果\n3. AnticipateOvershootInterpolator：以上两种的结合\n4. BounceInterpolator：\"Bounce\" means 弹跳, 就是模拟了自由落地后回弹的效果\n\n##OvershootInterpolation\n---\n先来看Overshoot的实现的数学公式,mTension默认值为2.0f,有一个构造函数可以进行设置。\n\n    public float getInterpolation(float t) {\n        t -= 1.0f;\n        return t * t * ((mTension + 1) * t + mTension) + 1.0f;\n    }\n\n如果带入默认值，简化下就是\n\n\ty=3t^3+2t^2+1  // t:[-1~0]\n\n然后去google搜索一下\"3t^3+2t^2+1\",就能看到下面这个曲线图\n\n![overshoot](http://pic.yupoo.com/wsyanligang_v/CVV0gdj5/14rU1Z.png)\n\n我们改下参数mTension,就能发现`mTension越大，冲过的距离越大，效果越明显!`\n\n##AnticipateInterpolation\n---\n再看下Anticipate的实现数学公式，mTension同样默认是2.0f：\n\n    public float getInterpolation(float t) {\n        return t * t * ((mTension + 1) * t - mTension);\n    }\n\n于是带上实际参数2.0f，得到\n\n```\ny=3t^3-2t^2 //t:[0~1.0]\n```\n\n![anticipate](http://pic.yupoo.com/wsyanligang_v/CVV0gQsS/13bFN5.png)\n\n同样的结论：`mTension越大，抢先动画约长，效果越明显！`\n\n##BounceInterpolator\n---\n从源码我们能发现，实现方式是根据时间t，模拟了一次自由落体运动，所以Google这次帮不了我们了。\n\n    private static float bounce(float t) {\n        return t * t * 8.0f;\n    }\n\n    public float getInterpolation(float t) {\n        t *= 1.1226f;\n        if (t < 0.3535f) return bounce(t);\n        else if (t < 0.7408f) return bounce(t - 0.54719f) + 0.7f;\n        else if (t < 0.9644f) return bounce(t - 0.8526f) + 0.9f;\n        else return bounce(t - 1.0435f) + 0.95f;\n    }\n","source":"_posts/2013-06-13-animation-interpolator.md","raw":"---\ncategory: Android\ndate: 2013-06-13\nlayout: post\ntitle: Android 四种特殊Interpolator源码解析\n---\n\n今天介绍4种动画插值器\n\n1. OvershootInterpolator： \"Overshoot\" means 冲过头了，模拟了冲过了头回滚一点的效果\n2. AnticipateInterpolator：“Anticipate” means 抢先，模拟了出发前先后退一步再前冲的动画效果\n3. AnticipateOvershootInterpolator：以上两种的结合\n4. BounceInterpolator：\"Bounce\" means 弹跳, 就是模拟了自由落地后回弹的效果\n\n##OvershootInterpolation\n---\n先来看Overshoot的实现的数学公式,mTension默认值为2.0f,有一个构造函数可以进行设置。\n\n    public float getInterpolation(float t) {\n        t -= 1.0f;\n        return t * t * ((mTension + 1) * t + mTension) + 1.0f;\n    }\n\n如果带入默认值，简化下就是\n\n\ty=3t^3+2t^2+1  // t:[-1~0]\n\n然后去google搜索一下\"3t^3+2t^2+1\",就能看到下面这个曲线图\n\n![overshoot](http://pic.yupoo.com/wsyanligang_v/CVV0gdj5/14rU1Z.png)\n\n我们改下参数mTension,就能发现`mTension越大，冲过的距离越大，效果越明显!`\n\n##AnticipateInterpolation\n---\n再看下Anticipate的实现数学公式，mTension同样默认是2.0f：\n\n    public float getInterpolation(float t) {\n        return t * t * ((mTension + 1) * t - mTension);\n    }\n\n于是带上实际参数2.0f，得到\n\n```\ny=3t^3-2t^2 //t:[0~1.0]\n```\n\n![anticipate](http://pic.yupoo.com/wsyanligang_v/CVV0gQsS/13bFN5.png)\n\n同样的结论：`mTension越大，抢先动画约长，效果越明显！`\n\n##BounceInterpolator\n---\n从源码我们能发现，实现方式是根据时间t，模拟了一次自由落体运动，所以Google这次帮不了我们了。\n\n    private static float bounce(float t) {\n        return t * t * 8.0f;\n    }\n\n    public float getInterpolation(float t) {\n        t *= 1.1226f;\n        if (t < 0.3535f) return bounce(t);\n        else if (t < 0.7408f) return bounce(t - 0.54719f) + 0.7f;\n        else if (t < 0.9644f) return bounce(t - 0.8526f) + 0.9f;\n        else return bounce(t - 1.0435f) + 0.95f;\n    }\n","slug":"2013-06-13-animation-interpolator","published":1,"updated":"2018-02-14T21:36:14.835Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlq0010rpfyngd793m2","content":"<p>今天介绍4种动画插值器</p>\n<ol>\n<li>OvershootInterpolator： “Overshoot” means 冲过头了，模拟了冲过了头回滚一点的效果</li>\n<li>AnticipateInterpolator：“Anticipate” means 抢先，模拟了出发前先后退一步再前冲的动画效果</li>\n<li>AnticipateOvershootInterpolator：以上两种的结合</li>\n<li>BounceInterpolator：”Bounce” means 弹跳, 就是模拟了自由落地后回弹的效果</li>\n</ol>\n<h2 id=\"OvershootInterpolation\"><a href=\"#OvershootInterpolation\" class=\"headerlink\" title=\"##OvershootInterpolation\"></a>##OvershootInterpolation</h2><p>先来看Overshoot的实现的数学公式,mTension默认值为2.0f,有一个构造函数可以进行设置。</p>\n<pre><code>public float getInterpolation(float t) {\n    t -= 1.0f;\n    return t * t * ((mTension + 1) * t + mTension) + 1.0f;\n}\n</code></pre><p>如果带入默认值，简化下就是</p>\n<pre><code>y=3t^3+2t^2+1  // t:[-1~0]\n</code></pre><p>然后去google搜索一下”3t^3+2t^2+1”,就能看到下面这个曲线图</p>\n<p><img src=\"http://pic.yupoo.com/wsyanligang_v/CVV0gdj5/14rU1Z.png\" alt=\"overshoot\"></p>\n<p>我们改下参数mTension,就能发现<code>mTension越大，冲过的距离越大，效果越明显!</code></p>\n<h2 id=\"AnticipateInterpolation\"><a href=\"#AnticipateInterpolation\" class=\"headerlink\" title=\"##AnticipateInterpolation\"></a>##AnticipateInterpolation</h2><p>再看下Anticipate的实现数学公式，mTension同样默认是2.0f：</p>\n<pre><code>public float getInterpolation(float t) {\n    return t * t * ((mTension + 1) * t - mTension);\n}\n</code></pre><p>于是带上实际参数2.0f，得到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y=3t^3-2t^2 //t:[0~1.0]</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://pic.yupoo.com/wsyanligang_v/CVV0gQsS/13bFN5.png\" alt=\"anticipate\"></p>\n<p>同样的结论：<code>mTension越大，抢先动画约长，效果越明显！</code></p>\n<h2 id=\"BounceInterpolator\"><a href=\"#BounceInterpolator\" class=\"headerlink\" title=\"##BounceInterpolator\"></a>##BounceInterpolator</h2><p>从源码我们能发现，实现方式是根据时间t，模拟了一次自由落体运动，所以Google这次帮不了我们了。</p>\n<pre><code>private static float bounce(float t) {\n    return t * t * 8.0f;\n}\n\npublic float getInterpolation(float t) {\n    t *= 1.1226f;\n    if (t &lt; 0.3535f) return bounce(t);\n    else if (t &lt; 0.7408f) return bounce(t - 0.54719f) + 0.7f;\n    else if (t &lt; 0.9644f) return bounce(t - 0.8526f) + 0.9f;\n    else return bounce(t - 1.0435f) + 0.95f;\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>今天介绍4种动画插值器</p>\n<ol>\n<li>OvershootInterpolator： “Overshoot” means 冲过头了，模拟了冲过了头回滚一点的效果</li>\n<li>AnticipateInterpolator：“Anticipate” means 抢先，模拟了出发前先后退一步再前冲的动画效果</li>\n<li>AnticipateOvershootInterpolator：以上两种的结合</li>\n<li>BounceInterpolator：”Bounce” means 弹跳, 就是模拟了自由落地后回弹的效果</li>\n</ol>\n<h2 id=\"OvershootInterpolation\"><a href=\"#OvershootInterpolation\" class=\"headerlink\" title=\"##OvershootInterpolation\"></a>##OvershootInterpolation</h2><p>先来看Overshoot的实现的数学公式,mTension默认值为2.0f,有一个构造函数可以进行设置。</p>\n<pre><code>public float getInterpolation(float t) {\n    t -= 1.0f;\n    return t * t * ((mTension + 1) * t + mTension) + 1.0f;\n}\n</code></pre><p>如果带入默认值，简化下就是</p>\n<pre><code>y=3t^3+2t^2+1  // t:[-1~0]\n</code></pre><p>然后去google搜索一下”3t^3+2t^2+1”,就能看到下面这个曲线图</p>\n<p><img src=\"http://pic.yupoo.com/wsyanligang_v/CVV0gdj5/14rU1Z.png\" alt=\"overshoot\"></p>\n<p>我们改下参数mTension,就能发现<code>mTension越大，冲过的距离越大，效果越明显!</code></p>\n<h2 id=\"AnticipateInterpolation\"><a href=\"#AnticipateInterpolation\" class=\"headerlink\" title=\"##AnticipateInterpolation\"></a>##AnticipateInterpolation</h2><p>再看下Anticipate的实现数学公式，mTension同样默认是2.0f：</p>\n<pre><code>public float getInterpolation(float t) {\n    return t * t * ((mTension + 1) * t - mTension);\n}\n</code></pre><p>于是带上实际参数2.0f，得到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y=3t^3-2t^2 //t:[0~1.0]</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://pic.yupoo.com/wsyanligang_v/CVV0gQsS/13bFN5.png\" alt=\"anticipate\"></p>\n<p>同样的结论：<code>mTension越大，抢先动画约长，效果越明显！</code></p>\n<h2 id=\"BounceInterpolator\"><a href=\"#BounceInterpolator\" class=\"headerlink\" title=\"##BounceInterpolator\"></a>##BounceInterpolator</h2><p>从源码我们能发现，实现方式是根据时间t，模拟了一次自由落体运动，所以Google这次帮不了我们了。</p>\n<pre><code>private static float bounce(float t) {\n    return t * t * 8.0f;\n}\n\npublic float getInterpolation(float t) {\n    t *= 1.1226f;\n    if (t &lt; 0.3535f) return bounce(t);\n    else if (t &lt; 0.7408f) return bounce(t - 0.54719f) + 0.7f;\n    else if (t &lt; 0.9644f) return bounce(t - 0.8526f) + 0.9f;\n    else return bounce(t - 1.0435f) + 0.95f;\n}\n</code></pre>"},{"date":"2013-06-13T16:00:00.000Z","layout":"post","title":"呼吸灯特效-使用PropertyAnimation","_content":"\n\n >成人平静时的呼吸频率约为每分钟12-20次;儿童约为每分钟20次;一般女性比男性快1-2次.\n\n我们假设为平均为15次每分钟吧，一个循环大概是4秒，暂定模拟前2.7后1.3,那么我们就先来编写动画:\n\nanimator/anim_breath.xml\n\n```\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t <!-顺序动画->\n     android:ordering=\"sequentially\">\n    <set\n    \t<!--插值器使用立方减速 效果很逼真-->\n    \tandroid:interpolator=\"@android:interpolator/decelerate_cubic\"\n    \tandroid:ordering=\"together\">\n    \t<!--同步动画-->\n     \t<!--X Y轴同时放大5% -->\n        <objectAnimator\n                android:propertyName=\"scaleX\"\n                android:duration=\"2700\"\n                android:valueTo=\"1.05\"\n                android:valueFrom=\"1\"\n                android:valueType=\"floatType\"/>\n        <objectAnimator\n                android:propertyName=\"scaleY\"\n                android:duration=\"2700\"\n                android:valueTo=\"1.05\"\n                android:valueFrom=\"1\"\n                android:valueType=\"floatType\"/>\n    </set>\n    <set\n    \tandroid:interpolator=\"@android:interpolator/decelerate_cubic\"\n    \tandroid:ordering=\"together\">\n\t    <!--X Y轴同时缩小回原始大小 -->\n        <objectAnimator\n                android:propertyName=\"scaleX\"\n                android:duration=\"1300\"\n                android:valueTo=\"1\"\n                android:valueFrom=\"1.05\"\n                android:valueType=\"floatType\"/>\n        <objectAnimator\n                android:propertyName=\"scaleY\"\n                android:duration=\"1300\"\n                android:valueTo=\"1\"\n                android:valueFrom=\"1.05\"\n                android:valueType=\"floatType\"/>\n    </set>\n</set>\n```\n\n然后我们适当的封装下，不知道为什么repeat设置无效，先用这样不妥的方式吧。\n\n```\npublic class BreathAnim {\n    AnimatorSet mSet;\n\n    public BreathAnim(Context ctx, int animRid, Object target) {\n        mSet = (AnimatorSet) AnimatorInflater.loadAnimator(ctx, animRid);\n        mSet.setTarget(target);\n        mSet.addListener(new Animator.AnimatorListener() {\n           \t …\n           \t@Override\n            public void onAnimationEnd(Animator animation) {\n                //ToDo\n                mSet.start();\n            }\n\t\t\t...\n        });\n    }\n\n    public void start() {\n        mSet.start();\n    }\n\n    public void cancel() {\n        mSet.cancel();\n        mSet = null;\n    }\n}\n```\n\n最后简单调用\n\n```\nBreathAnim ba=new BreathAnim(context,R.animator.anim_breath,mTargetView);\nba.start();\n```\n\n给个差不多的效果，但是我没有做亮度这个维度 [戳这里->JS呼吸灯](http://www.iinterest.net/2009/12/10/breathing-light-botton/)\n\n**Notice:暂时没有去使用[NineOldAndroids](https://github.com/JakeWharton/NineOldAndroids),所以只能在API 11+使用，稍微改改还算简单。**\n","source":"_posts/2013-06-14-breath.md","raw":"---\ncategory: Android\ndate: 2013-06-14\nlayout: post\ntitle: 呼吸灯特效-使用PropertyAnimation\n---\n\n\n >成人平静时的呼吸频率约为每分钟12-20次;儿童约为每分钟20次;一般女性比男性快1-2次.\n\n我们假设为平均为15次每分钟吧，一个循环大概是4秒，暂定模拟前2.7后1.3,那么我们就先来编写动画:\n\nanimator/anim_breath.xml\n\n```\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t <!-顺序动画->\n     android:ordering=\"sequentially\">\n    <set\n    \t<!--插值器使用立方减速 效果很逼真-->\n    \tandroid:interpolator=\"@android:interpolator/decelerate_cubic\"\n    \tandroid:ordering=\"together\">\n    \t<!--同步动画-->\n     \t<!--X Y轴同时放大5% -->\n        <objectAnimator\n                android:propertyName=\"scaleX\"\n                android:duration=\"2700\"\n                android:valueTo=\"1.05\"\n                android:valueFrom=\"1\"\n                android:valueType=\"floatType\"/>\n        <objectAnimator\n                android:propertyName=\"scaleY\"\n                android:duration=\"2700\"\n                android:valueTo=\"1.05\"\n                android:valueFrom=\"1\"\n                android:valueType=\"floatType\"/>\n    </set>\n    <set\n    \tandroid:interpolator=\"@android:interpolator/decelerate_cubic\"\n    \tandroid:ordering=\"together\">\n\t    <!--X Y轴同时缩小回原始大小 -->\n        <objectAnimator\n                android:propertyName=\"scaleX\"\n                android:duration=\"1300\"\n                android:valueTo=\"1\"\n                android:valueFrom=\"1.05\"\n                android:valueType=\"floatType\"/>\n        <objectAnimator\n                android:propertyName=\"scaleY\"\n                android:duration=\"1300\"\n                android:valueTo=\"1\"\n                android:valueFrom=\"1.05\"\n                android:valueType=\"floatType\"/>\n    </set>\n</set>\n```\n\n然后我们适当的封装下，不知道为什么repeat设置无效，先用这样不妥的方式吧。\n\n```\npublic class BreathAnim {\n    AnimatorSet mSet;\n\n    public BreathAnim(Context ctx, int animRid, Object target) {\n        mSet = (AnimatorSet) AnimatorInflater.loadAnimator(ctx, animRid);\n        mSet.setTarget(target);\n        mSet.addListener(new Animator.AnimatorListener() {\n           \t …\n           \t@Override\n            public void onAnimationEnd(Animator animation) {\n                //ToDo\n                mSet.start();\n            }\n\t\t\t...\n        });\n    }\n\n    public void start() {\n        mSet.start();\n    }\n\n    public void cancel() {\n        mSet.cancel();\n        mSet = null;\n    }\n}\n```\n\n最后简单调用\n\n```\nBreathAnim ba=new BreathAnim(context,R.animator.anim_breath,mTargetView);\nba.start();\n```\n\n给个差不多的效果，但是我没有做亮度这个维度 [戳这里->JS呼吸灯](http://www.iinterest.net/2009/12/10/breathing-light-botton/)\n\n**Notice:暂时没有去使用[NineOldAndroids](https://github.com/JakeWharton/NineOldAndroids),所以只能在API 11+使用，稍微改改还算简单。**\n","slug":"2013-06-14-breath","published":1,"updated":"2018-02-14T21:36:14.836Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlr0012rpfyt8u0sz4d","content":"<blockquote>\n<p>成人平静时的呼吸频率约为每分钟12-20次;儿童约为每分钟20次;一般女性比男性快1-2次.</p>\n</blockquote>\n<p>我们假设为平均为15次每分钟吧，一个循环大概是4秒，暂定模拟前2.7后1.3,那么我们就先来编写动画:</p>\n<p>animator/anim_breath.xml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\t &lt;!-顺序动画-&gt;</span><br><span class=\"line\">     android:ordering=&quot;sequentially&quot;&gt;</span><br><span class=\"line\">    &lt;set</span><br><span class=\"line\">    \t&lt;!--插值器使用立方减速 效果很逼真--&gt;</span><br><span class=\"line\">    \tandroid:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;</span><br><span class=\"line\">    \tandroid:ordering=&quot;together&quot;&gt;</span><br><span class=\"line\">    \t&lt;!--同步动画--&gt;</span><br><span class=\"line\">     \t&lt;!--X Y轴同时放大5% --&gt;</span><br><span class=\"line\">        &lt;objectAnimator</span><br><span class=\"line\">                android:propertyName=&quot;scaleX&quot;</span><br><span class=\"line\">                android:duration=&quot;2700&quot;</span><br><span class=\"line\">                android:valueTo=&quot;1.05&quot;</span><br><span class=\"line\">                android:valueFrom=&quot;1&quot;</span><br><span class=\"line\">                android:valueType=&quot;floatType&quot;/&gt;</span><br><span class=\"line\">        &lt;objectAnimator</span><br><span class=\"line\">                android:propertyName=&quot;scaleY&quot;</span><br><span class=\"line\">                android:duration=&quot;2700&quot;</span><br><span class=\"line\">                android:valueTo=&quot;1.05&quot;</span><br><span class=\"line\">                android:valueFrom=&quot;1&quot;</span><br><span class=\"line\">                android:valueType=&quot;floatType&quot;/&gt;</span><br><span class=\"line\">    &lt;/set&gt;</span><br><span class=\"line\">    &lt;set</span><br><span class=\"line\">    \tandroid:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;</span><br><span class=\"line\">    \tandroid:ordering=&quot;together&quot;&gt;</span><br><span class=\"line\">\t    &lt;!--X Y轴同时缩小回原始大小 --&gt;</span><br><span class=\"line\">        &lt;objectAnimator</span><br><span class=\"line\">                android:propertyName=&quot;scaleX&quot;</span><br><span class=\"line\">                android:duration=&quot;1300&quot;</span><br><span class=\"line\">                android:valueTo=&quot;1&quot;</span><br><span class=\"line\">                android:valueFrom=&quot;1.05&quot;</span><br><span class=\"line\">                android:valueType=&quot;floatType&quot;/&gt;</span><br><span class=\"line\">        &lt;objectAnimator</span><br><span class=\"line\">                android:propertyName=&quot;scaleY&quot;</span><br><span class=\"line\">                android:duration=&quot;1300&quot;</span><br><span class=\"line\">                android:valueTo=&quot;1&quot;</span><br><span class=\"line\">                android:valueFrom=&quot;1.05&quot;</span><br><span class=\"line\">                android:valueType=&quot;floatType&quot;/&gt;</span><br><span class=\"line\">    &lt;/set&gt;</span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n<p>然后我们适当的封装下，不知道为什么repeat设置无效，先用这样不妥的方式吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BreathAnim &#123;</span><br><span class=\"line\">    AnimatorSet mSet;</span><br><span class=\"line\"></span><br><span class=\"line\">    public BreathAnim(Context ctx, int animRid, Object target) &#123;</span><br><span class=\"line\">        mSet = (AnimatorSet) AnimatorInflater.loadAnimator(ctx, animRid);</span><br><span class=\"line\">        mSet.setTarget(target);</span><br><span class=\"line\">        mSet.addListener(new Animator.AnimatorListener() &#123;</span><br><span class=\"line\">           \t …</span><br><span class=\"line\">           \t@Override</span><br><span class=\"line\">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class=\"line\">                //ToDo</span><br><span class=\"line\">                mSet.start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void start() &#123;</span><br><span class=\"line\">        mSet.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void cancel() &#123;</span><br><span class=\"line\">        mSet.cancel();</span><br><span class=\"line\">        mSet = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后简单调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BreathAnim ba=new BreathAnim(context,R.animator.anim_breath,mTargetView);</span><br><span class=\"line\">ba.start();</span><br></pre></td></tr></table></figure>\n<p>给个差不多的效果，但是我没有做亮度这个维度 <a href=\"http://www.iinterest.net/2009/12/10/breathing-light-botton/\" target=\"_blank\" rel=\"noopener\">戳这里-&gt;JS呼吸灯</a></p>\n<p><strong>Notice:暂时没有去使用<a href=\"https://github.com/JakeWharton/NineOldAndroids\" target=\"_blank\" rel=\"noopener\">NineOldAndroids</a>,所以只能在API 11+使用，稍微改改还算简单。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>成人平静时的呼吸频率约为每分钟12-20次;儿童约为每分钟20次;一般女性比男性快1-2次.</p>\n</blockquote>\n<p>我们假设为平均为15次每分钟吧，一个循环大概是4秒，暂定模拟前2.7后1.3,那么我们就先来编写动画:</p>\n<p>animator/anim_breath.xml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">\t &lt;!-顺序动画-&gt;</span><br><span class=\"line\">     android:ordering=&quot;sequentially&quot;&gt;</span><br><span class=\"line\">    &lt;set</span><br><span class=\"line\">    \t&lt;!--插值器使用立方减速 效果很逼真--&gt;</span><br><span class=\"line\">    \tandroid:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;</span><br><span class=\"line\">    \tandroid:ordering=&quot;together&quot;&gt;</span><br><span class=\"line\">    \t&lt;!--同步动画--&gt;</span><br><span class=\"line\">     \t&lt;!--X Y轴同时放大5% --&gt;</span><br><span class=\"line\">        &lt;objectAnimator</span><br><span class=\"line\">                android:propertyName=&quot;scaleX&quot;</span><br><span class=\"line\">                android:duration=&quot;2700&quot;</span><br><span class=\"line\">                android:valueTo=&quot;1.05&quot;</span><br><span class=\"line\">                android:valueFrom=&quot;1&quot;</span><br><span class=\"line\">                android:valueType=&quot;floatType&quot;/&gt;</span><br><span class=\"line\">        &lt;objectAnimator</span><br><span class=\"line\">                android:propertyName=&quot;scaleY&quot;</span><br><span class=\"line\">                android:duration=&quot;2700&quot;</span><br><span class=\"line\">                android:valueTo=&quot;1.05&quot;</span><br><span class=\"line\">                android:valueFrom=&quot;1&quot;</span><br><span class=\"line\">                android:valueType=&quot;floatType&quot;/&gt;</span><br><span class=\"line\">    &lt;/set&gt;</span><br><span class=\"line\">    &lt;set</span><br><span class=\"line\">    \tandroid:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;</span><br><span class=\"line\">    \tandroid:ordering=&quot;together&quot;&gt;</span><br><span class=\"line\">\t    &lt;!--X Y轴同时缩小回原始大小 --&gt;</span><br><span class=\"line\">        &lt;objectAnimator</span><br><span class=\"line\">                android:propertyName=&quot;scaleX&quot;</span><br><span class=\"line\">                android:duration=&quot;1300&quot;</span><br><span class=\"line\">                android:valueTo=&quot;1&quot;</span><br><span class=\"line\">                android:valueFrom=&quot;1.05&quot;</span><br><span class=\"line\">                android:valueType=&quot;floatType&quot;/&gt;</span><br><span class=\"line\">        &lt;objectAnimator</span><br><span class=\"line\">                android:propertyName=&quot;scaleY&quot;</span><br><span class=\"line\">                android:duration=&quot;1300&quot;</span><br><span class=\"line\">                android:valueTo=&quot;1&quot;</span><br><span class=\"line\">                android:valueFrom=&quot;1.05&quot;</span><br><span class=\"line\">                android:valueType=&quot;floatType&quot;/&gt;</span><br><span class=\"line\">    &lt;/set&gt;</span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n<p>然后我们适当的封装下，不知道为什么repeat设置无效，先用这样不妥的方式吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BreathAnim &#123;</span><br><span class=\"line\">    AnimatorSet mSet;</span><br><span class=\"line\"></span><br><span class=\"line\">    public BreathAnim(Context ctx, int animRid, Object target) &#123;</span><br><span class=\"line\">        mSet = (AnimatorSet) AnimatorInflater.loadAnimator(ctx, animRid);</span><br><span class=\"line\">        mSet.setTarget(target);</span><br><span class=\"line\">        mSet.addListener(new Animator.AnimatorListener() &#123;</span><br><span class=\"line\">           \t …</span><br><span class=\"line\">           \t@Override</span><br><span class=\"line\">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class=\"line\">                //ToDo</span><br><span class=\"line\">                mSet.start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void start() &#123;</span><br><span class=\"line\">        mSet.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void cancel() &#123;</span><br><span class=\"line\">        mSet.cancel();</span><br><span class=\"line\">        mSet = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后简单调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BreathAnim ba=new BreathAnim(context,R.animator.anim_breath,mTargetView);</span><br><span class=\"line\">ba.start();</span><br></pre></td></tr></table></figure>\n<p>给个差不多的效果，但是我没有做亮度这个维度 <a href=\"http://www.iinterest.net/2009/12/10/breathing-light-botton/\" target=\"_blank\" rel=\"noopener\">戳这里-&gt;JS呼吸灯</a></p>\n<p><strong>Notice:暂时没有去使用<a href=\"https://github.com/JakeWharton/NineOldAndroids\" target=\"_blank\" rel=\"noopener\">NineOldAndroids</a>,所以只能在API 11+使用，稍微改改还算简单。</strong></p>\n"},{"date":"2013-06-18T16:00:00.000Z","layout":"post","title":"Google官方指南-动画滚动手势","_content":"\nsource:[http://developer.android.com/training/gestures/scroll.html](http://developer.android.com/training/gestures/scroll.html)\n\n在Android中，通常我们使用ScrollView类来实现滑动。任何标准的布局都可能超出容器本身的边界，需要嵌套在由框架管理的可滑动视图的ScrollView中去展示。只有在需要特定的场景中，我们才可能需要去实现一个自定的Scroller。本章节描述了这么一个场景，显示一个使用了滑动器，响应触摸手势的滑动效果。\n\n你可以使用Scroller（如 Scroller 或者 OverScroller）去收集生产一个滑动动画所需要响应的触摸事件的数据。它们很类似，但是OverScroller包含指示用户甩动手势已经到达内容边界的方法。InteractiveChart示例使用了EdgeEffect类(准确地说是 EdgeEffectCompat类)去显示发光的效果，当用户到达内容的边界。\n\n>>>注意：我们建议你使用OverScroller而不是Scroller去实现滑动动画。OverScroller为旧的设备提供了最好的向后兼容性。\n\n\n同样提醒你通常只有你要自己实现滑动时才使用scrollers。ScrollView和HorizontalScrollView已经为你准备好一切，如果你把布局嵌套其中。\n\nScroller被用于随时间推移动画滚动，使用平台标准的滚动物理（摩擦，速度等）。Scroller其实本身不绘制任何东西。Scrollers随时间推移跟踪滚动偏移，但是他们不会自动地将你的视图移动到那些位置。而是应该由你去获取坐标并且按照一定的速率，以使得滚动动画看起来比较平滑。\n\n##理解滚动术语\n---\n\n\"Scrolling\"在不同的Android中不同的上下文有着不同的含义。\n\n- 滚动是移动视图窗口(viewport--也就是你正看到的内容的窗口)的一般过程。当同时在x和y轴滚动式，称为平移(panning)。在样品应用中提供了这样一个类，InteractiveChart,说明了两种类型的滚动,拖拽和甩动。\n- 拖动是一种滚动--发生在用户将他的手指在触摸屏上拖动。简单的拖动经常是通过重写GestureDetector.OnGestureListener类的onScroll()函数实现的。更多关于拖动的讨论，查看Dragging and Scaling.\n\n甩是一种滚动发生在用户拖动并快速抬起他的手指。在用户抬起他的手指后，你通常要保持滚动(移动视口),但是减速滚动直到视口停止移动。甩动作可以通过重写GestureDetector.OnGestureListener类的onFling()实现，并且使用一个scroller类。这就是本主题要将的使用情况。\n\n通常使用scroller对象关联甩手势，但他们可以被用在几乎任何你想要UI去反馈触摸事件显示滚动的上下文中。例如，你可以重写onTouchEvent()直接处理触摸事件，并且产生一个滚动效果或者一个吸附页面（snapping to page）动画响应那些触摸事件\n\n\n##实现基于触摸的滚动\n---\n\n本段描述了如何使用scroller类，下面展示的片段来自InteractiveChart。它使用了GestureDetector，并且重写GestureDetector.SimpleOnGestureListener中的onFling()。使用了OverScroller跟踪甩手势。如果用户在甩手势之后达到了内容的边界，应用会显示一个发光效果。\n\n>>>Note: The InteractiveChart sample app displays a chart that you can zoom, pan, scroll, and so on. In the following snippet, mContentRect represents the rectangle coordinates within the view that the chart will be drawn into. At any given time, a subset of the total chart domain and range are drawn into this rectangular area. mCurrentViewport represents the portion of the chart that is currently visible in the screen. Because pixel offsets are generally treated as integers, mContentRect is of the type Rect. Because the graph domain and range are decimal/float values, mCurrentViewport is of the type RectF.\n\n\nThe first part of the snippet shows the implementation of onFling():\n\n```\n// The current viewport. This rectangle represents the currently visible\n// chart domain and range. The viewport is the part of the app that the\n// user manipulates via touch gestures.\nprivate RectF mCurrentViewport =\n        new RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);\n\n// The current destination rectangle (in pixel coordinates) into which the\n// chart data should be drawn.\nprivate Rect mContentRect;\n\nprivate OverScroller mScroller;\nprivate RectF mScrollerStartViewport;\n...\nprivate final GestureDetector.SimpleOnGestureListener mGestureListener\n        = new GestureDetector.SimpleOnGestureListener() {\n    @Override\n    public boolean onDown(MotionEvent e) {\n        // Initiates the decay phase of any active edge effects.\n        releaseEdgeEffects();\n        mScrollerStartViewport.set(mCurrentViewport);\n        // Aborts any active scroll animations and invalidates.\n        mScroller.forceFinished(true);\n        ViewCompat.postInvalidateOnAnimation(InteractiveLineGraphView.this);\n        return true;\n    }\n    ...\n    @Override\n    public boolean onFling(MotionEvent e1, MotionEvent e2,\n            float velocityX, float velocityY) {\n        fling((int) -velocityX, (int) -velocityY);\n        return true;\n    }\n};\n\nprivate void fling(int velocityX, int velocityY) {\n    // Initiates the decay phase of any active edge effects.\n    releaseEdgeEffects();\n    // Flings use math in pixels (as opposed to math based on the viewport).\n    Point surfaceSize = computeScrollSurfaceSize();\n    mScrollerStartViewport.set(mCurrentViewport);\n    int startX = (int) (surfaceSize.x * (mScrollerStartViewport.left -\n            AXIS_X_MIN) / (\n            AXIS_X_MAX - AXIS_X_MIN));\n    int startY = (int) (surfaceSize.y * (AXIS_Y_MAX -\n            mScrollerStartViewport.bottom) / (\n            AXIS_Y_MAX - AXIS_Y_MIN));\n    // Before flinging, aborts the current animation.\n    mScroller.forceFinished(true);\n    // Begins the animation\n    mScroller.fling(\n            // Current scroll position\n            startX,\n            startY,\n            velocityX,\n            velocityY,\n            /*\n             * Minimum and maximum scroll positions. The minimum scroll\n             * position is generally zero and the maximum scroll position\n             * is generally the content size less the screen size. So if the\n             * content width is 1000 pixels and the screen width is 200  \n             * pixels, the maximum scroll offset should be 800 pixels.\n             */\n            0, surfaceSize.x - mContentRect.width(),\n            0, surfaceSize.y - mContentRect.height(),\n            // The edges of the content. This comes into play when using\n            // the EdgeEffect class to draw \"glow\" overlays.\n            mContentRect.width() / 2,\n            mContentRect.height() / 2);\n    // Invalidates to trigger computeScroll()\n    ViewCompat.postInvalidateOnAnimation(this);\n}\n```\n\n当onFling()调用postInvalidateOnAniamtion(),会触发computeScroll()去更新x,y的值。当一个子视图使用scroller动画显示一个滚动时，通常是必须要做的，就像是在例子中一样。\n\n\nMost views pass the scroller object's x and y position directly to scrollTo(). The following implementation of computeScroll() takes a different approach—it calls computeScrollOffset() to get the current location of x and y. When the criteria for displaying an overscroll \"glow\" edge effect are met (the display is zoomed in, x or y is out of bounds, and the app isn't already showing an overscroll), the code sets up the overscroll glow effect and calls postInvalidateOnAnimation() to trigger an invalidate on the view:\n\n```\n// Edge effect / overscroll tracking objects.\nprivate EdgeEffectCompat mEdgeEffectTop;\nprivate EdgeEffectCompat mEdgeEffectBottom;\nprivate EdgeEffectCompat mEdgeEffectLeft;\nprivate EdgeEffectCompat mEdgeEffectRight;\n\nprivate boolean mEdgeEffectTopActive;\nprivate boolean mEdgeEffectBottomActive;\nprivate boolean mEdgeEffectLeftActive;\nprivate boolean mEdgeEffectRightActive;\n\n@Override\npublic void computeScroll() {\n    super.computeScroll();\n\n    boolean needsInvalidate = false;\n\n    // The scroller isn't finished, meaning a fling or programmatic pan\n    // operation is currently active.\n    if (mScroller.computeScrollOffset()) {\n        Point surfaceSize = computeScrollSurfaceSize();\n        int currX = mScroller.getCurrX();\n        int currY = mScroller.getCurrY();\n\n        boolean canScrollX = (mCurrentViewport.left > AXIS_X_MIN\n                || mCurrentViewport.right < AXIS_X_MAX);\n        boolean canScrollY = (mCurrentViewport.top > AXIS_Y_MIN\n                || mCurrentViewport.bottom < AXIS_Y_MAX);\n\n        /*          \n         * If you are zoomed in and currX or currY is\n         * outside of bounds and you're not already\n         * showing overscroll, then render the overscroll\n         * glow edge effect.\n         */\n        if (canScrollX\n                && currX < 0\n                && mEdgeEffectLeft.isFinished()\n                && !mEdgeEffectLeftActive) {\n            mEdgeEffectLeft.onAbsorb((int)\n                    OverScrollerCompat.getCurrVelocity(mScroller));\n            mEdgeEffectLeftActive = true;\n            needsInvalidate = true;\n        } else if (canScrollX\n                && currX > (surfaceSize.x - mContentRect.width())\n                && mEdgeEffectRight.isFinished()\n                && !mEdgeEffectRightActive) {\n            mEdgeEffectRight.onAbsorb((int)\n                    OverScrollerCompat.getCurrVelocity(mScroller));\n            mEdgeEffectRightActive = true;\n            needsInvalidate = true;\n        }\n\n        if (canScrollY\n                && currY < 0\n                && mEdgeEffectTop.isFinished()\n                && !mEdgeEffectTopActive) {\n            mEdgeEffectTop.onAbsorb((int)\n                    OverScrollerCompat.getCurrVelocity(mScroller));\n            mEdgeEffectTopActive = true;\n            needsInvalidate = true;\n        } else if (canScrollY\n                && currY > (surfaceSize.y - mContentRect.height())\n                && mEdgeEffectBottom.isFinished()\n                && !mEdgeEffectBottomActive) {\n            mEdgeEffectBottom.onAbsorb((int)\n                    OverScrollerCompat.getCurrVelocity(mScroller));\n            mEdgeEffectBottomActive = true;\n            needsInvalidate = true;\n        }\n        ...\n    }\n```\n\nHere is the section of the code that performs the actual zoom:\n\n```\n// Custom object that is functionally similar to Scroller\nZoomer mZoomer;\nprivate PointF mZoomFocalPoint = new PointF();\n...\n\n// If a zoom is in progress (either programmatically or via double\n// touch), performs the zoom.\nif (mZoomer.computeZoom()) {\n    float newWidth = (1f - mZoomer.getCurrZoom()) *\n            mScrollerStartViewport.width();\n    float newHeight = (1f - mZoomer.getCurrZoom()) *\n            mScrollerStartViewport.height();\n    float pointWithinViewportX = (mZoomFocalPoint.x -\n            mScrollerStartViewport.left)\n            / mScrollerStartViewport.width();\n    float pointWithinViewportY = (mZoomFocalPoint.y -\n            mScrollerStartViewport.top)\n            / mScrollerStartViewport.height();\n    mCurrentViewport.set(\n            mZoomFocalPoint.x - newWidth * pointWithinViewportX,\n            mZoomFocalPoint.y - newHeight * pointWithinViewportY,\n            mZoomFocalPoint.x + newWidth * (1 - pointWithinViewportX),\n            mZoomFocalPoint.y + newHeight * (1 - pointWithinViewportY));\n    constrainViewport();\n    needsInvalidate = true;\n}\nif (needsInvalidate) {\n    ViewCompat.postInvalidateOnAnimation(this);\n}\n```\n\nThis is the computeScrollSurfaceSize() method that's called in the above snippet. It computes the current scrollable surface size, in pixels. For example, if the entire chart area is visible, this is simply the current size of mContentRect. If the chart is zoomed in 200% in both directions, the returned size will be twice as large horizontally and vertically.\n\n```\nprivate Point computeScrollSurfaceSize() {\n    return new Point(\n            (int) (mContentRect.width() * (AXIS_X_MAX - AXIS_X_MIN)\n                    / mCurrentViewport.width()),\n            (int) (mContentRect.height() * (AXIS_Y_MAX - AXIS_Y_MIN)\n                    / mCurrentViewport.height()));\n}\n```\n\nFor another example of scroller usage, see the source code for the ViewPager class. It scrolls in response to flings, and uses scrolling to implement the \"snapping to page\" animation.\n","source":"_posts/2013-06-19-animating-scroll-gesture.md","raw":"---\ncategory: Android\ndate: 2013-06-19\nlayout: post\ntitle:  Google官方指南-动画滚动手势\n---\n\nsource:[http://developer.android.com/training/gestures/scroll.html](http://developer.android.com/training/gestures/scroll.html)\n\n在Android中，通常我们使用ScrollView类来实现滑动。任何标准的布局都可能超出容器本身的边界，需要嵌套在由框架管理的可滑动视图的ScrollView中去展示。只有在需要特定的场景中，我们才可能需要去实现一个自定的Scroller。本章节描述了这么一个场景，显示一个使用了滑动器，响应触摸手势的滑动效果。\n\n你可以使用Scroller（如 Scroller 或者 OverScroller）去收集生产一个滑动动画所需要响应的触摸事件的数据。它们很类似，但是OverScroller包含指示用户甩动手势已经到达内容边界的方法。InteractiveChart示例使用了EdgeEffect类(准确地说是 EdgeEffectCompat类)去显示发光的效果，当用户到达内容的边界。\n\n>>>注意：我们建议你使用OverScroller而不是Scroller去实现滑动动画。OverScroller为旧的设备提供了最好的向后兼容性。\n\n\n同样提醒你通常只有你要自己实现滑动时才使用scrollers。ScrollView和HorizontalScrollView已经为你准备好一切，如果你把布局嵌套其中。\n\nScroller被用于随时间推移动画滚动，使用平台标准的滚动物理（摩擦，速度等）。Scroller其实本身不绘制任何东西。Scrollers随时间推移跟踪滚动偏移，但是他们不会自动地将你的视图移动到那些位置。而是应该由你去获取坐标并且按照一定的速率，以使得滚动动画看起来比较平滑。\n\n##理解滚动术语\n---\n\n\"Scrolling\"在不同的Android中不同的上下文有着不同的含义。\n\n- 滚动是移动视图窗口(viewport--也就是你正看到的内容的窗口)的一般过程。当同时在x和y轴滚动式，称为平移(panning)。在样品应用中提供了这样一个类，InteractiveChart,说明了两种类型的滚动,拖拽和甩动。\n- 拖动是一种滚动--发生在用户将他的手指在触摸屏上拖动。简单的拖动经常是通过重写GestureDetector.OnGestureListener类的onScroll()函数实现的。更多关于拖动的讨论，查看Dragging and Scaling.\n\n甩是一种滚动发生在用户拖动并快速抬起他的手指。在用户抬起他的手指后，你通常要保持滚动(移动视口),但是减速滚动直到视口停止移动。甩动作可以通过重写GestureDetector.OnGestureListener类的onFling()实现，并且使用一个scroller类。这就是本主题要将的使用情况。\n\n通常使用scroller对象关联甩手势，但他们可以被用在几乎任何你想要UI去反馈触摸事件显示滚动的上下文中。例如，你可以重写onTouchEvent()直接处理触摸事件，并且产生一个滚动效果或者一个吸附页面（snapping to page）动画响应那些触摸事件\n\n\n##实现基于触摸的滚动\n---\n\n本段描述了如何使用scroller类，下面展示的片段来自InteractiveChart。它使用了GestureDetector，并且重写GestureDetector.SimpleOnGestureListener中的onFling()。使用了OverScroller跟踪甩手势。如果用户在甩手势之后达到了内容的边界，应用会显示一个发光效果。\n\n>>>Note: The InteractiveChart sample app displays a chart that you can zoom, pan, scroll, and so on. In the following snippet, mContentRect represents the rectangle coordinates within the view that the chart will be drawn into. At any given time, a subset of the total chart domain and range are drawn into this rectangular area. mCurrentViewport represents the portion of the chart that is currently visible in the screen. Because pixel offsets are generally treated as integers, mContentRect is of the type Rect. Because the graph domain and range are decimal/float values, mCurrentViewport is of the type RectF.\n\n\nThe first part of the snippet shows the implementation of onFling():\n\n```\n// The current viewport. This rectangle represents the currently visible\n// chart domain and range. The viewport is the part of the app that the\n// user manipulates via touch gestures.\nprivate RectF mCurrentViewport =\n        new RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);\n\n// The current destination rectangle (in pixel coordinates) into which the\n// chart data should be drawn.\nprivate Rect mContentRect;\n\nprivate OverScroller mScroller;\nprivate RectF mScrollerStartViewport;\n...\nprivate final GestureDetector.SimpleOnGestureListener mGestureListener\n        = new GestureDetector.SimpleOnGestureListener() {\n    @Override\n    public boolean onDown(MotionEvent e) {\n        // Initiates the decay phase of any active edge effects.\n        releaseEdgeEffects();\n        mScrollerStartViewport.set(mCurrentViewport);\n        // Aborts any active scroll animations and invalidates.\n        mScroller.forceFinished(true);\n        ViewCompat.postInvalidateOnAnimation(InteractiveLineGraphView.this);\n        return true;\n    }\n    ...\n    @Override\n    public boolean onFling(MotionEvent e1, MotionEvent e2,\n            float velocityX, float velocityY) {\n        fling((int) -velocityX, (int) -velocityY);\n        return true;\n    }\n};\n\nprivate void fling(int velocityX, int velocityY) {\n    // Initiates the decay phase of any active edge effects.\n    releaseEdgeEffects();\n    // Flings use math in pixels (as opposed to math based on the viewport).\n    Point surfaceSize = computeScrollSurfaceSize();\n    mScrollerStartViewport.set(mCurrentViewport);\n    int startX = (int) (surfaceSize.x * (mScrollerStartViewport.left -\n            AXIS_X_MIN) / (\n            AXIS_X_MAX - AXIS_X_MIN));\n    int startY = (int) (surfaceSize.y * (AXIS_Y_MAX -\n            mScrollerStartViewport.bottom) / (\n            AXIS_Y_MAX - AXIS_Y_MIN));\n    // Before flinging, aborts the current animation.\n    mScroller.forceFinished(true);\n    // Begins the animation\n    mScroller.fling(\n            // Current scroll position\n            startX,\n            startY,\n            velocityX,\n            velocityY,\n            /*\n             * Minimum and maximum scroll positions. The minimum scroll\n             * position is generally zero and the maximum scroll position\n             * is generally the content size less the screen size. So if the\n             * content width is 1000 pixels and the screen width is 200  \n             * pixels, the maximum scroll offset should be 800 pixels.\n             */\n            0, surfaceSize.x - mContentRect.width(),\n            0, surfaceSize.y - mContentRect.height(),\n            // The edges of the content. This comes into play when using\n            // the EdgeEffect class to draw \"glow\" overlays.\n            mContentRect.width() / 2,\n            mContentRect.height() / 2);\n    // Invalidates to trigger computeScroll()\n    ViewCompat.postInvalidateOnAnimation(this);\n}\n```\n\n当onFling()调用postInvalidateOnAniamtion(),会触发computeScroll()去更新x,y的值。当一个子视图使用scroller动画显示一个滚动时，通常是必须要做的，就像是在例子中一样。\n\n\nMost views pass the scroller object's x and y position directly to scrollTo(). The following implementation of computeScroll() takes a different approach—it calls computeScrollOffset() to get the current location of x and y. When the criteria for displaying an overscroll \"glow\" edge effect are met (the display is zoomed in, x or y is out of bounds, and the app isn't already showing an overscroll), the code sets up the overscroll glow effect and calls postInvalidateOnAnimation() to trigger an invalidate on the view:\n\n```\n// Edge effect / overscroll tracking objects.\nprivate EdgeEffectCompat mEdgeEffectTop;\nprivate EdgeEffectCompat mEdgeEffectBottom;\nprivate EdgeEffectCompat mEdgeEffectLeft;\nprivate EdgeEffectCompat mEdgeEffectRight;\n\nprivate boolean mEdgeEffectTopActive;\nprivate boolean mEdgeEffectBottomActive;\nprivate boolean mEdgeEffectLeftActive;\nprivate boolean mEdgeEffectRightActive;\n\n@Override\npublic void computeScroll() {\n    super.computeScroll();\n\n    boolean needsInvalidate = false;\n\n    // The scroller isn't finished, meaning a fling or programmatic pan\n    // operation is currently active.\n    if (mScroller.computeScrollOffset()) {\n        Point surfaceSize = computeScrollSurfaceSize();\n        int currX = mScroller.getCurrX();\n        int currY = mScroller.getCurrY();\n\n        boolean canScrollX = (mCurrentViewport.left > AXIS_X_MIN\n                || mCurrentViewport.right < AXIS_X_MAX);\n        boolean canScrollY = (mCurrentViewport.top > AXIS_Y_MIN\n                || mCurrentViewport.bottom < AXIS_Y_MAX);\n\n        /*          \n         * If you are zoomed in and currX or currY is\n         * outside of bounds and you're not already\n         * showing overscroll, then render the overscroll\n         * glow edge effect.\n         */\n        if (canScrollX\n                && currX < 0\n                && mEdgeEffectLeft.isFinished()\n                && !mEdgeEffectLeftActive) {\n            mEdgeEffectLeft.onAbsorb((int)\n                    OverScrollerCompat.getCurrVelocity(mScroller));\n            mEdgeEffectLeftActive = true;\n            needsInvalidate = true;\n        } else if (canScrollX\n                && currX > (surfaceSize.x - mContentRect.width())\n                && mEdgeEffectRight.isFinished()\n                && !mEdgeEffectRightActive) {\n            mEdgeEffectRight.onAbsorb((int)\n                    OverScrollerCompat.getCurrVelocity(mScroller));\n            mEdgeEffectRightActive = true;\n            needsInvalidate = true;\n        }\n\n        if (canScrollY\n                && currY < 0\n                && mEdgeEffectTop.isFinished()\n                && !mEdgeEffectTopActive) {\n            mEdgeEffectTop.onAbsorb((int)\n                    OverScrollerCompat.getCurrVelocity(mScroller));\n            mEdgeEffectTopActive = true;\n            needsInvalidate = true;\n        } else if (canScrollY\n                && currY > (surfaceSize.y - mContentRect.height())\n                && mEdgeEffectBottom.isFinished()\n                && !mEdgeEffectBottomActive) {\n            mEdgeEffectBottom.onAbsorb((int)\n                    OverScrollerCompat.getCurrVelocity(mScroller));\n            mEdgeEffectBottomActive = true;\n            needsInvalidate = true;\n        }\n        ...\n    }\n```\n\nHere is the section of the code that performs the actual zoom:\n\n```\n// Custom object that is functionally similar to Scroller\nZoomer mZoomer;\nprivate PointF mZoomFocalPoint = new PointF();\n...\n\n// If a zoom is in progress (either programmatically or via double\n// touch), performs the zoom.\nif (mZoomer.computeZoom()) {\n    float newWidth = (1f - mZoomer.getCurrZoom()) *\n            mScrollerStartViewport.width();\n    float newHeight = (1f - mZoomer.getCurrZoom()) *\n            mScrollerStartViewport.height();\n    float pointWithinViewportX = (mZoomFocalPoint.x -\n            mScrollerStartViewport.left)\n            / mScrollerStartViewport.width();\n    float pointWithinViewportY = (mZoomFocalPoint.y -\n            mScrollerStartViewport.top)\n            / mScrollerStartViewport.height();\n    mCurrentViewport.set(\n            mZoomFocalPoint.x - newWidth * pointWithinViewportX,\n            mZoomFocalPoint.y - newHeight * pointWithinViewportY,\n            mZoomFocalPoint.x + newWidth * (1 - pointWithinViewportX),\n            mZoomFocalPoint.y + newHeight * (1 - pointWithinViewportY));\n    constrainViewport();\n    needsInvalidate = true;\n}\nif (needsInvalidate) {\n    ViewCompat.postInvalidateOnAnimation(this);\n}\n```\n\nThis is the computeScrollSurfaceSize() method that's called in the above snippet. It computes the current scrollable surface size, in pixels. For example, if the entire chart area is visible, this is simply the current size of mContentRect. If the chart is zoomed in 200% in both directions, the returned size will be twice as large horizontally and vertically.\n\n```\nprivate Point computeScrollSurfaceSize() {\n    return new Point(\n            (int) (mContentRect.width() * (AXIS_X_MAX - AXIS_X_MIN)\n                    / mCurrentViewport.width()),\n            (int) (mContentRect.height() * (AXIS_Y_MAX - AXIS_Y_MIN)\n                    / mCurrentViewport.height()));\n}\n```\n\nFor another example of scroller usage, see the source code for the ViewPager class. It scrolls in response to flings, and uses scrolling to implement the \"snapping to page\" animation.\n","slug":"2013-06-19-animating-scroll-gesture","published":1,"updated":"2018-02-14T21:36:14.837Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlt0014rpfygh59b4ud","content":"<p>source:<a href=\"http://developer.android.com/training/gestures/scroll.html\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/training/gestures/scroll.html</a></p>\n<p>在Android中，通常我们使用ScrollView类来实现滑动。任何标准的布局都可能超出容器本身的边界，需要嵌套在由框架管理的可滑动视图的ScrollView中去展示。只有在需要特定的场景中，我们才可能需要去实现一个自定的Scroller。本章节描述了这么一个场景，显示一个使用了滑动器，响应触摸手势的滑动效果。</p>\n<p>你可以使用Scroller（如 Scroller 或者 OverScroller）去收集生产一个滑动动画所需要响应的触摸事件的数据。它们很类似，但是OverScroller包含指示用户甩动手势已经到达内容边界的方法。InteractiveChart示例使用了EdgeEffect类(准确地说是 EdgeEffectCompat类)去显示发光的效果，当用户到达内容的边界。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>注意：我们建议你使用OverScroller而不是Scroller去实现滑动动画。OverScroller为旧的设备提供了最好的向后兼容性。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>同样提醒你通常只有你要自己实现滑动时才使用scrollers。ScrollView和HorizontalScrollView已经为你准备好一切，如果你把布局嵌套其中。</p>\n<p>Scroller被用于随时间推移动画滚动，使用平台标准的滚动物理（摩擦，速度等）。Scroller其实本身不绘制任何东西。Scrollers随时间推移跟踪滚动偏移，但是他们不会自动地将你的视图移动到那些位置。而是应该由你去获取坐标并且按照一定的速率，以使得滚动动画看起来比较平滑。</p>\n<h2 id=\"理解滚动术语\"><a href=\"#理解滚动术语\" class=\"headerlink\" title=\"##理解滚动术语\"></a>##理解滚动术语</h2><p>“Scrolling”在不同的Android中不同的上下文有着不同的含义。</p>\n<ul>\n<li>滚动是移动视图窗口(viewport–也就是你正看到的内容的窗口)的一般过程。当同时在x和y轴滚动式，称为平移(panning)。在样品应用中提供了这样一个类，InteractiveChart,说明了两种类型的滚动,拖拽和甩动。</li>\n<li>拖动是一种滚动–发生在用户将他的手指在触摸屏上拖动。简单的拖动经常是通过重写GestureDetector.OnGestureListener类的onScroll()函数实现的。更多关于拖动的讨论，查看Dragging and Scaling.</li>\n</ul>\n<p>甩是一种滚动发生在用户拖动并快速抬起他的手指。在用户抬起他的手指后，你通常要保持滚动(移动视口),但是减速滚动直到视口停止移动。甩动作可以通过重写GestureDetector.OnGestureListener类的onFling()实现，并且使用一个scroller类。这就是本主题要将的使用情况。</p>\n<p>通常使用scroller对象关联甩手势，但他们可以被用在几乎任何你想要UI去反馈触摸事件显示滚动的上下文中。例如，你可以重写onTouchEvent()直接处理触摸事件，并且产生一个滚动效果或者一个吸附页面（snapping to page）动画响应那些触摸事件</p>\n<h2 id=\"实现基于触摸的滚动\"><a href=\"#实现基于触摸的滚动\" class=\"headerlink\" title=\"##实现基于触摸的滚动\"></a>##实现基于触摸的滚动</h2><p>本段描述了如何使用scroller类，下面展示的片段来自InteractiveChart。它使用了GestureDetector，并且重写GestureDetector.SimpleOnGestureListener中的onFling()。使用了OverScroller跟踪甩手势。如果用户在甩手势之后达到了内容的边界，应用会显示一个发光效果。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Note: The InteractiveChart sample app displays a chart that you can zoom, pan, scroll, and so on. In the following snippet, mContentRect represents the rectangle coordinates within the view that the chart will be drawn into. At any given time, a subset of the total chart domain and range are drawn into this rectangular area. mCurrentViewport represents the portion of the chart that is currently visible in the screen. Because pixel offsets are generally treated as integers, mContentRect is of the type Rect. Because the graph domain and range are decimal/float values, mCurrentViewport is of the type RectF.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>The first part of the snippet shows the implementation of onFling():</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// The current viewport. This rectangle represents the currently visible</span><br><span class=\"line\">// chart domain and range. The viewport is the part of the app that the</span><br><span class=\"line\">// user manipulates via touch gestures.</span><br><span class=\"line\">private RectF mCurrentViewport =</span><br><span class=\"line\">        new RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">// The current destination rectangle (in pixel coordinates) into which the</span><br><span class=\"line\">// chart data should be drawn.</span><br><span class=\"line\">private Rect mContentRect;</span><br><span class=\"line\"></span><br><span class=\"line\">private OverScroller mScroller;</span><br><span class=\"line\">private RectF mScrollerStartViewport;</span><br><span class=\"line\">...</span><br><span class=\"line\">private final GestureDetector.SimpleOnGestureListener mGestureListener</span><br><span class=\"line\">        = new GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onDown(MotionEvent e) &#123;</span><br><span class=\"line\">        // Initiates the decay phase of any active edge effects.</span><br><span class=\"line\">        releaseEdgeEffects();</span><br><span class=\"line\">        mScrollerStartViewport.set(mCurrentViewport);</span><br><span class=\"line\">        // Aborts any active scroll animations and invalidates.</span><br><span class=\"line\">        mScroller.forceFinished(true);</span><br><span class=\"line\">        ViewCompat.postInvalidateOnAnimation(InteractiveLineGraphView.this);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onFling(MotionEvent e1, MotionEvent e2,</span><br><span class=\"line\">            float velocityX, float velocityY) &#123;</span><br><span class=\"line\">        fling((int) -velocityX, (int) -velocityY);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">private void fling(int velocityX, int velocityY) &#123;</span><br><span class=\"line\">    // Initiates the decay phase of any active edge effects.</span><br><span class=\"line\">    releaseEdgeEffects();</span><br><span class=\"line\">    // Flings use math in pixels (as opposed to math based on the viewport).</span><br><span class=\"line\">    Point surfaceSize = computeScrollSurfaceSize();</span><br><span class=\"line\">    mScrollerStartViewport.set(mCurrentViewport);</span><br><span class=\"line\">    int startX = (int) (surfaceSize.x * (mScrollerStartViewport.left -</span><br><span class=\"line\">            AXIS_X_MIN) / (</span><br><span class=\"line\">            AXIS_X_MAX - AXIS_X_MIN));</span><br><span class=\"line\">    int startY = (int) (surfaceSize.y * (AXIS_Y_MAX -</span><br><span class=\"line\">            mScrollerStartViewport.bottom) / (</span><br><span class=\"line\">            AXIS_Y_MAX - AXIS_Y_MIN));</span><br><span class=\"line\">    // Before flinging, aborts the current animation.</span><br><span class=\"line\">    mScroller.forceFinished(true);</span><br><span class=\"line\">    // Begins the animation</span><br><span class=\"line\">    mScroller.fling(</span><br><span class=\"line\">            // Current scroll position</span><br><span class=\"line\">            startX,</span><br><span class=\"line\">            startY,</span><br><span class=\"line\">            velocityX,</span><br><span class=\"line\">            velocityY,</span><br><span class=\"line\">            /*</span><br><span class=\"line\">             * Minimum and maximum scroll positions. The minimum scroll</span><br><span class=\"line\">             * position is generally zero and the maximum scroll position</span><br><span class=\"line\">             * is generally the content size less the screen size. So if the</span><br><span class=\"line\">             * content width is 1000 pixels and the screen width is 200  </span><br><span class=\"line\">             * pixels, the maximum scroll offset should be 800 pixels.</span><br><span class=\"line\">             */</span><br><span class=\"line\">            0, surfaceSize.x - mContentRect.width(),</span><br><span class=\"line\">            0, surfaceSize.y - mContentRect.height(),</span><br><span class=\"line\">            // The edges of the content. This comes into play when using</span><br><span class=\"line\">            // the EdgeEffect class to draw &quot;glow&quot; overlays.</span><br><span class=\"line\">            mContentRect.width() / 2,</span><br><span class=\"line\">            mContentRect.height() / 2);</span><br><span class=\"line\">    // Invalidates to trigger computeScroll()</span><br><span class=\"line\">    ViewCompat.postInvalidateOnAnimation(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当onFling()调用postInvalidateOnAniamtion(),会触发computeScroll()去更新x,y的值。当一个子视图使用scroller动画显示一个滚动时，通常是必须要做的，就像是在例子中一样。</p>\n<p>Most views pass the scroller object’s x and y position directly to scrollTo(). The following implementation of computeScroll() takes a different approach—it calls computeScrollOffset() to get the current location of x and y. When the criteria for displaying an overscroll “glow” edge effect are met (the display is zoomed in, x or y is out of bounds, and the app isn’t already showing an overscroll), the code sets up the overscroll glow effect and calls postInvalidateOnAnimation() to trigger an invalidate on the view:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Edge effect / overscroll tracking objects.</span><br><span class=\"line\">private EdgeEffectCompat mEdgeEffectTop;</span><br><span class=\"line\">private EdgeEffectCompat mEdgeEffectBottom;</span><br><span class=\"line\">private EdgeEffectCompat mEdgeEffectLeft;</span><br><span class=\"line\">private EdgeEffectCompat mEdgeEffectRight;</span><br><span class=\"line\"></span><br><span class=\"line\">private boolean mEdgeEffectTopActive;</span><br><span class=\"line\">private boolean mEdgeEffectBottomActive;</span><br><span class=\"line\">private boolean mEdgeEffectLeftActive;</span><br><span class=\"line\">private boolean mEdgeEffectRightActive;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void computeScroll() &#123;</span><br><span class=\"line\">    super.computeScroll();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean needsInvalidate = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    // The scroller isn&apos;t finished, meaning a fling or programmatic pan</span><br><span class=\"line\">    // operation is currently active.</span><br><span class=\"line\">    if (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">        Point surfaceSize = computeScrollSurfaceSize();</span><br><span class=\"line\">        int currX = mScroller.getCurrX();</span><br><span class=\"line\">        int currY = mScroller.getCurrY();</span><br><span class=\"line\"></span><br><span class=\"line\">        boolean canScrollX = (mCurrentViewport.left &gt; AXIS_X_MIN</span><br><span class=\"line\">                || mCurrentViewport.right &lt; AXIS_X_MAX);</span><br><span class=\"line\">        boolean canScrollY = (mCurrentViewport.top &gt; AXIS_Y_MIN</span><br><span class=\"line\">                || mCurrentViewport.bottom &lt; AXIS_Y_MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">        /*          </span><br><span class=\"line\">         * If you are zoomed in and currX or currY is</span><br><span class=\"line\">         * outside of bounds and you&apos;re not already</span><br><span class=\"line\">         * showing overscroll, then render the overscroll</span><br><span class=\"line\">         * glow edge effect.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        if (canScrollX</span><br><span class=\"line\">                &amp;&amp; currX &lt; 0</span><br><span class=\"line\">                &amp;&amp; mEdgeEffectLeft.isFinished()</span><br><span class=\"line\">                &amp;&amp; !mEdgeEffectLeftActive) &#123;</span><br><span class=\"line\">            mEdgeEffectLeft.onAbsorb((int)</span><br><span class=\"line\">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class=\"line\">            mEdgeEffectLeftActive = true;</span><br><span class=\"line\">            needsInvalidate = true;</span><br><span class=\"line\">        &#125; else if (canScrollX</span><br><span class=\"line\">                &amp;&amp; currX &gt; (surfaceSize.x - mContentRect.width())</span><br><span class=\"line\">                &amp;&amp; mEdgeEffectRight.isFinished()</span><br><span class=\"line\">                &amp;&amp; !mEdgeEffectRightActive) &#123;</span><br><span class=\"line\">            mEdgeEffectRight.onAbsorb((int)</span><br><span class=\"line\">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class=\"line\">            mEdgeEffectRightActive = true;</span><br><span class=\"line\">            needsInvalidate = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (canScrollY</span><br><span class=\"line\">                &amp;&amp; currY &lt; 0</span><br><span class=\"line\">                &amp;&amp; mEdgeEffectTop.isFinished()</span><br><span class=\"line\">                &amp;&amp; !mEdgeEffectTopActive) &#123;</span><br><span class=\"line\">            mEdgeEffectTop.onAbsorb((int)</span><br><span class=\"line\">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class=\"line\">            mEdgeEffectTopActive = true;</span><br><span class=\"line\">            needsInvalidate = true;</span><br><span class=\"line\">        &#125; else if (canScrollY</span><br><span class=\"line\">                &amp;&amp; currY &gt; (surfaceSize.y - mContentRect.height())</span><br><span class=\"line\">                &amp;&amp; mEdgeEffectBottom.isFinished()</span><br><span class=\"line\">                &amp;&amp; !mEdgeEffectBottomActive) &#123;</span><br><span class=\"line\">            mEdgeEffectBottom.onAbsorb((int)</span><br><span class=\"line\">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class=\"line\">            mEdgeEffectBottomActive = true;</span><br><span class=\"line\">            needsInvalidate = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>Here is the section of the code that performs the actual zoom:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Custom object that is functionally similar to Scroller</span><br><span class=\"line\">Zoomer mZoomer;</span><br><span class=\"line\">private PointF mZoomFocalPoint = new PointF();</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">// If a zoom is in progress (either programmatically or via double</span><br><span class=\"line\">// touch), performs the zoom.</span><br><span class=\"line\">if (mZoomer.computeZoom()) &#123;</span><br><span class=\"line\">    float newWidth = (1f - mZoomer.getCurrZoom()) *</span><br><span class=\"line\">            mScrollerStartViewport.width();</span><br><span class=\"line\">    float newHeight = (1f - mZoomer.getCurrZoom()) *</span><br><span class=\"line\">            mScrollerStartViewport.height();</span><br><span class=\"line\">    float pointWithinViewportX = (mZoomFocalPoint.x -</span><br><span class=\"line\">            mScrollerStartViewport.left)</span><br><span class=\"line\">            / mScrollerStartViewport.width();</span><br><span class=\"line\">    float pointWithinViewportY = (mZoomFocalPoint.y -</span><br><span class=\"line\">            mScrollerStartViewport.top)</span><br><span class=\"line\">            / mScrollerStartViewport.height();</span><br><span class=\"line\">    mCurrentViewport.set(</span><br><span class=\"line\">            mZoomFocalPoint.x - newWidth * pointWithinViewportX,</span><br><span class=\"line\">            mZoomFocalPoint.y - newHeight * pointWithinViewportY,</span><br><span class=\"line\">            mZoomFocalPoint.x + newWidth * (1 - pointWithinViewportX),</span><br><span class=\"line\">            mZoomFocalPoint.y + newHeight * (1 - pointWithinViewportY));</span><br><span class=\"line\">    constrainViewport();</span><br><span class=\"line\">    needsInvalidate = true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (needsInvalidate) &#123;</span><br><span class=\"line\">    ViewCompat.postInvalidateOnAnimation(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>This is the computeScrollSurfaceSize() method that’s called in the above snippet. It computes the current scrollable surface size, in pixels. For example, if the entire chart area is visible, this is simply the current size of mContentRect. If the chart is zoomed in 200% in both directions, the returned size will be twice as large horizontally and vertically.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Point computeScrollSurfaceSize() &#123;</span><br><span class=\"line\">    return new Point(</span><br><span class=\"line\">            (int) (mContentRect.width() * (AXIS_X_MAX - AXIS_X_MIN)</span><br><span class=\"line\">                    / mCurrentViewport.width()),</span><br><span class=\"line\">            (int) (mContentRect.height() * (AXIS_Y_MAX - AXIS_Y_MIN)</span><br><span class=\"line\">                    / mCurrentViewport.height()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>For another example of scroller usage, see the source code for the ViewPager class. It scrolls in response to flings, and uses scrolling to implement the “snapping to page” animation.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>source:<a href=\"http://developer.android.com/training/gestures/scroll.html\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/training/gestures/scroll.html</a></p>\n<p>在Android中，通常我们使用ScrollView类来实现滑动。任何标准的布局都可能超出容器本身的边界，需要嵌套在由框架管理的可滑动视图的ScrollView中去展示。只有在需要特定的场景中，我们才可能需要去实现一个自定的Scroller。本章节描述了这么一个场景，显示一个使用了滑动器，响应触摸手势的滑动效果。</p>\n<p>你可以使用Scroller（如 Scroller 或者 OverScroller）去收集生产一个滑动动画所需要响应的触摸事件的数据。它们很类似，但是OverScroller包含指示用户甩动手势已经到达内容边界的方法。InteractiveChart示例使用了EdgeEffect类(准确地说是 EdgeEffectCompat类)去显示发光的效果，当用户到达内容的边界。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>注意：我们建议你使用OverScroller而不是Scroller去实现滑动动画。OverScroller为旧的设备提供了最好的向后兼容性。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>同样提醒你通常只有你要自己实现滑动时才使用scrollers。ScrollView和HorizontalScrollView已经为你准备好一切，如果你把布局嵌套其中。</p>\n<p>Scroller被用于随时间推移动画滚动，使用平台标准的滚动物理（摩擦，速度等）。Scroller其实本身不绘制任何东西。Scrollers随时间推移跟踪滚动偏移，但是他们不会自动地将你的视图移动到那些位置。而是应该由你去获取坐标并且按照一定的速率，以使得滚动动画看起来比较平滑。</p>\n<h2 id=\"理解滚动术语\"><a href=\"#理解滚动术语\" class=\"headerlink\" title=\"##理解滚动术语\"></a>##理解滚动术语</h2><p>“Scrolling”在不同的Android中不同的上下文有着不同的含义。</p>\n<ul>\n<li>滚动是移动视图窗口(viewport–也就是你正看到的内容的窗口)的一般过程。当同时在x和y轴滚动式，称为平移(panning)。在样品应用中提供了这样一个类，InteractiveChart,说明了两种类型的滚动,拖拽和甩动。</li>\n<li>拖动是一种滚动–发生在用户将他的手指在触摸屏上拖动。简单的拖动经常是通过重写GestureDetector.OnGestureListener类的onScroll()函数实现的。更多关于拖动的讨论，查看Dragging and Scaling.</li>\n</ul>\n<p>甩是一种滚动发生在用户拖动并快速抬起他的手指。在用户抬起他的手指后，你通常要保持滚动(移动视口),但是减速滚动直到视口停止移动。甩动作可以通过重写GestureDetector.OnGestureListener类的onFling()实现，并且使用一个scroller类。这就是本主题要将的使用情况。</p>\n<p>通常使用scroller对象关联甩手势，但他们可以被用在几乎任何你想要UI去反馈触摸事件显示滚动的上下文中。例如，你可以重写onTouchEvent()直接处理触摸事件，并且产生一个滚动效果或者一个吸附页面（snapping to page）动画响应那些触摸事件</p>\n<h2 id=\"实现基于触摸的滚动\"><a href=\"#实现基于触摸的滚动\" class=\"headerlink\" title=\"##实现基于触摸的滚动\"></a>##实现基于触摸的滚动</h2><p>本段描述了如何使用scroller类，下面展示的片段来自InteractiveChart。它使用了GestureDetector，并且重写GestureDetector.SimpleOnGestureListener中的onFling()。使用了OverScroller跟踪甩手势。如果用户在甩手势之后达到了内容的边界，应用会显示一个发光效果。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Note: The InteractiveChart sample app displays a chart that you can zoom, pan, scroll, and so on. In the following snippet, mContentRect represents the rectangle coordinates within the view that the chart will be drawn into. At any given time, a subset of the total chart domain and range are drawn into this rectangular area. mCurrentViewport represents the portion of the chart that is currently visible in the screen. Because pixel offsets are generally treated as integers, mContentRect is of the type Rect. Because the graph domain and range are decimal/float values, mCurrentViewport is of the type RectF.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>The first part of the snippet shows the implementation of onFling():</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// The current viewport. This rectangle represents the currently visible</span><br><span class=\"line\">// chart domain and range. The viewport is the part of the app that the</span><br><span class=\"line\">// user manipulates via touch gestures.</span><br><span class=\"line\">private RectF mCurrentViewport =</span><br><span class=\"line\">        new RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">// The current destination rectangle (in pixel coordinates) into which the</span><br><span class=\"line\">// chart data should be drawn.</span><br><span class=\"line\">private Rect mContentRect;</span><br><span class=\"line\"></span><br><span class=\"line\">private OverScroller mScroller;</span><br><span class=\"line\">private RectF mScrollerStartViewport;</span><br><span class=\"line\">...</span><br><span class=\"line\">private final GestureDetector.SimpleOnGestureListener mGestureListener</span><br><span class=\"line\">        = new GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onDown(MotionEvent e) &#123;</span><br><span class=\"line\">        // Initiates the decay phase of any active edge effects.</span><br><span class=\"line\">        releaseEdgeEffects();</span><br><span class=\"line\">        mScrollerStartViewport.set(mCurrentViewport);</span><br><span class=\"line\">        // Aborts any active scroll animations and invalidates.</span><br><span class=\"line\">        mScroller.forceFinished(true);</span><br><span class=\"line\">        ViewCompat.postInvalidateOnAnimation(InteractiveLineGraphView.this);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onFling(MotionEvent e1, MotionEvent e2,</span><br><span class=\"line\">            float velocityX, float velocityY) &#123;</span><br><span class=\"line\">        fling((int) -velocityX, (int) -velocityY);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">private void fling(int velocityX, int velocityY) &#123;</span><br><span class=\"line\">    // Initiates the decay phase of any active edge effects.</span><br><span class=\"line\">    releaseEdgeEffects();</span><br><span class=\"line\">    // Flings use math in pixels (as opposed to math based on the viewport).</span><br><span class=\"line\">    Point surfaceSize = computeScrollSurfaceSize();</span><br><span class=\"line\">    mScrollerStartViewport.set(mCurrentViewport);</span><br><span class=\"line\">    int startX = (int) (surfaceSize.x * (mScrollerStartViewport.left -</span><br><span class=\"line\">            AXIS_X_MIN) / (</span><br><span class=\"line\">            AXIS_X_MAX - AXIS_X_MIN));</span><br><span class=\"line\">    int startY = (int) (surfaceSize.y * (AXIS_Y_MAX -</span><br><span class=\"line\">            mScrollerStartViewport.bottom) / (</span><br><span class=\"line\">            AXIS_Y_MAX - AXIS_Y_MIN));</span><br><span class=\"line\">    // Before flinging, aborts the current animation.</span><br><span class=\"line\">    mScroller.forceFinished(true);</span><br><span class=\"line\">    // Begins the animation</span><br><span class=\"line\">    mScroller.fling(</span><br><span class=\"line\">            // Current scroll position</span><br><span class=\"line\">            startX,</span><br><span class=\"line\">            startY,</span><br><span class=\"line\">            velocityX,</span><br><span class=\"line\">            velocityY,</span><br><span class=\"line\">            /*</span><br><span class=\"line\">             * Minimum and maximum scroll positions. The minimum scroll</span><br><span class=\"line\">             * position is generally zero and the maximum scroll position</span><br><span class=\"line\">             * is generally the content size less the screen size. So if the</span><br><span class=\"line\">             * content width is 1000 pixels and the screen width is 200  </span><br><span class=\"line\">             * pixels, the maximum scroll offset should be 800 pixels.</span><br><span class=\"line\">             */</span><br><span class=\"line\">            0, surfaceSize.x - mContentRect.width(),</span><br><span class=\"line\">            0, surfaceSize.y - mContentRect.height(),</span><br><span class=\"line\">            // The edges of the content. This comes into play when using</span><br><span class=\"line\">            // the EdgeEffect class to draw &quot;glow&quot; overlays.</span><br><span class=\"line\">            mContentRect.width() / 2,</span><br><span class=\"line\">            mContentRect.height() / 2);</span><br><span class=\"line\">    // Invalidates to trigger computeScroll()</span><br><span class=\"line\">    ViewCompat.postInvalidateOnAnimation(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当onFling()调用postInvalidateOnAniamtion(),会触发computeScroll()去更新x,y的值。当一个子视图使用scroller动画显示一个滚动时，通常是必须要做的，就像是在例子中一样。</p>\n<p>Most views pass the scroller object’s x and y position directly to scrollTo(). The following implementation of computeScroll() takes a different approach—it calls computeScrollOffset() to get the current location of x and y. When the criteria for displaying an overscroll “glow” edge effect are met (the display is zoomed in, x or y is out of bounds, and the app isn’t already showing an overscroll), the code sets up the overscroll glow effect and calls postInvalidateOnAnimation() to trigger an invalidate on the view:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Edge effect / overscroll tracking objects.</span><br><span class=\"line\">private EdgeEffectCompat mEdgeEffectTop;</span><br><span class=\"line\">private EdgeEffectCompat mEdgeEffectBottom;</span><br><span class=\"line\">private EdgeEffectCompat mEdgeEffectLeft;</span><br><span class=\"line\">private EdgeEffectCompat mEdgeEffectRight;</span><br><span class=\"line\"></span><br><span class=\"line\">private boolean mEdgeEffectTopActive;</span><br><span class=\"line\">private boolean mEdgeEffectBottomActive;</span><br><span class=\"line\">private boolean mEdgeEffectLeftActive;</span><br><span class=\"line\">private boolean mEdgeEffectRightActive;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void computeScroll() &#123;</span><br><span class=\"line\">    super.computeScroll();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean needsInvalidate = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    // The scroller isn&apos;t finished, meaning a fling or programmatic pan</span><br><span class=\"line\">    // operation is currently active.</span><br><span class=\"line\">    if (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">        Point surfaceSize = computeScrollSurfaceSize();</span><br><span class=\"line\">        int currX = mScroller.getCurrX();</span><br><span class=\"line\">        int currY = mScroller.getCurrY();</span><br><span class=\"line\"></span><br><span class=\"line\">        boolean canScrollX = (mCurrentViewport.left &gt; AXIS_X_MIN</span><br><span class=\"line\">                || mCurrentViewport.right &lt; AXIS_X_MAX);</span><br><span class=\"line\">        boolean canScrollY = (mCurrentViewport.top &gt; AXIS_Y_MIN</span><br><span class=\"line\">                || mCurrentViewport.bottom &lt; AXIS_Y_MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">        /*          </span><br><span class=\"line\">         * If you are zoomed in and currX or currY is</span><br><span class=\"line\">         * outside of bounds and you&apos;re not already</span><br><span class=\"line\">         * showing overscroll, then render the overscroll</span><br><span class=\"line\">         * glow edge effect.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        if (canScrollX</span><br><span class=\"line\">                &amp;&amp; currX &lt; 0</span><br><span class=\"line\">                &amp;&amp; mEdgeEffectLeft.isFinished()</span><br><span class=\"line\">                &amp;&amp; !mEdgeEffectLeftActive) &#123;</span><br><span class=\"line\">            mEdgeEffectLeft.onAbsorb((int)</span><br><span class=\"line\">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class=\"line\">            mEdgeEffectLeftActive = true;</span><br><span class=\"line\">            needsInvalidate = true;</span><br><span class=\"line\">        &#125; else if (canScrollX</span><br><span class=\"line\">                &amp;&amp; currX &gt; (surfaceSize.x - mContentRect.width())</span><br><span class=\"line\">                &amp;&amp; mEdgeEffectRight.isFinished()</span><br><span class=\"line\">                &amp;&amp; !mEdgeEffectRightActive) &#123;</span><br><span class=\"line\">            mEdgeEffectRight.onAbsorb((int)</span><br><span class=\"line\">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class=\"line\">            mEdgeEffectRightActive = true;</span><br><span class=\"line\">            needsInvalidate = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (canScrollY</span><br><span class=\"line\">                &amp;&amp; currY &lt; 0</span><br><span class=\"line\">                &amp;&amp; mEdgeEffectTop.isFinished()</span><br><span class=\"line\">                &amp;&amp; !mEdgeEffectTopActive) &#123;</span><br><span class=\"line\">            mEdgeEffectTop.onAbsorb((int)</span><br><span class=\"line\">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class=\"line\">            mEdgeEffectTopActive = true;</span><br><span class=\"line\">            needsInvalidate = true;</span><br><span class=\"line\">        &#125; else if (canScrollY</span><br><span class=\"line\">                &amp;&amp; currY &gt; (surfaceSize.y - mContentRect.height())</span><br><span class=\"line\">                &amp;&amp; mEdgeEffectBottom.isFinished()</span><br><span class=\"line\">                &amp;&amp; !mEdgeEffectBottomActive) &#123;</span><br><span class=\"line\">            mEdgeEffectBottom.onAbsorb((int)</span><br><span class=\"line\">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class=\"line\">            mEdgeEffectBottomActive = true;</span><br><span class=\"line\">            needsInvalidate = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>Here is the section of the code that performs the actual zoom:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Custom object that is functionally similar to Scroller</span><br><span class=\"line\">Zoomer mZoomer;</span><br><span class=\"line\">private PointF mZoomFocalPoint = new PointF();</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">// If a zoom is in progress (either programmatically or via double</span><br><span class=\"line\">// touch), performs the zoom.</span><br><span class=\"line\">if (mZoomer.computeZoom()) &#123;</span><br><span class=\"line\">    float newWidth = (1f - mZoomer.getCurrZoom()) *</span><br><span class=\"line\">            mScrollerStartViewport.width();</span><br><span class=\"line\">    float newHeight = (1f - mZoomer.getCurrZoom()) *</span><br><span class=\"line\">            mScrollerStartViewport.height();</span><br><span class=\"line\">    float pointWithinViewportX = (mZoomFocalPoint.x -</span><br><span class=\"line\">            mScrollerStartViewport.left)</span><br><span class=\"line\">            / mScrollerStartViewport.width();</span><br><span class=\"line\">    float pointWithinViewportY = (mZoomFocalPoint.y -</span><br><span class=\"line\">            mScrollerStartViewport.top)</span><br><span class=\"line\">            / mScrollerStartViewport.height();</span><br><span class=\"line\">    mCurrentViewport.set(</span><br><span class=\"line\">            mZoomFocalPoint.x - newWidth * pointWithinViewportX,</span><br><span class=\"line\">            mZoomFocalPoint.y - newHeight * pointWithinViewportY,</span><br><span class=\"line\">            mZoomFocalPoint.x + newWidth * (1 - pointWithinViewportX),</span><br><span class=\"line\">            mZoomFocalPoint.y + newHeight * (1 - pointWithinViewportY));</span><br><span class=\"line\">    constrainViewport();</span><br><span class=\"line\">    needsInvalidate = true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (needsInvalidate) &#123;</span><br><span class=\"line\">    ViewCompat.postInvalidateOnAnimation(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>This is the computeScrollSurfaceSize() method that’s called in the above snippet. It computes the current scrollable surface size, in pixels. For example, if the entire chart area is visible, this is simply the current size of mContentRect. If the chart is zoomed in 200% in both directions, the returned size will be twice as large horizontally and vertically.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Point computeScrollSurfaceSize() &#123;</span><br><span class=\"line\">    return new Point(</span><br><span class=\"line\">            (int) (mContentRect.width() * (AXIS_X_MAX - AXIS_X_MIN)</span><br><span class=\"line\">                    / mCurrentViewport.width()),</span><br><span class=\"line\">            (int) (mContentRect.height() * (AXIS_Y_MAX - AXIS_Y_MIN)</span><br><span class=\"line\">                    / mCurrentViewport.height()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>For another example of scroller usage, see the source code for the ViewPager class. It scrolls in response to flings, and uses scrolling to implement the “snapping to page” animation.</p>\n"},{"date":"2013-06-18T16:00:00.000Z","layout":"post","title":"ViewPager TouchEvent流程源码分析","_content":"\n由于ViewPager是继承ViewGroup的，所以它需要重写`onInterceptTouchEvent(MotionEvent ev)`函数，来控制父控件与子控件触摸事件传递流程\n\n[知识点： onInterceptTouchEvent和onTouchEvent调用时序](http://blog.csdn.net/ddna/article/details/5473293) 网友总结的知识点\n\n[Google官方指南：Managing Touch Events in a ViewGroup](http://developer.android.com/training/gestures/viewgroup.html)\n\n>首先吐槽下Google在触摸事件处理流程上的混乱，回调函数中逻辑都乱成浆糊了，ViewPager中仅onInterceptTouchEvent()和onTouchEvent()两个函数就长达270行，中间变量也多的发指！希望将来的能有所改善,类似iOS，清晰回调down，move，cancel等事件\n\n首先分析public boolean onInterceptTouchEvent(MotionEvent ev)函数，顾名思义是拦截触摸事件的回调函数：\n\n- 返回false: 表示父控件不拦截触摸事件，而将后续的所有事件传递给子控件\n- 返回true:  表示父控件拦截了子控件接收触摸事件的机会，而将后续事件转交给了自己的onTouchEvent()函数去处理。\n\nViewPager使用了两个重要的变量\n\n1. mIsBeingDragged：如果该变量为true，onInterceptionTouchEvent()会立刻返回true，表明\"我现在准备要把整个父控件拖动起来了，子控件们都不可能接收到Click,Touch,DoubleClick等触摸事件了\"\n2. mIsUnableToDrag: 与mIsBeingDragged相对应，表示父控件的触摸手势被判断为不应该拖动，比如Y轴滑动的距离大于了TouchSlop-->[Google术语](http://developer.android.com/training/gestures/viewgroup.html),向X轴触摸滑动得角度不足等等情况（具体数据是 xDiff*0.5>yDiff ）.\n\n \t\t// Nothing more to do here if we have decided whether or not we\n        // are dragging.\n        if (action != MotionEvent.ACTION_DOWN) {\n            if (mIsBeingDragged) {\n                if (DEBUG) Log.v(TAG, \"Intercept returning true!\");\n                return true;\n            }\n            if (mIsUnableToDrag) {\n                if (DEBUG) Log.v(TAG, \"Intercept returning false!\");\n                return false;\n            }\n        }\n\n\n如果用伪代码来写onInteceptTouchEvent()的话大概是这样的：\n\n```\n{\n\tif(action_cancel||action_up)\n\treturn\tfalse;\n\n\tif(!action_down)\n\t\tif (mIsBeingDragged)\n\t\t\treturn true;\n\t\tif (mIsUnableToDrag)\n\t\t\treturn false;\n\tswitch(action){\n\t\tcase move:\n\t\t\tif(可以滑动&&不是从屏幕边缘开始触摸滑动的){\n\t\t\t\tmIsUnableToDrag=ture;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(xDiff>mTouchSlop && xDiff*0.5>yDiff){\n\t\t\t\tmIsBeingDragged=true;\n\t\t\t}else if(yDiff>mTouchSlop){\n\t\t\t\tmIsUnableToDrag=true;\n\t\t\t}\n\t\t\tif(mIsBeingDragged){\n\t\t\t\t//拖动滑行x\n\t\t\t\tperformDrag(x);\n\t\t\t}\n\t\t\tbreak；\n\t\tcase down：\n\t\t\t初始化变量\n\t\t\tmIsUnableToDrag=false;\n\n\t\t\t//当ViewPager 正在左右页面切换滑动时，我们按下去之后  直接判断为开始滑动状态，\n\t\t\t//mCloseEnough默认值为2(dip),意思是Scroller可能已经快要结束它的动画了，必须要结束X坐标和当前X坐标相差大于2(dip)以上，才认为是还在滑动中\n\t\t\tmScroller.computeScrollOffset();\n\t\t\tif(mScrollState==SCROLL_STATE_SETTLING&&Math.abs(mScroller.getFinalX()-mScroller.getCurrX())>mCloseEnough){\n\t\t\t\tmIsBeingDragged=true;\n\t\t\t}else{\n\t\t\t\tmIsBeingDragged=false;\n\t\t\t}\n\t\t\tbreak；\n\t}\n\n\n\treturn mIsBeingDragged;\n}\n```\n\n好了，我们现在可以假设mIsBeingDragged==true,那么ViewPager就开始回调onTouchEvent(MotionEvent ev)()\n\n```\npublic boolean onTouchEvent(MotionEvent ev) {\n\tif (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {\n\t\t//按下时触摸到的屏幕边缘，则返回false\n\t\treturn false;\n    }\n\n    switch(action){\n    \tcase down:\n    \t\t变量初始化\n    \t\tmIsBeingDragged=true;\n    \t\tbreak;\n    \tcase move:\n    \t\tif(!mIsBeingDragged){\n    \t\t\tif(xDiff>mTouchSlop && xDiff > yDiff){\n    \t\t\t\tmIsBeingDragged=true;\n    \t\t\t}\n    \t\t}\n    \t\t//Not else! Note that mIsBeingDragged can be set above.\n    \t\tif(mIsBeingDragged){\n    \t\t\t // 页面逻辑\n    \t\t}\n    \t\tbreak;\n    \tcase up:\n    \t\tif(mIsBeingDragged){\n    \t\t\t // 页面逻辑\n    \t\t\t endDrag();\n    \t\t}\n    \t\tbreak;\n    \tcase cancel:\n    \t\tif(mIsBeingDragged){\n    \t\t\t // 页面逻辑\n    \t\t\t endDrag();\n    \t\t}\n    \t\tbreak;\n    }\n\n    // 可以看出，除了一些特殊情况外，onTouchEvent() 是必定返回true的，页面逻辑里实现了拖动和甩动等效果。\n    return true;\n}\n```\n\n##总结\n---\n假如我们要定制一个ViewGroup，类似与ViewPager,需要做手势判断的父控件，我们就有可能需要重写OnInteceptTouchEvent()，在move事件里判断手势，并决定是否拦截，在onTouchEvent里对整个ViewGroup做手势动画。\n\n\n##完整源码\n---\n\n \t<!-- java ->\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        /*\n         * This method JUST determines whether we want to intercept the motion.\n         * If we return true, onMotionEvent will be called and we do the actual\n         * scrolling there.\n         */\n        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;\n\n        // Always take care of the touch gesture being complete.\n        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {\n            // Release the drag.\n            if (DEBUG) Log.v(TAG, \"Intercept done!\");\n            mIsBeingDragged = false;\n            mIsUnableToDrag = false;\n            mActivePointerId = INVALID_POINTER;\n            if (mVelocityTracker != null) {\n                mVelocityTracker.recycle();\n                mVelocityTracker = null;\n            }\n            return false;\n        }\n\n        // Nothing more to do here if we have decided whether or not we\n        // are dragging.\n        if (action != MotionEvent.ACTION_DOWN) {\n            if (mIsBeingDragged) {\n                if (DEBUG) Log.v(TAG, \"Intercept returning true!\");\n                return true;\n            }\n            if (mIsUnableToDrag) {\n                if (DEBUG) Log.v(TAG, \"Intercept returning false!\");\n                return false;\n            }\n        }\n\n        switch (action) {\n            case MotionEvent.ACTION_MOVE: {\n                /*\n                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check\n                 * whether the user has moved far enough from his original down touch.\n                 */\n\n                /*\n                * Locally do absolute value. mLastMotionY is set to the y value\n                * of the down event.\n                */\n                final int activePointerId = mActivePointerId;\n                if (activePointerId == INVALID_POINTER) {\n                    // If we don't have a valid id, the touch down wasn't on content.\n                    break;\n                }\n\n                final int pointerIndex = MotionEventCompat.findPointerIndex(ev, activePointerId);\n                final float x = MotionEventCompat.getX(ev, pointerIndex);\n                final float dx = x - mLastMotionX;\n                final float xDiff = Math.abs(dx);\n                final float y = MotionEventCompat.getY(ev, pointerIndex);\n                final float yDiff = Math.abs(y - mInitialMotionY);\n                if (DEBUG)\n                    Log.v(TAG, \"Moved x to \" + x + \",\" + y + \" diff=\" + xDiff + \",\" + yDiff);\n\n                if (dx != 0 && !isGutterDrag(mLastMotionX, dx) &&\n                        canScroll(this, false, (int) dx, (int) x, (int) y)) {\n                    // Nested view has scrollable area under this point. Let it be handled there.\n                    mLastMotionX = x;\n                    mLastMotionY = y;\n                    mIsUnableToDrag = true;\n                    return false;\n                }\n                // x轴滑动大于 mTouchSlop  x轴滑动大于y轴滑动两倍\n                if (xDiff > mTouchSlop && xDiff * 0.5f > yDiff) {\n                    if (DEBUG) Log.v(TAG, \"Starting drag!\");\n                    mIsBeingDragged = true;\n                    setScrollState(SCROLL_STATE_DRAGGING);\n\n                    // mLastMotionX 修正\n                    mLastMotionX = dx > 0 ? mInitialMotionX + mTouchSlop :\n                            mInitialMotionX - mTouchSlop;\n                    mLastMotionY = y;\n                    setScrollingCacheEnabled(true);\n                } else if (yDiff > mTouchSlop) {\n                    // The finger has moved enough in the vertical\n                    // direction to be counted as a drag...  abort\n                    // any attempt to drag horizontally, to work correctly\n                    // with children that have scrolling containers.\n                    if (DEBUG) Log.v(TAG, \"Starting unable to drag!\");\n                    mIsUnableToDrag = true;\n                }\n                if (mIsBeingDragged) {\n                    // Scroll to follow the motion event\n                    if (performDrag(x)) {\n                        ViewCompat.postInvalidateOnAnimation(this);\n                    }\n                }\n                break;\n            }\n\n            case MotionEvent.ACTION_DOWN: {\n                /*\n                 * Remember location of down touch.\n                 * ACTION_DOWN always refers to pointer index 0.\n                 */\n                mLastMotionX = mInitialMotionX = ev.getX();\n                mLastMotionY = mInitialMotionY = ev.getY();\n                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n                mIsUnableToDrag = false;\n\n                mScroller.computeScrollOffset();\n                if (mScrollState == SCROLL_STATE_SETTLING &&\n                        Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) > mCloseEnough) {\n                    // Let the user 'catch' the pager as it animates.\n                    mScroller.abortAnimation();\n                    mPopulatePending = false;\n                    populate();\n                    mIsBeingDragged = true;\n                    setScrollState(SCROLL_STATE_DRAGGING);\n                } else {\n                    completeScroll(false);\n                    mIsBeingDragged = false;\n                }\n\n                if (DEBUG) Log.v(TAG, \"Down at \" + mLastMotionX + \",\" + mLastMotionY\n                        + \" mIsBeingDragged=\" + mIsBeingDragged\n                        + \"mIsUnableToDrag=\" + mIsUnableToDrag);\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_UP:\n                onSecondaryPointerUp(ev);\n                break;\n        }\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain();\n        }\n        mVelocityTracker.addMovement(ev);\n\n        /*\n         * The only time we want to intercept motion events is if we are in the\n         * drag mode.\n         */\n        return mIsBeingDragged;\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (mFakeDragging) {\n            // A fake drag is in progress already, ignore this real one\n            // but still eat the touch events.\n            // (It is likely that the user is multi-touching the screen.)\n            return true;\n        }\n\n        if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {\n            // Don't handle edge touches immediately -- they may actually belong to one of our\n            // descendants.\n            return false;\n        }\n\n        if (mAdapter == null || mAdapter.getCount() == 0) {\n            // Nothing to present or scroll; nothing to touch.\n            return false;\n        }\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain();\n        }\n        mVelocityTracker.addMovement(ev);\n\n        final int action = ev.getAction();\n        boolean needsInvalidate = false;\n\n        switch (action & MotionEventCompat.ACTION_MASK) {\n            case MotionEvent.ACTION_DOWN: {\n\n                mScroller.abortAnimation();\n                mPopulatePending = false;\n                populate();\n                mIsBeingDragged = true;\n                setScrollState(SCROLL_STATE_DRAGGING);\n\n                // Remember where the motion event started\n                mLastMotionX = mInitialMotionX = ev.getX();\n                mLastMotionY = mInitialMotionY = ev.getY();\n                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n                break;\n            }\n            case MotionEvent.ACTION_MOVE:\n                if (!mIsBeingDragged) {\n                    final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                    final float x = MotionEventCompat.getX(ev, pointerIndex);\n                    final float xDiff = Math.abs(x - mLastMotionX);\n                    final float y = MotionEventCompat.getY(ev, pointerIndex);\n                    final float yDiff = Math.abs(y - mLastMotionY);\n                    if (DEBUG)\n                        Log.v(TAG, \"Moved x to \" + x + \",\" + y + \" diff=\" + xDiff + \",\" + yDiff);\n                    if (xDiff > mTouchSlop && xDiff > yDiff) {\n                        if (DEBUG) Log.v(TAG, \"Starting drag!\");\n\n                        mIsBeingDragged = true;\n                        mLastMotionX = x - mInitialMotionX > 0 ? mInitialMotionX + mTouchSlop :\n                                mInitialMotionX - mTouchSlop;\n                        mLastMotionY = y;\n                        setScrollState(SCROLL_STATE_DRAGGING);\n                        setScrollingCacheEnabled(true);\n                    }\n                }\n                // Not else! Note that mIsBeingDragged can be set above.\n                if (mIsBeingDragged) {\n                    // Scroll to follow the motion event\n                    final int activePointerIndex = MotionEventCompat.findPointerIndex(\n                            ev, mActivePointerId);\n                    final float x = MotionEventCompat.getX(ev, activePointerIndex);\n                    needsInvalidate |= performDrag(x);\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                if (mIsBeingDragged) {\n\n                    final VelocityTracker velocityTracker = mVelocityTracker;\n                    velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n                    int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(\n                            velocityTracker, mActivePointerId);\n                    mPopulatePending = true;\n                    final int width = getWidth();\n                    final int scrollX = getScrollX();\n                    final ItemInfo ii = infoForCurrentScrollPosition();\n                    final int currentPage = ii.position;\n                    final float pageOffset = (((float) scrollX / width) - ii.offset) / ii.widthFactor;\n                    final int activePointerIndex =\n                            MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                    final float x = MotionEventCompat.getX(ev, activePointerIndex);\n\n                    final int totalDelta = (int) (x - mInitialMotionX);\n                    int nextPage = determineTargetPage(currentPage, pageOffset, initialVelocity,\n                            totalDelta);\n\n                    //Link Add\n                    if (nextPage == currentPage) {\n                        if (mOnPopViewListener != null) {\n                            mOnPopViewListener.onPoped();\n                        }\n                    }\n                    setCurrentItemInternal(nextPage, true, true, initialVelocity);\n\n\n                    mActivePointerId = INVALID_POINTER;\n                    endDrag();\n                    needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();\n                }\n                break;\n            case MotionEvent.ACTION_CANCEL:\n                if (mIsBeingDragged) {\n                    scrollToItem(mCurItem, true, 0, false);\n                    mActivePointerId = INVALID_POINTER;\n                    endDrag();\n                    needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();\n                }\n                break;\n            case MotionEventCompat.ACTION_POINTER_DOWN: {\n                final int index = MotionEventCompat.getActionIndex(ev);\n                final float x = MotionEventCompat.getX(ev, index);\n                mLastMotionX = x;\n                mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n                break;\n            }\n            case MotionEventCompat.ACTION_POINTER_UP:\n                onSecondaryPointerUp(ev);\n                mLastMotionX = MotionEventCompat.getX(ev,\n                        MotionEventCompat.findPointerIndex(ev, mActivePointerId));\n                break;\n        }\n        if (needsInvalidate) {\n            ViewCompat.postInvalidateOnAnimation(this);\n        }\n        return true;\n    }\n\n    private boolean performDrag(float x) {\n        boolean needsInvalidate = false;\n\n        final float deltaX = mLastMotionX - x;\n        mLastMotionX = x;\n\n        float oldScrollX = getScrollX();\n        float scrollX = oldScrollX + deltaX;\n        final int width = getWidth();\n\n        float leftBound = width * mFirstOffset;\n\n        // Link modify\n        // float rightBound = width * mLastOffset;\n        float rightBound = width * mCurItem;\n        boolean leftAbsolute = true;\n        boolean rightAbsolute = true;\n\n        final ItemInfo firstItem = mItems.get(0);\n        final ItemInfo lastItem = mItems.get(mItems.size() - 1);\n        if (firstItem.position != 0) {\n            leftAbsolute = false;\n            leftBound = firstItem.offset * width;\n        }\n\n        // 注释\n\t\t// if (lastItem.position != mAdapter.getCount() - 1) {\n\t\t//\t\trightAbsolute = false;\n\t\t//\t \trightBound = lastItem.offset * width;\n\t\t//\t}\n\n        if (scrollX < leftBound) {\n            if (leftAbsolute) {\n                float over = leftBound - scrollX;\n                needsInvalidate = mLeftEdge.onPull(Math.abs(over) / width);\n            }\n            scrollX = leftBound;\n        } else if (scrollX > rightBound) {\n            if (rightAbsolute) {\n                float over = scrollX - rightBound;\n\n                //Link Modify\n\t\t\t\t// needsInvalidate = mRightEdge.onPull(Math.abs(over) / width);\n                needsInvalidate = true;\n            }\n            scrollX = rightBound;\n        }\n        mLastMotionX += scrollX - (int) scrollX;\n\n        scrollTo((int) scrollX, getScrollY());\n        pageScrolled((int) scrollX);\n\n        return needsInvalidate;\n    }\n","source":"_posts/2013-06-19-viewpage-intercept.md","raw":"---\ncategory: Android\ndate: 2013-06-19\nlayout: post\ntitle: ViewPager TouchEvent流程源码分析\n---\n\n由于ViewPager是继承ViewGroup的，所以它需要重写`onInterceptTouchEvent(MotionEvent ev)`函数，来控制父控件与子控件触摸事件传递流程\n\n[知识点： onInterceptTouchEvent和onTouchEvent调用时序](http://blog.csdn.net/ddna/article/details/5473293) 网友总结的知识点\n\n[Google官方指南：Managing Touch Events in a ViewGroup](http://developer.android.com/training/gestures/viewgroup.html)\n\n>首先吐槽下Google在触摸事件处理流程上的混乱，回调函数中逻辑都乱成浆糊了，ViewPager中仅onInterceptTouchEvent()和onTouchEvent()两个函数就长达270行，中间变量也多的发指！希望将来的能有所改善,类似iOS，清晰回调down，move，cancel等事件\n\n首先分析public boolean onInterceptTouchEvent(MotionEvent ev)函数，顾名思义是拦截触摸事件的回调函数：\n\n- 返回false: 表示父控件不拦截触摸事件，而将后续的所有事件传递给子控件\n- 返回true:  表示父控件拦截了子控件接收触摸事件的机会，而将后续事件转交给了自己的onTouchEvent()函数去处理。\n\nViewPager使用了两个重要的变量\n\n1. mIsBeingDragged：如果该变量为true，onInterceptionTouchEvent()会立刻返回true，表明\"我现在准备要把整个父控件拖动起来了，子控件们都不可能接收到Click,Touch,DoubleClick等触摸事件了\"\n2. mIsUnableToDrag: 与mIsBeingDragged相对应，表示父控件的触摸手势被判断为不应该拖动，比如Y轴滑动的距离大于了TouchSlop-->[Google术语](http://developer.android.com/training/gestures/viewgroup.html),向X轴触摸滑动得角度不足等等情况（具体数据是 xDiff*0.5>yDiff ）.\n\n \t\t// Nothing more to do here if we have decided whether or not we\n        // are dragging.\n        if (action != MotionEvent.ACTION_DOWN) {\n            if (mIsBeingDragged) {\n                if (DEBUG) Log.v(TAG, \"Intercept returning true!\");\n                return true;\n            }\n            if (mIsUnableToDrag) {\n                if (DEBUG) Log.v(TAG, \"Intercept returning false!\");\n                return false;\n            }\n        }\n\n\n如果用伪代码来写onInteceptTouchEvent()的话大概是这样的：\n\n```\n{\n\tif(action_cancel||action_up)\n\treturn\tfalse;\n\n\tif(!action_down)\n\t\tif (mIsBeingDragged)\n\t\t\treturn true;\n\t\tif (mIsUnableToDrag)\n\t\t\treturn false;\n\tswitch(action){\n\t\tcase move:\n\t\t\tif(可以滑动&&不是从屏幕边缘开始触摸滑动的){\n\t\t\t\tmIsUnableToDrag=ture;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(xDiff>mTouchSlop && xDiff*0.5>yDiff){\n\t\t\t\tmIsBeingDragged=true;\n\t\t\t}else if(yDiff>mTouchSlop){\n\t\t\t\tmIsUnableToDrag=true;\n\t\t\t}\n\t\t\tif(mIsBeingDragged){\n\t\t\t\t//拖动滑行x\n\t\t\t\tperformDrag(x);\n\t\t\t}\n\t\t\tbreak；\n\t\tcase down：\n\t\t\t初始化变量\n\t\t\tmIsUnableToDrag=false;\n\n\t\t\t//当ViewPager 正在左右页面切换滑动时，我们按下去之后  直接判断为开始滑动状态，\n\t\t\t//mCloseEnough默认值为2(dip),意思是Scroller可能已经快要结束它的动画了，必须要结束X坐标和当前X坐标相差大于2(dip)以上，才认为是还在滑动中\n\t\t\tmScroller.computeScrollOffset();\n\t\t\tif(mScrollState==SCROLL_STATE_SETTLING&&Math.abs(mScroller.getFinalX()-mScroller.getCurrX())>mCloseEnough){\n\t\t\t\tmIsBeingDragged=true;\n\t\t\t}else{\n\t\t\t\tmIsBeingDragged=false;\n\t\t\t}\n\t\t\tbreak；\n\t}\n\n\n\treturn mIsBeingDragged;\n}\n```\n\n好了，我们现在可以假设mIsBeingDragged==true,那么ViewPager就开始回调onTouchEvent(MotionEvent ev)()\n\n```\npublic boolean onTouchEvent(MotionEvent ev) {\n\tif (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {\n\t\t//按下时触摸到的屏幕边缘，则返回false\n\t\treturn false;\n    }\n\n    switch(action){\n    \tcase down:\n    \t\t变量初始化\n    \t\tmIsBeingDragged=true;\n    \t\tbreak;\n    \tcase move:\n    \t\tif(!mIsBeingDragged){\n    \t\t\tif(xDiff>mTouchSlop && xDiff > yDiff){\n    \t\t\t\tmIsBeingDragged=true;\n    \t\t\t}\n    \t\t}\n    \t\t//Not else! Note that mIsBeingDragged can be set above.\n    \t\tif(mIsBeingDragged){\n    \t\t\t // 页面逻辑\n    \t\t}\n    \t\tbreak;\n    \tcase up:\n    \t\tif(mIsBeingDragged){\n    \t\t\t // 页面逻辑\n    \t\t\t endDrag();\n    \t\t}\n    \t\tbreak;\n    \tcase cancel:\n    \t\tif(mIsBeingDragged){\n    \t\t\t // 页面逻辑\n    \t\t\t endDrag();\n    \t\t}\n    \t\tbreak;\n    }\n\n    // 可以看出，除了一些特殊情况外，onTouchEvent() 是必定返回true的，页面逻辑里实现了拖动和甩动等效果。\n    return true;\n}\n```\n\n##总结\n---\n假如我们要定制一个ViewGroup，类似与ViewPager,需要做手势判断的父控件，我们就有可能需要重写OnInteceptTouchEvent()，在move事件里判断手势，并决定是否拦截，在onTouchEvent里对整个ViewGroup做手势动画。\n\n\n##完整源码\n---\n\n \t<!-- java ->\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        /*\n         * This method JUST determines whether we want to intercept the motion.\n         * If we return true, onMotionEvent will be called and we do the actual\n         * scrolling there.\n         */\n        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;\n\n        // Always take care of the touch gesture being complete.\n        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {\n            // Release the drag.\n            if (DEBUG) Log.v(TAG, \"Intercept done!\");\n            mIsBeingDragged = false;\n            mIsUnableToDrag = false;\n            mActivePointerId = INVALID_POINTER;\n            if (mVelocityTracker != null) {\n                mVelocityTracker.recycle();\n                mVelocityTracker = null;\n            }\n            return false;\n        }\n\n        // Nothing more to do here if we have decided whether or not we\n        // are dragging.\n        if (action != MotionEvent.ACTION_DOWN) {\n            if (mIsBeingDragged) {\n                if (DEBUG) Log.v(TAG, \"Intercept returning true!\");\n                return true;\n            }\n            if (mIsUnableToDrag) {\n                if (DEBUG) Log.v(TAG, \"Intercept returning false!\");\n                return false;\n            }\n        }\n\n        switch (action) {\n            case MotionEvent.ACTION_MOVE: {\n                /*\n                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check\n                 * whether the user has moved far enough from his original down touch.\n                 */\n\n                /*\n                * Locally do absolute value. mLastMotionY is set to the y value\n                * of the down event.\n                */\n                final int activePointerId = mActivePointerId;\n                if (activePointerId == INVALID_POINTER) {\n                    // If we don't have a valid id, the touch down wasn't on content.\n                    break;\n                }\n\n                final int pointerIndex = MotionEventCompat.findPointerIndex(ev, activePointerId);\n                final float x = MotionEventCompat.getX(ev, pointerIndex);\n                final float dx = x - mLastMotionX;\n                final float xDiff = Math.abs(dx);\n                final float y = MotionEventCompat.getY(ev, pointerIndex);\n                final float yDiff = Math.abs(y - mInitialMotionY);\n                if (DEBUG)\n                    Log.v(TAG, \"Moved x to \" + x + \",\" + y + \" diff=\" + xDiff + \",\" + yDiff);\n\n                if (dx != 0 && !isGutterDrag(mLastMotionX, dx) &&\n                        canScroll(this, false, (int) dx, (int) x, (int) y)) {\n                    // Nested view has scrollable area under this point. Let it be handled there.\n                    mLastMotionX = x;\n                    mLastMotionY = y;\n                    mIsUnableToDrag = true;\n                    return false;\n                }\n                // x轴滑动大于 mTouchSlop  x轴滑动大于y轴滑动两倍\n                if (xDiff > mTouchSlop && xDiff * 0.5f > yDiff) {\n                    if (DEBUG) Log.v(TAG, \"Starting drag!\");\n                    mIsBeingDragged = true;\n                    setScrollState(SCROLL_STATE_DRAGGING);\n\n                    // mLastMotionX 修正\n                    mLastMotionX = dx > 0 ? mInitialMotionX + mTouchSlop :\n                            mInitialMotionX - mTouchSlop;\n                    mLastMotionY = y;\n                    setScrollingCacheEnabled(true);\n                } else if (yDiff > mTouchSlop) {\n                    // The finger has moved enough in the vertical\n                    // direction to be counted as a drag...  abort\n                    // any attempt to drag horizontally, to work correctly\n                    // with children that have scrolling containers.\n                    if (DEBUG) Log.v(TAG, \"Starting unable to drag!\");\n                    mIsUnableToDrag = true;\n                }\n                if (mIsBeingDragged) {\n                    // Scroll to follow the motion event\n                    if (performDrag(x)) {\n                        ViewCompat.postInvalidateOnAnimation(this);\n                    }\n                }\n                break;\n            }\n\n            case MotionEvent.ACTION_DOWN: {\n                /*\n                 * Remember location of down touch.\n                 * ACTION_DOWN always refers to pointer index 0.\n                 */\n                mLastMotionX = mInitialMotionX = ev.getX();\n                mLastMotionY = mInitialMotionY = ev.getY();\n                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n                mIsUnableToDrag = false;\n\n                mScroller.computeScrollOffset();\n                if (mScrollState == SCROLL_STATE_SETTLING &&\n                        Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) > mCloseEnough) {\n                    // Let the user 'catch' the pager as it animates.\n                    mScroller.abortAnimation();\n                    mPopulatePending = false;\n                    populate();\n                    mIsBeingDragged = true;\n                    setScrollState(SCROLL_STATE_DRAGGING);\n                } else {\n                    completeScroll(false);\n                    mIsBeingDragged = false;\n                }\n\n                if (DEBUG) Log.v(TAG, \"Down at \" + mLastMotionX + \",\" + mLastMotionY\n                        + \" mIsBeingDragged=\" + mIsBeingDragged\n                        + \"mIsUnableToDrag=\" + mIsUnableToDrag);\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_UP:\n                onSecondaryPointerUp(ev);\n                break;\n        }\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain();\n        }\n        mVelocityTracker.addMovement(ev);\n\n        /*\n         * The only time we want to intercept motion events is if we are in the\n         * drag mode.\n         */\n        return mIsBeingDragged;\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (mFakeDragging) {\n            // A fake drag is in progress already, ignore this real one\n            // but still eat the touch events.\n            // (It is likely that the user is multi-touching the screen.)\n            return true;\n        }\n\n        if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {\n            // Don't handle edge touches immediately -- they may actually belong to one of our\n            // descendants.\n            return false;\n        }\n\n        if (mAdapter == null || mAdapter.getCount() == 0) {\n            // Nothing to present or scroll; nothing to touch.\n            return false;\n        }\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain();\n        }\n        mVelocityTracker.addMovement(ev);\n\n        final int action = ev.getAction();\n        boolean needsInvalidate = false;\n\n        switch (action & MotionEventCompat.ACTION_MASK) {\n            case MotionEvent.ACTION_DOWN: {\n\n                mScroller.abortAnimation();\n                mPopulatePending = false;\n                populate();\n                mIsBeingDragged = true;\n                setScrollState(SCROLL_STATE_DRAGGING);\n\n                // Remember where the motion event started\n                mLastMotionX = mInitialMotionX = ev.getX();\n                mLastMotionY = mInitialMotionY = ev.getY();\n                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n                break;\n            }\n            case MotionEvent.ACTION_MOVE:\n                if (!mIsBeingDragged) {\n                    final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                    final float x = MotionEventCompat.getX(ev, pointerIndex);\n                    final float xDiff = Math.abs(x - mLastMotionX);\n                    final float y = MotionEventCompat.getY(ev, pointerIndex);\n                    final float yDiff = Math.abs(y - mLastMotionY);\n                    if (DEBUG)\n                        Log.v(TAG, \"Moved x to \" + x + \",\" + y + \" diff=\" + xDiff + \",\" + yDiff);\n                    if (xDiff > mTouchSlop && xDiff > yDiff) {\n                        if (DEBUG) Log.v(TAG, \"Starting drag!\");\n\n                        mIsBeingDragged = true;\n                        mLastMotionX = x - mInitialMotionX > 0 ? mInitialMotionX + mTouchSlop :\n                                mInitialMotionX - mTouchSlop;\n                        mLastMotionY = y;\n                        setScrollState(SCROLL_STATE_DRAGGING);\n                        setScrollingCacheEnabled(true);\n                    }\n                }\n                // Not else! Note that mIsBeingDragged can be set above.\n                if (mIsBeingDragged) {\n                    // Scroll to follow the motion event\n                    final int activePointerIndex = MotionEventCompat.findPointerIndex(\n                            ev, mActivePointerId);\n                    final float x = MotionEventCompat.getX(ev, activePointerIndex);\n                    needsInvalidate |= performDrag(x);\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                if (mIsBeingDragged) {\n\n                    final VelocityTracker velocityTracker = mVelocityTracker;\n                    velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n                    int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(\n                            velocityTracker, mActivePointerId);\n                    mPopulatePending = true;\n                    final int width = getWidth();\n                    final int scrollX = getScrollX();\n                    final ItemInfo ii = infoForCurrentScrollPosition();\n                    final int currentPage = ii.position;\n                    final float pageOffset = (((float) scrollX / width) - ii.offset) / ii.widthFactor;\n                    final int activePointerIndex =\n                            MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                    final float x = MotionEventCompat.getX(ev, activePointerIndex);\n\n                    final int totalDelta = (int) (x - mInitialMotionX);\n                    int nextPage = determineTargetPage(currentPage, pageOffset, initialVelocity,\n                            totalDelta);\n\n                    //Link Add\n                    if (nextPage == currentPage) {\n                        if (mOnPopViewListener != null) {\n                            mOnPopViewListener.onPoped();\n                        }\n                    }\n                    setCurrentItemInternal(nextPage, true, true, initialVelocity);\n\n\n                    mActivePointerId = INVALID_POINTER;\n                    endDrag();\n                    needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();\n                }\n                break;\n            case MotionEvent.ACTION_CANCEL:\n                if (mIsBeingDragged) {\n                    scrollToItem(mCurItem, true, 0, false);\n                    mActivePointerId = INVALID_POINTER;\n                    endDrag();\n                    needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();\n                }\n                break;\n            case MotionEventCompat.ACTION_POINTER_DOWN: {\n                final int index = MotionEventCompat.getActionIndex(ev);\n                final float x = MotionEventCompat.getX(ev, index);\n                mLastMotionX = x;\n                mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n                break;\n            }\n            case MotionEventCompat.ACTION_POINTER_UP:\n                onSecondaryPointerUp(ev);\n                mLastMotionX = MotionEventCompat.getX(ev,\n                        MotionEventCompat.findPointerIndex(ev, mActivePointerId));\n                break;\n        }\n        if (needsInvalidate) {\n            ViewCompat.postInvalidateOnAnimation(this);\n        }\n        return true;\n    }\n\n    private boolean performDrag(float x) {\n        boolean needsInvalidate = false;\n\n        final float deltaX = mLastMotionX - x;\n        mLastMotionX = x;\n\n        float oldScrollX = getScrollX();\n        float scrollX = oldScrollX + deltaX;\n        final int width = getWidth();\n\n        float leftBound = width * mFirstOffset;\n\n        // Link modify\n        // float rightBound = width * mLastOffset;\n        float rightBound = width * mCurItem;\n        boolean leftAbsolute = true;\n        boolean rightAbsolute = true;\n\n        final ItemInfo firstItem = mItems.get(0);\n        final ItemInfo lastItem = mItems.get(mItems.size() - 1);\n        if (firstItem.position != 0) {\n            leftAbsolute = false;\n            leftBound = firstItem.offset * width;\n        }\n\n        // 注释\n\t\t// if (lastItem.position != mAdapter.getCount() - 1) {\n\t\t//\t\trightAbsolute = false;\n\t\t//\t \trightBound = lastItem.offset * width;\n\t\t//\t}\n\n        if (scrollX < leftBound) {\n            if (leftAbsolute) {\n                float over = leftBound - scrollX;\n                needsInvalidate = mLeftEdge.onPull(Math.abs(over) / width);\n            }\n            scrollX = leftBound;\n        } else if (scrollX > rightBound) {\n            if (rightAbsolute) {\n                float over = scrollX - rightBound;\n\n                //Link Modify\n\t\t\t\t// needsInvalidate = mRightEdge.onPull(Math.abs(over) / width);\n                needsInvalidate = true;\n            }\n            scrollX = rightBound;\n        }\n        mLastMotionX += scrollX - (int) scrollX;\n\n        scrollTo((int) scrollX, getScrollY());\n        pageScrolled((int) scrollX);\n\n        return needsInvalidate;\n    }\n","slug":"2013-06-19-viewpage-intercept","published":1,"updated":"2018-02-14T21:36:14.837Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlu0016rpfy62rm0gsi","content":"<p>由于ViewPager是继承ViewGroup的，所以它需要重写<code>onInterceptTouchEvent(MotionEvent ev)</code>函数，来控制父控件与子控件触摸事件传递流程</p>\n<p><a href=\"http://blog.csdn.net/ddna/article/details/5473293\" target=\"_blank\" rel=\"noopener\">知识点： onInterceptTouchEvent和onTouchEvent调用时序</a> 网友总结的知识点</p>\n<p><a href=\"http://developer.android.com/training/gestures/viewgroup.html\" target=\"_blank\" rel=\"noopener\">Google官方指南：Managing Touch Events in a ViewGroup</a></p>\n<blockquote>\n<p>首先吐槽下Google在触摸事件处理流程上的混乱，回调函数中逻辑都乱成浆糊了，ViewPager中仅onInterceptTouchEvent()和onTouchEvent()两个函数就长达270行，中间变量也多的发指！希望将来的能有所改善,类似iOS，清晰回调down，move，cancel等事件</p>\n</blockquote>\n<p>首先分析public boolean onInterceptTouchEvent(MotionEvent ev)函数，顾名思义是拦截触摸事件的回调函数：</p>\n<ul>\n<li>返回false: 表示父控件不拦截触摸事件，而将后续的所有事件传递给子控件</li>\n<li>返回true:  表示父控件拦截了子控件接收触摸事件的机会，而将后续事件转交给了自己的onTouchEvent()函数去处理。</li>\n</ul>\n<p>ViewPager使用了两个重要的变量</p>\n<ol>\n<li>mIsBeingDragged：如果该变量为true，onInterceptionTouchEvent()会立刻返回true，表明”我现在准备要把整个父控件拖动起来了，子控件们都不可能接收到Click,Touch,DoubleClick等触摸事件了”</li>\n<li><p>mIsUnableToDrag: 与mIsBeingDragged相对应，表示父控件的触摸手势被判断为不应该拖动，比如Y轴滑动的距离大于了TouchSlop–&gt;<a href=\"http://developer.android.com/training/gestures/viewgroup.html\" target=\"_blank\" rel=\"noopener\">Google术语</a>,向X轴触摸滑动得角度不足等等情况（具体数据是 xDiff*0.5&gt;yDiff ）.</p>\n<pre><code> // Nothing more to do here if we have decided whether or not we\n// are dragging.\nif (action != MotionEvent.ACTION_DOWN) {\n    if (mIsBeingDragged) {\n        if (DEBUG) Log.v(TAG, &quot;Intercept returning true!&quot;);\n        return true;\n    }\n    if (mIsUnableToDrag) {\n        if (DEBUG) Log.v(TAG, &quot;Intercept returning false!&quot;);\n        return false;\n    }\n}\n</code></pre></li>\n</ol>\n<p>如果用伪代码来写onInteceptTouchEvent()的话大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(action_cancel||action_up)</span><br><span class=\"line\">\treturn\tfalse;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(!action_down)</span><br><span class=\"line\">\t\tif (mIsBeingDragged)</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\tif (mIsUnableToDrag)</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\tswitch(action)&#123;</span><br><span class=\"line\">\t\tcase move:</span><br><span class=\"line\">\t\t\tif(可以滑动&amp;&amp;不是从屏幕边缘开始触摸滑动的)&#123;</span><br><span class=\"line\">\t\t\t\tmIsUnableToDrag=ture;</span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif(xDiff&gt;mTouchSlop &amp;&amp; xDiff*0.5&gt;yDiff)&#123;</span><br><span class=\"line\">\t\t\t\tmIsBeingDragged=true;</span><br><span class=\"line\">\t\t\t&#125;else if(yDiff&gt;mTouchSlop)&#123;</span><br><span class=\"line\">\t\t\t\tmIsUnableToDrag=true;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif(mIsBeingDragged)&#123;</span><br><span class=\"line\">\t\t\t\t//拖动滑行x</span><br><span class=\"line\">\t\t\t\tperformDrag(x);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak；</span><br><span class=\"line\">\t\tcase down：</span><br><span class=\"line\">\t\t\t初始化变量</span><br><span class=\"line\">\t\t\tmIsUnableToDrag=false;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//当ViewPager 正在左右页面切换滑动时，我们按下去之后  直接判断为开始滑动状态，</span><br><span class=\"line\">\t\t\t//mCloseEnough默认值为2(dip),意思是Scroller可能已经快要结束它的动画了，必须要结束X坐标和当前X坐标相差大于2(dip)以上，才认为是还在滑动中</span><br><span class=\"line\">\t\t\tmScroller.computeScrollOffset();</span><br><span class=\"line\">\t\t\tif(mScrollState==SCROLL_STATE_SETTLING&amp;&amp;Math.abs(mScroller.getFinalX()-mScroller.getCurrX())&gt;mCloseEnough)&#123;</span><br><span class=\"line\">\t\t\t\tmIsBeingDragged=true;</span><br><span class=\"line\">\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\tmIsBeingDragged=false;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak；</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\treturn mIsBeingDragged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，我们现在可以假设mIsBeingDragged==true,那么ViewPager就开始回调onTouchEvent(MotionEvent ev)()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">\tif (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.getEdgeFlags() != 0) &#123;</span><br><span class=\"line\">\t\t//按下时触摸到的屏幕边缘，则返回false</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    switch(action)&#123;</span><br><span class=\"line\">    \tcase down:</span><br><span class=\"line\">    \t\t变量初始化</span><br><span class=\"line\">    \t\tmIsBeingDragged=true;</span><br><span class=\"line\">    \t\tbreak;</span><br><span class=\"line\">    \tcase move:</span><br><span class=\"line\">    \t\tif(!mIsBeingDragged)&#123;</span><br><span class=\"line\">    \t\t\tif(xDiff&gt;mTouchSlop &amp;&amp; xDiff &gt; yDiff)&#123;</span><br><span class=\"line\">    \t\t\t\tmIsBeingDragged=true;</span><br><span class=\"line\">    \t\t\t&#125;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\t//Not else! Note that mIsBeingDragged can be set above.</span><br><span class=\"line\">    \t\tif(mIsBeingDragged)&#123;</span><br><span class=\"line\">    \t\t\t // 页面逻辑</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\tbreak;</span><br><span class=\"line\">    \tcase up:</span><br><span class=\"line\">    \t\tif(mIsBeingDragged)&#123;</span><br><span class=\"line\">    \t\t\t // 页面逻辑</span><br><span class=\"line\">    \t\t\t endDrag();</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\tbreak;</span><br><span class=\"line\">    \tcase cancel:</span><br><span class=\"line\">    \t\tif(mIsBeingDragged)&#123;</span><br><span class=\"line\">    \t\t\t // 页面逻辑</span><br><span class=\"line\">    \t\t\t endDrag();</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\tbreak;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可以看出，除了一些特殊情况外，onTouchEvent() 是必定返回true的，页面逻辑里实现了拖动和甩动等效果。</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"##总结\"></a>##总结</h2><p>假如我们要定制一个ViewGroup，类似与ViewPager,需要做手势判断的父控件，我们就有可能需要重写OnInteceptTouchEvent()，在move事件里判断手势，并决定是否拦截，在onTouchEvent里对整个ViewGroup做手势动画。</p>\n<h2 id=\"完整源码\"><a href=\"#完整源码\" class=\"headerlink\" title=\"##完整源码\"></a>##完整源码</h2><pre><code> &lt;!-- java -&gt;\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\n    /*\n     * This method JUST determines whether we want to intercept the motion.\n     * If we return true, onMotionEvent will be called and we do the actual\n     * scrolling there.\n     */\n    final int action = ev.getAction() &amp; MotionEventCompat.ACTION_MASK;\n\n    // Always take care of the touch gesture being complete.\n    if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {\n        // Release the drag.\n        if (DEBUG) Log.v(TAG, &quot;Intercept done!&quot;);\n        mIsBeingDragged = false;\n        mIsUnableToDrag = false;\n        mActivePointerId = INVALID_POINTER;\n        if (mVelocityTracker != null) {\n            mVelocityTracker.recycle();\n            mVelocityTracker = null;\n        }\n        return false;\n    }\n\n    // Nothing more to do here if we have decided whether or not we\n    // are dragging.\n    if (action != MotionEvent.ACTION_DOWN) {\n        if (mIsBeingDragged) {\n            if (DEBUG) Log.v(TAG, &quot;Intercept returning true!&quot;);\n            return true;\n        }\n        if (mIsUnableToDrag) {\n            if (DEBUG) Log.v(TAG, &quot;Intercept returning false!&quot;);\n            return false;\n        }\n    }\n\n    switch (action) {\n        case MotionEvent.ACTION_MOVE: {\n            /*\n             * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check\n             * whether the user has moved far enough from his original down touch.\n             */\n\n            /*\n            * Locally do absolute value. mLastMotionY is set to the y value\n            * of the down event.\n            */\n            final int activePointerId = mActivePointerId;\n            if (activePointerId == INVALID_POINTER) {\n                // If we don&apos;t have a valid id, the touch down wasn&apos;t on content.\n                break;\n            }\n\n            final int pointerIndex = MotionEventCompat.findPointerIndex(ev, activePointerId);\n            final float x = MotionEventCompat.getX(ev, pointerIndex);\n            final float dx = x - mLastMotionX;\n            final float xDiff = Math.abs(dx);\n            final float y = MotionEventCompat.getY(ev, pointerIndex);\n            final float yDiff = Math.abs(y - mInitialMotionY);\n            if (DEBUG)\n                Log.v(TAG, &quot;Moved x to &quot; + x + &quot;,&quot; + y + &quot; diff=&quot; + xDiff + &quot;,&quot; + yDiff);\n\n            if (dx != 0 &amp;&amp; !isGutterDrag(mLastMotionX, dx) &amp;&amp;\n                    canScroll(this, false, (int) dx, (int) x, (int) y)) {\n                // Nested view has scrollable area under this point. Let it be handled there.\n                mLastMotionX = x;\n                mLastMotionY = y;\n                mIsUnableToDrag = true;\n                return false;\n            }\n            // x轴滑动大于 mTouchSlop  x轴滑动大于y轴滑动两倍\n            if (xDiff &gt; mTouchSlop &amp;&amp; xDiff * 0.5f &gt; yDiff) {\n                if (DEBUG) Log.v(TAG, &quot;Starting drag!&quot;);\n                mIsBeingDragged = true;\n                setScrollState(SCROLL_STATE_DRAGGING);\n\n                // mLastMotionX 修正\n                mLastMotionX = dx &gt; 0 ? mInitialMotionX + mTouchSlop :\n                        mInitialMotionX - mTouchSlop;\n                mLastMotionY = y;\n                setScrollingCacheEnabled(true);\n            } else if (yDiff &gt; mTouchSlop) {\n                // The finger has moved enough in the vertical\n                // direction to be counted as a drag...  abort\n                // any attempt to drag horizontally, to work correctly\n                // with children that have scrolling containers.\n                if (DEBUG) Log.v(TAG, &quot;Starting unable to drag!&quot;);\n                mIsUnableToDrag = true;\n            }\n            if (mIsBeingDragged) {\n                // Scroll to follow the motion event\n                if (performDrag(x)) {\n                    ViewCompat.postInvalidateOnAnimation(this);\n                }\n            }\n            break;\n        }\n\n        case MotionEvent.ACTION_DOWN: {\n            /*\n             * Remember location of down touch.\n             * ACTION_DOWN always refers to pointer index 0.\n             */\n            mLastMotionX = mInitialMotionX = ev.getX();\n            mLastMotionY = mInitialMotionY = ev.getY();\n            mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n            mIsUnableToDrag = false;\n\n            mScroller.computeScrollOffset();\n            if (mScrollState == SCROLL_STATE_SETTLING &amp;&amp;\n                    Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) &gt; mCloseEnough) {\n                // Let the user &apos;catch&apos; the pager as it animates.\n                mScroller.abortAnimation();\n                mPopulatePending = false;\n                populate();\n                mIsBeingDragged = true;\n                setScrollState(SCROLL_STATE_DRAGGING);\n            } else {\n                completeScroll(false);\n                mIsBeingDragged = false;\n            }\n\n            if (DEBUG) Log.v(TAG, &quot;Down at &quot; + mLastMotionX + &quot;,&quot; + mLastMotionY\n                    + &quot; mIsBeingDragged=&quot; + mIsBeingDragged\n                    + &quot;mIsUnableToDrag=&quot; + mIsUnableToDrag);\n            break;\n        }\n\n        case MotionEventCompat.ACTION_POINTER_UP:\n            onSecondaryPointerUp(ev);\n            break;\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    /*\n     * The only time we want to intercept motion events is if we are in the\n     * drag mode.\n     */\n    return mIsBeingDragged;\n}\n\n@Override\npublic boolean onTouchEvent(MotionEvent ev) {\n    if (mFakeDragging) {\n        // A fake drag is in progress already, ignore this real one\n        // but still eat the touch events.\n        // (It is likely that the user is multi-touching the screen.)\n        return true;\n    }\n\n    if (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.getEdgeFlags() != 0) {\n        // Don&apos;t handle edge touches immediately -- they may actually belong to one of our\n        // descendants.\n        return false;\n    }\n\n    if (mAdapter == null || mAdapter.getCount() == 0) {\n        // Nothing to present or scroll; nothing to touch.\n        return false;\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    final int action = ev.getAction();\n    boolean needsInvalidate = false;\n\n    switch (action &amp; MotionEventCompat.ACTION_MASK) {\n        case MotionEvent.ACTION_DOWN: {\n\n            mScroller.abortAnimation();\n            mPopulatePending = false;\n            populate();\n            mIsBeingDragged = true;\n            setScrollState(SCROLL_STATE_DRAGGING);\n\n            // Remember where the motion event started\n            mLastMotionX = mInitialMotionX = ev.getX();\n            mLastMotionY = mInitialMotionY = ev.getY();\n            mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n            break;\n        }\n        case MotionEvent.ACTION_MOVE:\n            if (!mIsBeingDragged) {\n                final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, pointerIndex);\n                final float xDiff = Math.abs(x - mLastMotionX);\n                final float y = MotionEventCompat.getY(ev, pointerIndex);\n                final float yDiff = Math.abs(y - mLastMotionY);\n                if (DEBUG)\n                    Log.v(TAG, &quot;Moved x to &quot; + x + &quot;,&quot; + y + &quot; diff=&quot; + xDiff + &quot;,&quot; + yDiff);\n                if (xDiff &gt; mTouchSlop &amp;&amp; xDiff &gt; yDiff) {\n                    if (DEBUG) Log.v(TAG, &quot;Starting drag!&quot;);\n\n                    mIsBeingDragged = true;\n                    mLastMotionX = x - mInitialMotionX &gt; 0 ? mInitialMotionX + mTouchSlop :\n                            mInitialMotionX - mTouchSlop;\n                    mLastMotionY = y;\n                    setScrollState(SCROLL_STATE_DRAGGING);\n                    setScrollingCacheEnabled(true);\n                }\n            }\n            // Not else! Note that mIsBeingDragged can be set above.\n            if (mIsBeingDragged) {\n                // Scroll to follow the motion event\n                final int activePointerIndex = MotionEventCompat.findPointerIndex(\n                        ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, activePointerIndex);\n                needsInvalidate |= performDrag(x);\n            }\n            break;\n        case MotionEvent.ACTION_UP:\n            if (mIsBeingDragged) {\n\n                final VelocityTracker velocityTracker = mVelocityTracker;\n                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n                int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(\n                        velocityTracker, mActivePointerId);\n                mPopulatePending = true;\n                final int width = getWidth();\n                final int scrollX = getScrollX();\n                final ItemInfo ii = infoForCurrentScrollPosition();\n                final int currentPage = ii.position;\n                final float pageOffset = (((float) scrollX / width) - ii.offset) / ii.widthFactor;\n                final int activePointerIndex =\n                        MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, activePointerIndex);\n\n                final int totalDelta = (int) (x - mInitialMotionX);\n                int nextPage = determineTargetPage(currentPage, pageOffset, initialVelocity,\n                        totalDelta);\n\n                //Link Add\n                if (nextPage == currentPage) {\n                    if (mOnPopViewListener != null) {\n                        mOnPopViewListener.onPoped();\n                    }\n                }\n                setCurrentItemInternal(nextPage, true, true, initialVelocity);\n\n\n                mActivePointerId = INVALID_POINTER;\n                endDrag();\n                needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();\n            }\n            break;\n        case MotionEvent.ACTION_CANCEL:\n            if (mIsBeingDragged) {\n                scrollToItem(mCurItem, true, 0, false);\n                mActivePointerId = INVALID_POINTER;\n                endDrag();\n                needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();\n            }\n            break;\n        case MotionEventCompat.ACTION_POINTER_DOWN: {\n            final int index = MotionEventCompat.getActionIndex(ev);\n            final float x = MotionEventCompat.getX(ev, index);\n            mLastMotionX = x;\n            mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n            break;\n        }\n        case MotionEventCompat.ACTION_POINTER_UP:\n            onSecondaryPointerUp(ev);\n            mLastMotionX = MotionEventCompat.getX(ev,\n                    MotionEventCompat.findPointerIndex(ev, mActivePointerId));\n            break;\n    }\n    if (needsInvalidate) {\n        ViewCompat.postInvalidateOnAnimation(this);\n    }\n    return true;\n}\n\nprivate boolean performDrag(float x) {\n    boolean needsInvalidate = false;\n\n    final float deltaX = mLastMotionX - x;\n    mLastMotionX = x;\n\n    float oldScrollX = getScrollX();\n    float scrollX = oldScrollX + deltaX;\n    final int width = getWidth();\n\n    float leftBound = width * mFirstOffset;\n\n    // Link modify\n    // float rightBound = width * mLastOffset;\n    float rightBound = width * mCurItem;\n    boolean leftAbsolute = true;\n    boolean rightAbsolute = true;\n\n    final ItemInfo firstItem = mItems.get(0);\n    final ItemInfo lastItem = mItems.get(mItems.size() - 1);\n    if (firstItem.position != 0) {\n        leftAbsolute = false;\n        leftBound = firstItem.offset * width;\n    }\n\n    // 注释\n    // if (lastItem.position != mAdapter.getCount() - 1) {\n    //        rightAbsolute = false;\n    //         rightBound = lastItem.offset * width;\n    //    }\n\n    if (scrollX &lt; leftBound) {\n        if (leftAbsolute) {\n            float over = leftBound - scrollX;\n            needsInvalidate = mLeftEdge.onPull(Math.abs(over) / width);\n        }\n        scrollX = leftBound;\n    } else if (scrollX &gt; rightBound) {\n        if (rightAbsolute) {\n            float over = scrollX - rightBound;\n\n            //Link Modify\n            // needsInvalidate = mRightEdge.onPull(Math.abs(over) / width);\n            needsInvalidate = true;\n        }\n        scrollX = rightBound;\n    }\n    mLastMotionX += scrollX - (int) scrollX;\n\n    scrollTo((int) scrollX, getScrollY());\n    pageScrolled((int) scrollX);\n\n    return needsInvalidate;\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>由于ViewPager是继承ViewGroup的，所以它需要重写<code>onInterceptTouchEvent(MotionEvent ev)</code>函数，来控制父控件与子控件触摸事件传递流程</p>\n<p><a href=\"http://blog.csdn.net/ddna/article/details/5473293\" target=\"_blank\" rel=\"noopener\">知识点： onInterceptTouchEvent和onTouchEvent调用时序</a> 网友总结的知识点</p>\n<p><a href=\"http://developer.android.com/training/gestures/viewgroup.html\" target=\"_blank\" rel=\"noopener\">Google官方指南：Managing Touch Events in a ViewGroup</a></p>\n<blockquote>\n<p>首先吐槽下Google在触摸事件处理流程上的混乱，回调函数中逻辑都乱成浆糊了，ViewPager中仅onInterceptTouchEvent()和onTouchEvent()两个函数就长达270行，中间变量也多的发指！希望将来的能有所改善,类似iOS，清晰回调down，move，cancel等事件</p>\n</blockquote>\n<p>首先分析public boolean onInterceptTouchEvent(MotionEvent ev)函数，顾名思义是拦截触摸事件的回调函数：</p>\n<ul>\n<li>返回false: 表示父控件不拦截触摸事件，而将后续的所有事件传递给子控件</li>\n<li>返回true:  表示父控件拦截了子控件接收触摸事件的机会，而将后续事件转交给了自己的onTouchEvent()函数去处理。</li>\n</ul>\n<p>ViewPager使用了两个重要的变量</p>\n<ol>\n<li>mIsBeingDragged：如果该变量为true，onInterceptionTouchEvent()会立刻返回true，表明”我现在准备要把整个父控件拖动起来了，子控件们都不可能接收到Click,Touch,DoubleClick等触摸事件了”</li>\n<li><p>mIsUnableToDrag: 与mIsBeingDragged相对应，表示父控件的触摸手势被判断为不应该拖动，比如Y轴滑动的距离大于了TouchSlop–&gt;<a href=\"http://developer.android.com/training/gestures/viewgroup.html\" target=\"_blank\" rel=\"noopener\">Google术语</a>,向X轴触摸滑动得角度不足等等情况（具体数据是 xDiff*0.5&gt;yDiff ）.</p>\n<pre><code> // Nothing more to do here if we have decided whether or not we\n// are dragging.\nif (action != MotionEvent.ACTION_DOWN) {\n    if (mIsBeingDragged) {\n        if (DEBUG) Log.v(TAG, &quot;Intercept returning true!&quot;);\n        return true;\n    }\n    if (mIsUnableToDrag) {\n        if (DEBUG) Log.v(TAG, &quot;Intercept returning false!&quot;);\n        return false;\n    }\n}\n</code></pre></li>\n</ol>\n<p>如果用伪代码来写onInteceptTouchEvent()的话大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(action_cancel||action_up)</span><br><span class=\"line\">\treturn\tfalse;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(!action_down)</span><br><span class=\"line\">\t\tif (mIsBeingDragged)</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\tif (mIsUnableToDrag)</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\tswitch(action)&#123;</span><br><span class=\"line\">\t\tcase move:</span><br><span class=\"line\">\t\t\tif(可以滑动&amp;&amp;不是从屏幕边缘开始触摸滑动的)&#123;</span><br><span class=\"line\">\t\t\t\tmIsUnableToDrag=ture;</span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif(xDiff&gt;mTouchSlop &amp;&amp; xDiff*0.5&gt;yDiff)&#123;</span><br><span class=\"line\">\t\t\t\tmIsBeingDragged=true;</span><br><span class=\"line\">\t\t\t&#125;else if(yDiff&gt;mTouchSlop)&#123;</span><br><span class=\"line\">\t\t\t\tmIsUnableToDrag=true;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif(mIsBeingDragged)&#123;</span><br><span class=\"line\">\t\t\t\t//拖动滑行x</span><br><span class=\"line\">\t\t\t\tperformDrag(x);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak；</span><br><span class=\"line\">\t\tcase down：</span><br><span class=\"line\">\t\t\t初始化变量</span><br><span class=\"line\">\t\t\tmIsUnableToDrag=false;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//当ViewPager 正在左右页面切换滑动时，我们按下去之后  直接判断为开始滑动状态，</span><br><span class=\"line\">\t\t\t//mCloseEnough默认值为2(dip),意思是Scroller可能已经快要结束它的动画了，必须要结束X坐标和当前X坐标相差大于2(dip)以上，才认为是还在滑动中</span><br><span class=\"line\">\t\t\tmScroller.computeScrollOffset();</span><br><span class=\"line\">\t\t\tif(mScrollState==SCROLL_STATE_SETTLING&amp;&amp;Math.abs(mScroller.getFinalX()-mScroller.getCurrX())&gt;mCloseEnough)&#123;</span><br><span class=\"line\">\t\t\t\tmIsBeingDragged=true;</span><br><span class=\"line\">\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\tmIsBeingDragged=false;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak；</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\treturn mIsBeingDragged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，我们现在可以假设mIsBeingDragged==true,那么ViewPager就开始回调onTouchEvent(MotionEvent ev)()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">\tif (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.getEdgeFlags() != 0) &#123;</span><br><span class=\"line\">\t\t//按下时触摸到的屏幕边缘，则返回false</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    switch(action)&#123;</span><br><span class=\"line\">    \tcase down:</span><br><span class=\"line\">    \t\t变量初始化</span><br><span class=\"line\">    \t\tmIsBeingDragged=true;</span><br><span class=\"line\">    \t\tbreak;</span><br><span class=\"line\">    \tcase move:</span><br><span class=\"line\">    \t\tif(!mIsBeingDragged)&#123;</span><br><span class=\"line\">    \t\t\tif(xDiff&gt;mTouchSlop &amp;&amp; xDiff &gt; yDiff)&#123;</span><br><span class=\"line\">    \t\t\t\tmIsBeingDragged=true;</span><br><span class=\"line\">    \t\t\t&#125;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\t//Not else! Note that mIsBeingDragged can be set above.</span><br><span class=\"line\">    \t\tif(mIsBeingDragged)&#123;</span><br><span class=\"line\">    \t\t\t // 页面逻辑</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\tbreak;</span><br><span class=\"line\">    \tcase up:</span><br><span class=\"line\">    \t\tif(mIsBeingDragged)&#123;</span><br><span class=\"line\">    \t\t\t // 页面逻辑</span><br><span class=\"line\">    \t\t\t endDrag();</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\tbreak;</span><br><span class=\"line\">    \tcase cancel:</span><br><span class=\"line\">    \t\tif(mIsBeingDragged)&#123;</span><br><span class=\"line\">    \t\t\t // 页面逻辑</span><br><span class=\"line\">    \t\t\t endDrag();</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\tbreak;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可以看出，除了一些特殊情况外，onTouchEvent() 是必定返回true的，页面逻辑里实现了拖动和甩动等效果。</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"##总结\"></a>##总结</h2><p>假如我们要定制一个ViewGroup，类似与ViewPager,需要做手势判断的父控件，我们就有可能需要重写OnInteceptTouchEvent()，在move事件里判断手势，并决定是否拦截，在onTouchEvent里对整个ViewGroup做手势动画。</p>\n<h2 id=\"完整源码\"><a href=\"#完整源码\" class=\"headerlink\" title=\"##完整源码\"></a>##完整源码</h2><pre><code> &lt;!-- java -&gt;\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\n    /*\n     * This method JUST determines whether we want to intercept the motion.\n     * If we return true, onMotionEvent will be called and we do the actual\n     * scrolling there.\n     */\n    final int action = ev.getAction() &amp; MotionEventCompat.ACTION_MASK;\n\n    // Always take care of the touch gesture being complete.\n    if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {\n        // Release the drag.\n        if (DEBUG) Log.v(TAG, &quot;Intercept done!&quot;);\n        mIsBeingDragged = false;\n        mIsUnableToDrag = false;\n        mActivePointerId = INVALID_POINTER;\n        if (mVelocityTracker != null) {\n            mVelocityTracker.recycle();\n            mVelocityTracker = null;\n        }\n        return false;\n    }\n\n    // Nothing more to do here if we have decided whether or not we\n    // are dragging.\n    if (action != MotionEvent.ACTION_DOWN) {\n        if (mIsBeingDragged) {\n            if (DEBUG) Log.v(TAG, &quot;Intercept returning true!&quot;);\n            return true;\n        }\n        if (mIsUnableToDrag) {\n            if (DEBUG) Log.v(TAG, &quot;Intercept returning false!&quot;);\n            return false;\n        }\n    }\n\n    switch (action) {\n        case MotionEvent.ACTION_MOVE: {\n            /*\n             * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check\n             * whether the user has moved far enough from his original down touch.\n             */\n\n            /*\n            * Locally do absolute value. mLastMotionY is set to the y value\n            * of the down event.\n            */\n            final int activePointerId = mActivePointerId;\n            if (activePointerId == INVALID_POINTER) {\n                // If we don&apos;t have a valid id, the touch down wasn&apos;t on content.\n                break;\n            }\n\n            final int pointerIndex = MotionEventCompat.findPointerIndex(ev, activePointerId);\n            final float x = MotionEventCompat.getX(ev, pointerIndex);\n            final float dx = x - mLastMotionX;\n            final float xDiff = Math.abs(dx);\n            final float y = MotionEventCompat.getY(ev, pointerIndex);\n            final float yDiff = Math.abs(y - mInitialMotionY);\n            if (DEBUG)\n                Log.v(TAG, &quot;Moved x to &quot; + x + &quot;,&quot; + y + &quot; diff=&quot; + xDiff + &quot;,&quot; + yDiff);\n\n            if (dx != 0 &amp;&amp; !isGutterDrag(mLastMotionX, dx) &amp;&amp;\n                    canScroll(this, false, (int) dx, (int) x, (int) y)) {\n                // Nested view has scrollable area under this point. Let it be handled there.\n                mLastMotionX = x;\n                mLastMotionY = y;\n                mIsUnableToDrag = true;\n                return false;\n            }\n            // x轴滑动大于 mTouchSlop  x轴滑动大于y轴滑动两倍\n            if (xDiff &gt; mTouchSlop &amp;&amp; xDiff * 0.5f &gt; yDiff) {\n                if (DEBUG) Log.v(TAG, &quot;Starting drag!&quot;);\n                mIsBeingDragged = true;\n                setScrollState(SCROLL_STATE_DRAGGING);\n\n                // mLastMotionX 修正\n                mLastMotionX = dx &gt; 0 ? mInitialMotionX + mTouchSlop :\n                        mInitialMotionX - mTouchSlop;\n                mLastMotionY = y;\n                setScrollingCacheEnabled(true);\n            } else if (yDiff &gt; mTouchSlop) {\n                // The finger has moved enough in the vertical\n                // direction to be counted as a drag...  abort\n                // any attempt to drag horizontally, to work correctly\n                // with children that have scrolling containers.\n                if (DEBUG) Log.v(TAG, &quot;Starting unable to drag!&quot;);\n                mIsUnableToDrag = true;\n            }\n            if (mIsBeingDragged) {\n                // Scroll to follow the motion event\n                if (performDrag(x)) {\n                    ViewCompat.postInvalidateOnAnimation(this);\n                }\n            }\n            break;\n        }\n\n        case MotionEvent.ACTION_DOWN: {\n            /*\n             * Remember location of down touch.\n             * ACTION_DOWN always refers to pointer index 0.\n             */\n            mLastMotionX = mInitialMotionX = ev.getX();\n            mLastMotionY = mInitialMotionY = ev.getY();\n            mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n            mIsUnableToDrag = false;\n\n            mScroller.computeScrollOffset();\n            if (mScrollState == SCROLL_STATE_SETTLING &amp;&amp;\n                    Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) &gt; mCloseEnough) {\n                // Let the user &apos;catch&apos; the pager as it animates.\n                mScroller.abortAnimation();\n                mPopulatePending = false;\n                populate();\n                mIsBeingDragged = true;\n                setScrollState(SCROLL_STATE_DRAGGING);\n            } else {\n                completeScroll(false);\n                mIsBeingDragged = false;\n            }\n\n            if (DEBUG) Log.v(TAG, &quot;Down at &quot; + mLastMotionX + &quot;,&quot; + mLastMotionY\n                    + &quot; mIsBeingDragged=&quot; + mIsBeingDragged\n                    + &quot;mIsUnableToDrag=&quot; + mIsUnableToDrag);\n            break;\n        }\n\n        case MotionEventCompat.ACTION_POINTER_UP:\n            onSecondaryPointerUp(ev);\n            break;\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    /*\n     * The only time we want to intercept motion events is if we are in the\n     * drag mode.\n     */\n    return mIsBeingDragged;\n}\n\n@Override\npublic boolean onTouchEvent(MotionEvent ev) {\n    if (mFakeDragging) {\n        // A fake drag is in progress already, ignore this real one\n        // but still eat the touch events.\n        // (It is likely that the user is multi-touching the screen.)\n        return true;\n    }\n\n    if (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.getEdgeFlags() != 0) {\n        // Don&apos;t handle edge touches immediately -- they may actually belong to one of our\n        // descendants.\n        return false;\n    }\n\n    if (mAdapter == null || mAdapter.getCount() == 0) {\n        // Nothing to present or scroll; nothing to touch.\n        return false;\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    final int action = ev.getAction();\n    boolean needsInvalidate = false;\n\n    switch (action &amp; MotionEventCompat.ACTION_MASK) {\n        case MotionEvent.ACTION_DOWN: {\n\n            mScroller.abortAnimation();\n            mPopulatePending = false;\n            populate();\n            mIsBeingDragged = true;\n            setScrollState(SCROLL_STATE_DRAGGING);\n\n            // Remember where the motion event started\n            mLastMotionX = mInitialMotionX = ev.getX();\n            mLastMotionY = mInitialMotionY = ev.getY();\n            mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n            break;\n        }\n        case MotionEvent.ACTION_MOVE:\n            if (!mIsBeingDragged) {\n                final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, pointerIndex);\n                final float xDiff = Math.abs(x - mLastMotionX);\n                final float y = MotionEventCompat.getY(ev, pointerIndex);\n                final float yDiff = Math.abs(y - mLastMotionY);\n                if (DEBUG)\n                    Log.v(TAG, &quot;Moved x to &quot; + x + &quot;,&quot; + y + &quot; diff=&quot; + xDiff + &quot;,&quot; + yDiff);\n                if (xDiff &gt; mTouchSlop &amp;&amp; xDiff &gt; yDiff) {\n                    if (DEBUG) Log.v(TAG, &quot;Starting drag!&quot;);\n\n                    mIsBeingDragged = true;\n                    mLastMotionX = x - mInitialMotionX &gt; 0 ? mInitialMotionX + mTouchSlop :\n                            mInitialMotionX - mTouchSlop;\n                    mLastMotionY = y;\n                    setScrollState(SCROLL_STATE_DRAGGING);\n                    setScrollingCacheEnabled(true);\n                }\n            }\n            // Not else! Note that mIsBeingDragged can be set above.\n            if (mIsBeingDragged) {\n                // Scroll to follow the motion event\n                final int activePointerIndex = MotionEventCompat.findPointerIndex(\n                        ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, activePointerIndex);\n                needsInvalidate |= performDrag(x);\n            }\n            break;\n        case MotionEvent.ACTION_UP:\n            if (mIsBeingDragged) {\n\n                final VelocityTracker velocityTracker = mVelocityTracker;\n                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n                int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(\n                        velocityTracker, mActivePointerId);\n                mPopulatePending = true;\n                final int width = getWidth();\n                final int scrollX = getScrollX();\n                final ItemInfo ii = infoForCurrentScrollPosition();\n                final int currentPage = ii.position;\n                final float pageOffset = (((float) scrollX / width) - ii.offset) / ii.widthFactor;\n                final int activePointerIndex =\n                        MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, activePointerIndex);\n\n                final int totalDelta = (int) (x - mInitialMotionX);\n                int nextPage = determineTargetPage(currentPage, pageOffset, initialVelocity,\n                        totalDelta);\n\n                //Link Add\n                if (nextPage == currentPage) {\n                    if (mOnPopViewListener != null) {\n                        mOnPopViewListener.onPoped();\n                    }\n                }\n                setCurrentItemInternal(nextPage, true, true, initialVelocity);\n\n\n                mActivePointerId = INVALID_POINTER;\n                endDrag();\n                needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();\n            }\n            break;\n        case MotionEvent.ACTION_CANCEL:\n            if (mIsBeingDragged) {\n                scrollToItem(mCurItem, true, 0, false);\n                mActivePointerId = INVALID_POINTER;\n                endDrag();\n                needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();\n            }\n            break;\n        case MotionEventCompat.ACTION_POINTER_DOWN: {\n            final int index = MotionEventCompat.getActionIndex(ev);\n            final float x = MotionEventCompat.getX(ev, index);\n            mLastMotionX = x;\n            mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n            break;\n        }\n        case MotionEventCompat.ACTION_POINTER_UP:\n            onSecondaryPointerUp(ev);\n            mLastMotionX = MotionEventCompat.getX(ev,\n                    MotionEventCompat.findPointerIndex(ev, mActivePointerId));\n            break;\n    }\n    if (needsInvalidate) {\n        ViewCompat.postInvalidateOnAnimation(this);\n    }\n    return true;\n}\n\nprivate boolean performDrag(float x) {\n    boolean needsInvalidate = false;\n\n    final float deltaX = mLastMotionX - x;\n    mLastMotionX = x;\n\n    float oldScrollX = getScrollX();\n    float scrollX = oldScrollX + deltaX;\n    final int width = getWidth();\n\n    float leftBound = width * mFirstOffset;\n\n    // Link modify\n    // float rightBound = width * mLastOffset;\n    float rightBound = width * mCurItem;\n    boolean leftAbsolute = true;\n    boolean rightAbsolute = true;\n\n    final ItemInfo firstItem = mItems.get(0);\n    final ItemInfo lastItem = mItems.get(mItems.size() - 1);\n    if (firstItem.position != 0) {\n        leftAbsolute = false;\n        leftBound = firstItem.offset * width;\n    }\n\n    // 注释\n    // if (lastItem.position != mAdapter.getCount() - 1) {\n    //        rightAbsolute = false;\n    //         rightBound = lastItem.offset * width;\n    //    }\n\n    if (scrollX &lt; leftBound) {\n        if (leftAbsolute) {\n            float over = leftBound - scrollX;\n            needsInvalidate = mLeftEdge.onPull(Math.abs(over) / width);\n        }\n        scrollX = leftBound;\n    } else if (scrollX &gt; rightBound) {\n        if (rightAbsolute) {\n            float over = scrollX - rightBound;\n\n            //Link Modify\n            // needsInvalidate = mRightEdge.onPull(Math.abs(over) / width);\n            needsInvalidate = true;\n        }\n        scrollX = rightBound;\n    }\n    mLastMotionX += scrollX - (int) scrollX;\n\n    scrollTo((int) scrollX, getScrollY());\n    pageScrolled((int) scrollX);\n\n    return needsInvalidate;\n}\n</code></pre>"},{"date":"2013-07-31T16:00:00.000Z","layout":"post","title":"Custom Class Loading in Dalvik (译)","_content":"\n[原文链接](http://android-developers.blogspot.com/2011/07/custom-class-loading-in-dalvik.html)\n\nDalvik虚拟机为开发者执行自定类加载提供了便利。除了从本地加载Dalvik可执行文件(\"dex\"),应用程序可以从备选地点如内部存储或者网络上加载它们。\n\n这种技术不是适用每个应用程序的，事实上，大部分没有使用这种技术的也工作的很好。然而，有些情况下自定义类加载会得心应手。这里有一对情景：\n\n巨大的应用程序包含超过64k个方法引用，超出了在一个dex文件里支持的最大值。为了绕过这个限制，开发者可以将这个程序分成多个二级dex文件，然后在运行时加载它们。\n\n开发者可以将它们的框架设计成执行逻辑具有很好的可扩展性，然后通过在运行时动态加载代码。\n\n我们已经创建了一个[应用](https://code.google.com/p/android-custom-class-loading-sample/)来演示分割的dex文件和运行时类加载。（请注意，在下面讨论的原因，应用不能用ADT Eclipse plug-in 构建，而使用包含其中的Ant构建脚本,详细查看Readme.txt）\n\nApp有一个简单的Activity来调用一个类库组件以显示一个Toast.Activity和它的资源包含在默认的dex中，而类库代码是被存储在二级dex中并绑定在APK。这需要一个修改的构建过程，也就是接下来将详细展示的。\n\n在类方法可以被调用前，App首先必须明确地加载二级dex文件。让我们看看这些相关的moving parts\n\n##代码组织\n---\n\n应用包含3个类\n\ncom.example.dex.MainActivity: UI component from which the library is invoked\n\ncom.example.dex.LibraryInterface: Interface definition for the library\n\ncom.example.dex.lib.LibraryProvider: Implementation of the library\n\n类库被打包在一个二级dex中，而其余类包含在默认（主要的）dex文件中，“Build Process”章节说明了如何完成它。当然，打包策略依赖于特殊场景--开发者正要处理的问题。\n\n##类加载和方法调用\n---\n\n二级dex文件--含有LibraryProvider,存储为App的asset。首先，它必须拷贝到一个路径能被类加载器访问到的存储位置。示例App使用了App的私有内部存储空间做到了这点。（从技术上来说，外部存储也可以，但要考虑到将App二进制文件保存在那里的安全性问题）\n\n下面片段来自MainActivity--使用标准文件I/O完成拷贝工作\n\n\t// Before the secondary dex file can be processed by the DexClassLoader,\n  \t// it has to be first copied from asset resource to a storage location.\n  \tFile dexInternalStoragePath = new File(getDir(\"dex\", Context.MODE_PRIVATE),\n          SECONDARY_DEX_NAME);\n  \t...\n  \tBufferedInputStream bis = null;\n  \tOutputStream dexWriter = null；\n  \tstatic final int BUF_SIZE = 8 * 1024;\n  \ttry {\n      bis = new BufferedInputStream(getAssets().open(SECONDARY_DEX_NAME));\n      dexWriter = new BufferedOutputStream(\n          new FileOutputStream(dexInternalStoragePath));\n      byte[] buf = new byte[BUF_SIZE];\n      int len;\n      while((len = bis.read(buf, 0, BUF_SIZE)) > 0) {\n          dexWriter.write(buf, 0, len);\n      }\n      dexWriter.close();\n      bis.close();\n  \t} catch (. . .) {...}\n\n接着，DexClassLoader被实例化去加载来自提取出来的二级dex文件的类库。有两种方式去调用加载了的类方法以这种方式。在示例中，类实例转换成接口，然后直接调用方法。\n\n另一个途径是使用反射API调用方法。使用反射的优点是它不要求二级dex文件去实现任何特殊的接口，然而你应该察觉到反射很啰嗦而且慢。\n\n\n  \t// Internal storage where the DexClassLoader writes the optimized dex file to\n  \tfinal File optimizedDexOutputPath = getDir(\"outdex\", Context.MODE_PRIVATE);\n\n  \tDexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(),\n                                         optimizedDexOutputPath.getAbsolutePath(),\n                                         null,\n                                         getClassLoader());\n  \tClass libProviderClazz = null;\n  \ttry {\n      \t// Load the library.\n      \tlibProviderClazz =\n          cl.loadClass(\"com.example.dex.lib.LibraryProvider\");\n      \t// Cast the return object to the library interface so that the\n      \t// caller can directly invoke methods in the interface.\n      \t// Alternatively, the caller can invoke methods through reflection,\n      \t// which is more verbose.\n      \tLibraryInterface lib = (LibraryInterface) libProviderClazz.newInstance();\n      \tlib.showAwesomeToast(this, \"hello\");\n  \t} catch (Exception e) { ... }\n\n##构建过程\n---\n\n为了churn out 两个分开的dex文件，我们需要tweak标准的构建过程。完成这个戏法，我们只要简单地修改\"-dex\"目标，在项目的Ant build.xml中。\n\n修改了的\"-dex\"目标执行以下操作：\n\n创建两个临时目录去存储.class文件，用来被转换为默认的dex和二级dex。\n\n有选择性的从Project_Root/bin/classes拷贝.class文件到这两个临时目录。\n\n      <!-- Primary dex to include everything but the concrete library\n                 implementation. -->\n            <copy todir=\"${out.classes.absolute.dir}.1\" >\n                <fileset dir=\"${out.classes.absolute.dir}\" >\n                        <exclude name=\"com/example/dex/lib/**\" />\n                </fileset>\n            </copy>\n            <!-- Secondary dex to include the concrete library implementation. -->\n            <copy todir=\"${out.classes.absolute.dir}.2\" >\n                <fileset dir=\"${out.classes.absolute.dir}\" >\n                        <include name=\"com/example/dex/lib/**\" />\n                </fileset>\n            </copy>     \n\n将两个临时目录的.class文件转换成两个分开的dex文件\n\n添加二级dex文件到一个jar文件--DexClassLoader的预期输入格式。最后，存储jar文件到项目的assets目录下。\n\n\n    <!-- Package the output in the assets directory of the apk. -->\n            <jar destfile=\"${asset.absolute.dir}/secondary_dex.jar\"\n                   basedir=\"${out.absolute.dir}/secondary_dex_dir\"\n                   includes=\"classes.dex\" />\n\n\nTo kick-off the build, you execute ant debug (or release) from the project root directory.\n\nThat’s it! In the right situations, dynamic class loading can be quite useful.\n","source":"_posts/2013-08-01-dynamic_load.md","raw":"---\ncategory: Android\ndate: 2013-08-01\nlayout: post\ntitle:  Custom Class Loading in Dalvik (译)\n---\n\n[原文链接](http://android-developers.blogspot.com/2011/07/custom-class-loading-in-dalvik.html)\n\nDalvik虚拟机为开发者执行自定类加载提供了便利。除了从本地加载Dalvik可执行文件(\"dex\"),应用程序可以从备选地点如内部存储或者网络上加载它们。\n\n这种技术不是适用每个应用程序的，事实上，大部分没有使用这种技术的也工作的很好。然而，有些情况下自定义类加载会得心应手。这里有一对情景：\n\n巨大的应用程序包含超过64k个方法引用，超出了在一个dex文件里支持的最大值。为了绕过这个限制，开发者可以将这个程序分成多个二级dex文件，然后在运行时加载它们。\n\n开发者可以将它们的框架设计成执行逻辑具有很好的可扩展性，然后通过在运行时动态加载代码。\n\n我们已经创建了一个[应用](https://code.google.com/p/android-custom-class-loading-sample/)来演示分割的dex文件和运行时类加载。（请注意，在下面讨论的原因，应用不能用ADT Eclipse plug-in 构建，而使用包含其中的Ant构建脚本,详细查看Readme.txt）\n\nApp有一个简单的Activity来调用一个类库组件以显示一个Toast.Activity和它的资源包含在默认的dex中，而类库代码是被存储在二级dex中并绑定在APK。这需要一个修改的构建过程，也就是接下来将详细展示的。\n\n在类方法可以被调用前，App首先必须明确地加载二级dex文件。让我们看看这些相关的moving parts\n\n##代码组织\n---\n\n应用包含3个类\n\ncom.example.dex.MainActivity: UI component from which the library is invoked\n\ncom.example.dex.LibraryInterface: Interface definition for the library\n\ncom.example.dex.lib.LibraryProvider: Implementation of the library\n\n类库被打包在一个二级dex中，而其余类包含在默认（主要的）dex文件中，“Build Process”章节说明了如何完成它。当然，打包策略依赖于特殊场景--开发者正要处理的问题。\n\n##类加载和方法调用\n---\n\n二级dex文件--含有LibraryProvider,存储为App的asset。首先，它必须拷贝到一个路径能被类加载器访问到的存储位置。示例App使用了App的私有内部存储空间做到了这点。（从技术上来说，外部存储也可以，但要考虑到将App二进制文件保存在那里的安全性问题）\n\n下面片段来自MainActivity--使用标准文件I/O完成拷贝工作\n\n\t// Before the secondary dex file can be processed by the DexClassLoader,\n  \t// it has to be first copied from asset resource to a storage location.\n  \tFile dexInternalStoragePath = new File(getDir(\"dex\", Context.MODE_PRIVATE),\n          SECONDARY_DEX_NAME);\n  \t...\n  \tBufferedInputStream bis = null;\n  \tOutputStream dexWriter = null；\n  \tstatic final int BUF_SIZE = 8 * 1024;\n  \ttry {\n      bis = new BufferedInputStream(getAssets().open(SECONDARY_DEX_NAME));\n      dexWriter = new BufferedOutputStream(\n          new FileOutputStream(dexInternalStoragePath));\n      byte[] buf = new byte[BUF_SIZE];\n      int len;\n      while((len = bis.read(buf, 0, BUF_SIZE)) > 0) {\n          dexWriter.write(buf, 0, len);\n      }\n      dexWriter.close();\n      bis.close();\n  \t} catch (. . .) {...}\n\n接着，DexClassLoader被实例化去加载来自提取出来的二级dex文件的类库。有两种方式去调用加载了的类方法以这种方式。在示例中，类实例转换成接口，然后直接调用方法。\n\n另一个途径是使用反射API调用方法。使用反射的优点是它不要求二级dex文件去实现任何特殊的接口，然而你应该察觉到反射很啰嗦而且慢。\n\n\n  \t// Internal storage where the DexClassLoader writes the optimized dex file to\n  \tfinal File optimizedDexOutputPath = getDir(\"outdex\", Context.MODE_PRIVATE);\n\n  \tDexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(),\n                                         optimizedDexOutputPath.getAbsolutePath(),\n                                         null,\n                                         getClassLoader());\n  \tClass libProviderClazz = null;\n  \ttry {\n      \t// Load the library.\n      \tlibProviderClazz =\n          cl.loadClass(\"com.example.dex.lib.LibraryProvider\");\n      \t// Cast the return object to the library interface so that the\n      \t// caller can directly invoke methods in the interface.\n      \t// Alternatively, the caller can invoke methods through reflection,\n      \t// which is more verbose.\n      \tLibraryInterface lib = (LibraryInterface) libProviderClazz.newInstance();\n      \tlib.showAwesomeToast(this, \"hello\");\n  \t} catch (Exception e) { ... }\n\n##构建过程\n---\n\n为了churn out 两个分开的dex文件，我们需要tweak标准的构建过程。完成这个戏法，我们只要简单地修改\"-dex\"目标，在项目的Ant build.xml中。\n\n修改了的\"-dex\"目标执行以下操作：\n\n创建两个临时目录去存储.class文件，用来被转换为默认的dex和二级dex。\n\n有选择性的从Project_Root/bin/classes拷贝.class文件到这两个临时目录。\n\n      <!-- Primary dex to include everything but the concrete library\n                 implementation. -->\n            <copy todir=\"${out.classes.absolute.dir}.1\" >\n                <fileset dir=\"${out.classes.absolute.dir}\" >\n                        <exclude name=\"com/example/dex/lib/**\" />\n                </fileset>\n            </copy>\n            <!-- Secondary dex to include the concrete library implementation. -->\n            <copy todir=\"${out.classes.absolute.dir}.2\" >\n                <fileset dir=\"${out.classes.absolute.dir}\" >\n                        <include name=\"com/example/dex/lib/**\" />\n                </fileset>\n            </copy>     \n\n将两个临时目录的.class文件转换成两个分开的dex文件\n\n添加二级dex文件到一个jar文件--DexClassLoader的预期输入格式。最后，存储jar文件到项目的assets目录下。\n\n\n    <!-- Package the output in the assets directory of the apk. -->\n            <jar destfile=\"${asset.absolute.dir}/secondary_dex.jar\"\n                   basedir=\"${out.absolute.dir}/secondary_dex_dir\"\n                   includes=\"classes.dex\" />\n\n\nTo kick-off the build, you execute ant debug (or release) from the project root directory.\n\nThat’s it! In the right situations, dynamic class loading can be quite useful.\n","slug":"2013-08-01-dynamic_load","published":1,"updated":"2018-02-14T21:36:14.838Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlv0018rpfy95qkya5j","content":"<p><a href=\"http://android-developers.blogspot.com/2011/07/custom-class-loading-in-dalvik.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>Dalvik虚拟机为开发者执行自定类加载提供了便利。除了从本地加载Dalvik可执行文件(“dex”),应用程序可以从备选地点如内部存储或者网络上加载它们。</p>\n<p>这种技术不是适用每个应用程序的，事实上，大部分没有使用这种技术的也工作的很好。然而，有些情况下自定义类加载会得心应手。这里有一对情景：</p>\n<p>巨大的应用程序包含超过64k个方法引用，超出了在一个dex文件里支持的最大值。为了绕过这个限制，开发者可以将这个程序分成多个二级dex文件，然后在运行时加载它们。</p>\n<p>开发者可以将它们的框架设计成执行逻辑具有很好的可扩展性，然后通过在运行时动态加载代码。</p>\n<p>我们已经创建了一个<a href=\"https://code.google.com/p/android-custom-class-loading-sample/\" target=\"_blank\" rel=\"noopener\">应用</a>来演示分割的dex文件和运行时类加载。（请注意，在下面讨论的原因，应用不能用ADT Eclipse plug-in 构建，而使用包含其中的Ant构建脚本,详细查看Readme.txt）</p>\n<p>App有一个简单的Activity来调用一个类库组件以显示一个Toast.Activity和它的资源包含在默认的dex中，而类库代码是被存储在二级dex中并绑定在APK。这需要一个修改的构建过程，也就是接下来将详细展示的。</p>\n<p>在类方法可以被调用前，App首先必须明确地加载二级dex文件。让我们看看这些相关的moving parts</p>\n<h2 id=\"代码组织\"><a href=\"#代码组织\" class=\"headerlink\" title=\"##代码组织\"></a>##代码组织</h2><p>应用包含3个类</p>\n<p>com.example.dex.MainActivity: UI component from which the library is invoked</p>\n<p>com.example.dex.LibraryInterface: Interface definition for the library</p>\n<p>com.example.dex.lib.LibraryProvider: Implementation of the library</p>\n<p>类库被打包在一个二级dex中，而其余类包含在默认（主要的）dex文件中，“Build Process”章节说明了如何完成它。当然，打包策略依赖于特殊场景–开发者正要处理的问题。</p>\n<h2 id=\"类加载和方法调用\"><a href=\"#类加载和方法调用\" class=\"headerlink\" title=\"##类加载和方法调用\"></a>##类加载和方法调用</h2><p>二级dex文件–含有LibraryProvider,存储为App的asset。首先，它必须拷贝到一个路径能被类加载器访问到的存储位置。示例App使用了App的私有内部存储空间做到了这点。（从技术上来说，外部存储也可以，但要考虑到将App二进制文件保存在那里的安全性问题）</p>\n<p>下面片段来自MainActivity–使用标准文件I/O完成拷贝工作</p>\n<pre><code>// Before the secondary dex file can be processed by the DexClassLoader,\n  // it has to be first copied from asset resource to a storage location.\n  File dexInternalStoragePath = new File(getDir(&quot;dex&quot;, Context.MODE_PRIVATE),\n      SECONDARY_DEX_NAME);\n  ...\n  BufferedInputStream bis = null;\n  OutputStream dexWriter = null；\n  static final int BUF_SIZE = 8 * 1024;\n  try {\n  bis = new BufferedInputStream(getAssets().open(SECONDARY_DEX_NAME));\n  dexWriter = new BufferedOutputStream(\n      new FileOutputStream(dexInternalStoragePath));\n  byte[] buf = new byte[BUF_SIZE];\n  int len;\n  while((len = bis.read(buf, 0, BUF_SIZE)) &gt; 0) {\n      dexWriter.write(buf, 0, len);\n  }\n  dexWriter.close();\n  bis.close();\n  } catch (. . .) {...}\n</code></pre><p>接着，DexClassLoader被实例化去加载来自提取出来的二级dex文件的类库。有两种方式去调用加载了的类方法以这种方式。在示例中，类实例转换成接口，然后直接调用方法。</p>\n<p>另一个途径是使用反射API调用方法。使用反射的优点是它不要求二级dex文件去实现任何特殊的接口，然而你应该察觉到反射很啰嗦而且慢。</p>\n<pre><code>// Internal storage where the DexClassLoader writes the optimized dex file to\nfinal File optimizedDexOutputPath = getDir(&quot;outdex&quot;, Context.MODE_PRIVATE);\n\nDexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(),\n                                   optimizedDexOutputPath.getAbsolutePath(),\n                                   null,\n                                   getClassLoader());\nClass libProviderClazz = null;\ntry {\n    // Load the library.\n    libProviderClazz =\n    cl.loadClass(&quot;com.example.dex.lib.LibraryProvider&quot;);\n    // Cast the return object to the library interface so that the\n    // caller can directly invoke methods in the interface.\n    // Alternatively, the caller can invoke methods through reflection,\n    // which is more verbose.\n    LibraryInterface lib = (LibraryInterface) libProviderClazz.newInstance();\n    lib.showAwesomeToast(this, &quot;hello&quot;);\n} catch (Exception e) { ... }\n</code></pre><h2 id=\"构建过程\"><a href=\"#构建过程\" class=\"headerlink\" title=\"##构建过程\"></a>##构建过程</h2><p>为了churn out 两个分开的dex文件，我们需要tweak标准的构建过程。完成这个戏法，我们只要简单地修改”-dex”目标，在项目的Ant build.xml中。</p>\n<p>修改了的”-dex”目标执行以下操作：</p>\n<p>创建两个临时目录去存储.class文件，用来被转换为默认的dex和二级dex。</p>\n<p>有选择性的从Project_Root/bin/classes拷贝.class文件到这两个临时目录。</p>\n<pre><code>&lt;!-- Primary dex to include everything but the concrete library\n           implementation. --&gt;\n      &lt;copy todir=&quot;${out.classes.absolute.dir}.1&quot; &gt;\n          &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt;\n                  &lt;exclude name=&quot;com/example/dex/lib/**&quot; /&gt;\n          &lt;/fileset&gt;\n      &lt;/copy&gt;\n      &lt;!-- Secondary dex to include the concrete library implementation. --&gt;\n      &lt;copy todir=&quot;${out.classes.absolute.dir}.2&quot; &gt;\n          &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt;\n                  &lt;include name=&quot;com/example/dex/lib/**&quot; /&gt;\n          &lt;/fileset&gt;\n      &lt;/copy&gt;     \n</code></pre><p>将两个临时目录的.class文件转换成两个分开的dex文件</p>\n<p>添加二级dex文件到一个jar文件–DexClassLoader的预期输入格式。最后，存储jar文件到项目的assets目录下。</p>\n<pre><code>&lt;!-- Package the output in the assets directory of the apk. --&gt;\n        &lt;jar destfile=&quot;${asset.absolute.dir}/secondary_dex.jar&quot;\n               basedir=&quot;${out.absolute.dir}/secondary_dex_dir&quot;\n               includes=&quot;classes.dex&quot; /&gt;\n</code></pre><p>To kick-off the build, you execute ant debug (or release) from the project root directory.</p>\n<p>That’s it! In the right situations, dynamic class loading can be quite useful.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://android-developers.blogspot.com/2011/07/custom-class-loading-in-dalvik.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>Dalvik虚拟机为开发者执行自定类加载提供了便利。除了从本地加载Dalvik可执行文件(“dex”),应用程序可以从备选地点如内部存储或者网络上加载它们。</p>\n<p>这种技术不是适用每个应用程序的，事实上，大部分没有使用这种技术的也工作的很好。然而，有些情况下自定义类加载会得心应手。这里有一对情景：</p>\n<p>巨大的应用程序包含超过64k个方法引用，超出了在一个dex文件里支持的最大值。为了绕过这个限制，开发者可以将这个程序分成多个二级dex文件，然后在运行时加载它们。</p>\n<p>开发者可以将它们的框架设计成执行逻辑具有很好的可扩展性，然后通过在运行时动态加载代码。</p>\n<p>我们已经创建了一个<a href=\"https://code.google.com/p/android-custom-class-loading-sample/\" target=\"_blank\" rel=\"noopener\">应用</a>来演示分割的dex文件和运行时类加载。（请注意，在下面讨论的原因，应用不能用ADT Eclipse plug-in 构建，而使用包含其中的Ant构建脚本,详细查看Readme.txt）</p>\n<p>App有一个简单的Activity来调用一个类库组件以显示一个Toast.Activity和它的资源包含在默认的dex中，而类库代码是被存储在二级dex中并绑定在APK。这需要一个修改的构建过程，也就是接下来将详细展示的。</p>\n<p>在类方法可以被调用前，App首先必须明确地加载二级dex文件。让我们看看这些相关的moving parts</p>\n<h2 id=\"代码组织\"><a href=\"#代码组织\" class=\"headerlink\" title=\"##代码组织\"></a>##代码组织</h2><p>应用包含3个类</p>\n<p>com.example.dex.MainActivity: UI component from which the library is invoked</p>\n<p>com.example.dex.LibraryInterface: Interface definition for the library</p>\n<p>com.example.dex.lib.LibraryProvider: Implementation of the library</p>\n<p>类库被打包在一个二级dex中，而其余类包含在默认（主要的）dex文件中，“Build Process”章节说明了如何完成它。当然，打包策略依赖于特殊场景–开发者正要处理的问题。</p>\n<h2 id=\"类加载和方法调用\"><a href=\"#类加载和方法调用\" class=\"headerlink\" title=\"##类加载和方法调用\"></a>##类加载和方法调用</h2><p>二级dex文件–含有LibraryProvider,存储为App的asset。首先，它必须拷贝到一个路径能被类加载器访问到的存储位置。示例App使用了App的私有内部存储空间做到了这点。（从技术上来说，外部存储也可以，但要考虑到将App二进制文件保存在那里的安全性问题）</p>\n<p>下面片段来自MainActivity–使用标准文件I/O完成拷贝工作</p>\n<pre><code>// Before the secondary dex file can be processed by the DexClassLoader,\n  // it has to be first copied from asset resource to a storage location.\n  File dexInternalStoragePath = new File(getDir(&quot;dex&quot;, Context.MODE_PRIVATE),\n      SECONDARY_DEX_NAME);\n  ...\n  BufferedInputStream bis = null;\n  OutputStream dexWriter = null；\n  static final int BUF_SIZE = 8 * 1024;\n  try {\n  bis = new BufferedInputStream(getAssets().open(SECONDARY_DEX_NAME));\n  dexWriter = new BufferedOutputStream(\n      new FileOutputStream(dexInternalStoragePath));\n  byte[] buf = new byte[BUF_SIZE];\n  int len;\n  while((len = bis.read(buf, 0, BUF_SIZE)) &gt; 0) {\n      dexWriter.write(buf, 0, len);\n  }\n  dexWriter.close();\n  bis.close();\n  } catch (. . .) {...}\n</code></pre><p>接着，DexClassLoader被实例化去加载来自提取出来的二级dex文件的类库。有两种方式去调用加载了的类方法以这种方式。在示例中，类实例转换成接口，然后直接调用方法。</p>\n<p>另一个途径是使用反射API调用方法。使用反射的优点是它不要求二级dex文件去实现任何特殊的接口，然而你应该察觉到反射很啰嗦而且慢。</p>\n<pre><code>// Internal storage where the DexClassLoader writes the optimized dex file to\nfinal File optimizedDexOutputPath = getDir(&quot;outdex&quot;, Context.MODE_PRIVATE);\n\nDexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(),\n                                   optimizedDexOutputPath.getAbsolutePath(),\n                                   null,\n                                   getClassLoader());\nClass libProviderClazz = null;\ntry {\n    // Load the library.\n    libProviderClazz =\n    cl.loadClass(&quot;com.example.dex.lib.LibraryProvider&quot;);\n    // Cast the return object to the library interface so that the\n    // caller can directly invoke methods in the interface.\n    // Alternatively, the caller can invoke methods through reflection,\n    // which is more verbose.\n    LibraryInterface lib = (LibraryInterface) libProviderClazz.newInstance();\n    lib.showAwesomeToast(this, &quot;hello&quot;);\n} catch (Exception e) { ... }\n</code></pre><h2 id=\"构建过程\"><a href=\"#构建过程\" class=\"headerlink\" title=\"##构建过程\"></a>##构建过程</h2><p>为了churn out 两个分开的dex文件，我们需要tweak标准的构建过程。完成这个戏法，我们只要简单地修改”-dex”目标，在项目的Ant build.xml中。</p>\n<p>修改了的”-dex”目标执行以下操作：</p>\n<p>创建两个临时目录去存储.class文件，用来被转换为默认的dex和二级dex。</p>\n<p>有选择性的从Project_Root/bin/classes拷贝.class文件到这两个临时目录。</p>\n<pre><code>&lt;!-- Primary dex to include everything but the concrete library\n           implementation. --&gt;\n      &lt;copy todir=&quot;${out.classes.absolute.dir}.1&quot; &gt;\n          &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt;\n                  &lt;exclude name=&quot;com/example/dex/lib/**&quot; /&gt;\n          &lt;/fileset&gt;\n      &lt;/copy&gt;\n      &lt;!-- Secondary dex to include the concrete library implementation. --&gt;\n      &lt;copy todir=&quot;${out.classes.absolute.dir}.2&quot; &gt;\n          &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt;\n                  &lt;include name=&quot;com/example/dex/lib/**&quot; /&gt;\n          &lt;/fileset&gt;\n      &lt;/copy&gt;     \n</code></pre><p>将两个临时目录的.class文件转换成两个分开的dex文件</p>\n<p>添加二级dex文件到一个jar文件–DexClassLoader的预期输入格式。最后，存储jar文件到项目的assets目录下。</p>\n<pre><code>&lt;!-- Package the output in the assets directory of the apk. --&gt;\n        &lt;jar destfile=&quot;${asset.absolute.dir}/secondary_dex.jar&quot;\n               basedir=&quot;${out.absolute.dir}/secondary_dex_dir&quot;\n               includes=&quot;classes.dex&quot; /&gt;\n</code></pre><p>To kick-off the build, you execute ant debug (or release) from the project root directory.</p>\n<p>That’s it! In the right situations, dynamic class loading can be quite useful.</p>\n"},{"date":"2013-10-29T16:00:00.000Z","layout":"post","title":"Android中显示动画的GIF-Movie类解决方案","_content":"\n首先看看GIF文件的存储结构和动画原理-->[[转]GIF图片的文件储存结构和动画原理](http://blog.sina.com.cn/s/blog_571296860100jvhz.html)\n\n以及已知的两种解决方案-->[Android & how to use animated GIF](http://weavora.com/blog/2012/02/07/android-how-to-use-animated-gif/)\n\nGithub上还算可以的开源项目-->[gif-movie-view](https://github.com/sbakhtiarov/gif-movie-view)\n\n但实际使用的时候,还是有些小问题,比如\n\n我们的GIF不全是本地已经存在的,可能是从文件加载,或者是网络下载的,这时候在使用Movie.decodeStream(InputStream is)时会遇到\n\n- [IOException on Movie.decodeFile() - android](http://stackoverflow.com/questions/18307266/ioexception-on-movie-decodefile-android)\n- [IOException - Cannot load file](http://stackoverflow.com/questions/10240042/ioexception-cannot-load-file)\n\n我的做法是统一使用Movie.decodeByteArray(byte[] b) 类方法,可以避免很多麻烦,下载 [***gif-movie-view***](https://github.com/sbakhtiarov/gif-movie-view)\n 项目,并在GifMovieView中添加\n\n```\n  public void setMovieByteArray(byte[] bb) {\n        mMovie = Movie.decodeByteArray(bb, 0, bb.length);\n        requestLayout();\n    }\n```\n\n假如我们显示GIF的时候是异步的,那么在还没有显示时,GifMovieView不占据任何空间,完成加载后整个界面会重绘,因为GifMovieView重载的onMeasure()函数是这样子的:\n\n```\n  @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        if (mMovie != null) {\n            int movieWidth = mMovie.width();\n            int movieHeight = mMovie.height();\n\t\t\t/*\n             * Calculate horizontal scaling\n\t\t\t */\n\n            float scaleH = 1f;\n            int measureModeWidth = MeasureSpec.getMode(widthMeasureSpec);\n            if (measureModeWidth != MeasureSpec.UNSPECIFIED) {\n                int maximumWidth = MeasureSpec.getSize(widthMeasureSpec);\n                if (movieWidth > maximumWidth) {\n                    scaleH = (float) movieWidth / (float) maximumWidth;\n                }\n            }\n\t\t\t/*\n             * calculate vertical scaling\n\t\t\t */\n\n            float scaleW = 1f;\n            int measureModeHeight = MeasureSpec.getMode(heightMeasureSpec);\n\n            if (measureModeHeight != MeasureSpec.UNSPECIFIED) {\n                int maximumHeight = MeasureSpec.getSize(heightMeasureSpec);\n                if (movieHeight > maximumHeight) {\n                    scaleW = (float) movieHeight / (float) maximumHeight;\n                }\n            }\n\n\t\t\t/*\n             * calculate overall scale\n\t\t\t */\n            mScale = 1f / Math.max(scaleH, scaleW);\n\n            mMeasuredMovieWidth = (int) (movieWidth * mScale);\n            mMeasuredMovieHeight = (int) (movieHeight * mScale);\n\n            setMeasuredDimension(mMeasuredMovieWidth, mMeasuredMovieHeight);\n\n        } else {\n            /*\n             * No movie set, just set minimum available size.\n\t\t\t */\n\t\t\tsetMeasuredDimension(getSuggestedMinimumWidth(), getSuggestedMinimumHeight());\n        }\n    }\n```\n\n我们知道setMeasuredDimension(int width,int height);将指定View在父容器里占据的width,和height,假如你们的业务逻辑在得到GIF文件的URL同时,还能获得它的width和height,并且这里你不希望调用requestLayout()函数重绘,做了如下修改\n\n```\nsetMeasuredDimension(mWidth,mHeight);  //mWidth, mHeight 是已知Gif的宽高\n```\n\n这个时候可能连显示也不正常了! 可能是因为父容器判断GifMovieView大小并没有发生改变,这样的话就不调用onLayout() 和 onDraw() 函数,也就没有开始GIF的动画循环,所以就是一片空白. 有待考证.\n\n另外还有些注意点 比如API 11 之后不能使用硬件渲染:\n\n```\n  /**\n\t* Starting from HONEYCOMB have to turn off HW acceleration to draw\n\t* Movie on Canvas.\n    */\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n    \tsetLayerType(View.LAYER_TYPE_SOFTWARE, null);\n    }\n```\n\n###总结:\nMovie的坑还是很多的,不像成品类库,相对于WebView来显示GIF的优势是轻量级,更易管理.\n","source":"_posts/2013-10-30-display-gif.md","raw":"---\ncategory: Android\ndate: 2013-10-30\nlayout: post\ntitle:  Android中显示动画的GIF-Movie类解决方案\n---\n\n首先看看GIF文件的存储结构和动画原理-->[[转]GIF图片的文件储存结构和动画原理](http://blog.sina.com.cn/s/blog_571296860100jvhz.html)\n\n以及已知的两种解决方案-->[Android & how to use animated GIF](http://weavora.com/blog/2012/02/07/android-how-to-use-animated-gif/)\n\nGithub上还算可以的开源项目-->[gif-movie-view](https://github.com/sbakhtiarov/gif-movie-view)\n\n但实际使用的时候,还是有些小问题,比如\n\n我们的GIF不全是本地已经存在的,可能是从文件加载,或者是网络下载的,这时候在使用Movie.decodeStream(InputStream is)时会遇到\n\n- [IOException on Movie.decodeFile() - android](http://stackoverflow.com/questions/18307266/ioexception-on-movie-decodefile-android)\n- [IOException - Cannot load file](http://stackoverflow.com/questions/10240042/ioexception-cannot-load-file)\n\n我的做法是统一使用Movie.decodeByteArray(byte[] b) 类方法,可以避免很多麻烦,下载 [***gif-movie-view***](https://github.com/sbakhtiarov/gif-movie-view)\n 项目,并在GifMovieView中添加\n\n```\n  public void setMovieByteArray(byte[] bb) {\n        mMovie = Movie.decodeByteArray(bb, 0, bb.length);\n        requestLayout();\n    }\n```\n\n假如我们显示GIF的时候是异步的,那么在还没有显示时,GifMovieView不占据任何空间,完成加载后整个界面会重绘,因为GifMovieView重载的onMeasure()函数是这样子的:\n\n```\n  @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        if (mMovie != null) {\n            int movieWidth = mMovie.width();\n            int movieHeight = mMovie.height();\n\t\t\t/*\n             * Calculate horizontal scaling\n\t\t\t */\n\n            float scaleH = 1f;\n            int measureModeWidth = MeasureSpec.getMode(widthMeasureSpec);\n            if (measureModeWidth != MeasureSpec.UNSPECIFIED) {\n                int maximumWidth = MeasureSpec.getSize(widthMeasureSpec);\n                if (movieWidth > maximumWidth) {\n                    scaleH = (float) movieWidth / (float) maximumWidth;\n                }\n            }\n\t\t\t/*\n             * calculate vertical scaling\n\t\t\t */\n\n            float scaleW = 1f;\n            int measureModeHeight = MeasureSpec.getMode(heightMeasureSpec);\n\n            if (measureModeHeight != MeasureSpec.UNSPECIFIED) {\n                int maximumHeight = MeasureSpec.getSize(heightMeasureSpec);\n                if (movieHeight > maximumHeight) {\n                    scaleW = (float) movieHeight / (float) maximumHeight;\n                }\n            }\n\n\t\t\t/*\n             * calculate overall scale\n\t\t\t */\n            mScale = 1f / Math.max(scaleH, scaleW);\n\n            mMeasuredMovieWidth = (int) (movieWidth * mScale);\n            mMeasuredMovieHeight = (int) (movieHeight * mScale);\n\n            setMeasuredDimension(mMeasuredMovieWidth, mMeasuredMovieHeight);\n\n        } else {\n            /*\n             * No movie set, just set minimum available size.\n\t\t\t */\n\t\t\tsetMeasuredDimension(getSuggestedMinimumWidth(), getSuggestedMinimumHeight());\n        }\n    }\n```\n\n我们知道setMeasuredDimension(int width,int height);将指定View在父容器里占据的width,和height,假如你们的业务逻辑在得到GIF文件的URL同时,还能获得它的width和height,并且这里你不希望调用requestLayout()函数重绘,做了如下修改\n\n```\nsetMeasuredDimension(mWidth,mHeight);  //mWidth, mHeight 是已知Gif的宽高\n```\n\n这个时候可能连显示也不正常了! 可能是因为父容器判断GifMovieView大小并没有发生改变,这样的话就不调用onLayout() 和 onDraw() 函数,也就没有开始GIF的动画循环,所以就是一片空白. 有待考证.\n\n另外还有些注意点 比如API 11 之后不能使用硬件渲染:\n\n```\n  /**\n\t* Starting from HONEYCOMB have to turn off HW acceleration to draw\n\t* Movie on Canvas.\n    */\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n    \tsetLayerType(View.LAYER_TYPE_SOFTWARE, null);\n    }\n```\n\n###总结:\nMovie的坑还是很多的,不像成品类库,相对于WebView来显示GIF的优势是轻量级,更易管理.\n","slug":"2013-10-30-display-gif","published":1,"updated":"2018-02-14T21:36:14.838Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlw001arpfydgcguply","content":"<p>首先看看GIF文件的存储结构和动画原理–&gt;<a href=\"http://blog.sina.com.cn/s/blog_571296860100jvhz.html\" target=\"_blank\" rel=\"noopener\">[转]GIF图片的文件储存结构和动画原理</a></p>\n<p>以及已知的两种解决方案–&gt;<a href=\"http://weavora.com/blog/2012/02/07/android-how-to-use-animated-gif/\" target=\"_blank\" rel=\"noopener\">Android &amp; how to use animated GIF</a></p>\n<p>Github上还算可以的开源项目–&gt;<a href=\"https://github.com/sbakhtiarov/gif-movie-view\" target=\"_blank\" rel=\"noopener\">gif-movie-view</a></p>\n<p>但实际使用的时候,还是有些小问题,比如</p>\n<p>我们的GIF不全是本地已经存在的,可能是从文件加载,或者是网络下载的,这时候在使用Movie.decodeStream(InputStream is)时会遇到</p>\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/18307266/ioexception-on-movie-decodefile-android\" target=\"_blank\" rel=\"noopener\">IOException on Movie.decodeFile() - android</a></li>\n<li><a href=\"http://stackoverflow.com/questions/10240042/ioexception-cannot-load-file\" target=\"_blank\" rel=\"noopener\">IOException - Cannot load file</a></li>\n</ul>\n<p>我的做法是统一使用Movie.decodeByteArray(byte[] b) 类方法,可以避免很多麻烦,下载 <a href=\"https://github.com/sbakhtiarov/gif-movie-view\" target=\"_blank\" rel=\"noopener\"><strong><em>gif-movie-view</em></strong></a><br> 项目,并在GifMovieView中添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void setMovieByteArray(byte[] bb) &#123;</span><br><span class=\"line\">      mMovie = Movie.decodeByteArray(bb, 0, bb.length);</span><br><span class=\"line\">      requestLayout();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>假如我们显示GIF的时候是异步的,那么在还没有显示时,GifMovieView不占据任何空间,完成加载后整个界面会重绘,因为GifMovieView重载的onMeasure()函数是这样子的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">      if (mMovie != null) &#123;</span><br><span class=\"line\">          int movieWidth = mMovie.width();</span><br><span class=\"line\">          int movieHeight = mMovie.height();</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">           * Calculate horizontal scaling</span><br><span class=\"line\">\t */</span><br><span class=\"line\"></span><br><span class=\"line\">          float scaleH = 1f;</span><br><span class=\"line\">          int measureModeWidth = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class=\"line\">          if (measureModeWidth != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class=\"line\">              int maximumWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">              if (movieWidth &gt; maximumWidth) &#123;</span><br><span class=\"line\">                  scaleH = (float) movieWidth / (float) maximumWidth;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">           * calculate vertical scaling</span><br><span class=\"line\">\t */</span><br><span class=\"line\"></span><br><span class=\"line\">          float scaleW = 1f;</span><br><span class=\"line\">          int measureModeHeight = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">          if (measureModeHeight != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class=\"line\">              int maximumHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class=\"line\">              if (movieHeight &gt; maximumHeight) &#123;</span><br><span class=\"line\">                  scaleW = (float) movieHeight / (float) maximumHeight;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">           * calculate overall scale</span><br><span class=\"line\">\t */</span><br><span class=\"line\">          mScale = 1f / Math.max(scaleH, scaleW);</span><br><span class=\"line\"></span><br><span class=\"line\">          mMeasuredMovieWidth = (int) (movieWidth * mScale);</span><br><span class=\"line\">          mMeasuredMovieHeight = (int) (movieHeight * mScale);</span><br><span class=\"line\"></span><br><span class=\"line\">          setMeasuredDimension(mMeasuredMovieWidth, mMeasuredMovieHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">          /*</span><br><span class=\"line\">           * No movie set, just set minimum available size.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tsetMeasuredDimension(getSuggestedMinimumWidth(), getSuggestedMinimumHeight());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>我们知道setMeasuredDimension(int width,int height);将指定View在父容器里占据的width,和height,假如你们的业务逻辑在得到GIF文件的URL同时,还能获得它的width和height,并且这里你不希望调用requestLayout()函数重绘,做了如下修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setMeasuredDimension(mWidth,mHeight);  //mWidth, mHeight 是已知Gif的宽高</span><br></pre></td></tr></table></figure>\n<p>这个时候可能连显示也不正常了! 可能是因为父容器判断GifMovieView大小并没有发生改变,这样的话就不调用onLayout() 和 onDraw() 函数,也就没有开始GIF的动画循环,所以就是一片空白. 有待考证.</p>\n<p>另外还有些注意点 比如API 11 之后不能使用硬件渲染:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> /**</span><br><span class=\"line\">* Starting from HONEYCOMB have to turn off HW acceleration to draw</span><br><span class=\"line\">* Movie on Canvas.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">   \tsetLayerType(View.LAYER_TYPE_SOFTWARE, null);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>###总结:<br>Movie的坑还是很多的,不像成品类库,相对于WebView来显示GIF的优势是轻量级,更易管理.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先看看GIF文件的存储结构和动画原理–&gt;<a href=\"http://blog.sina.com.cn/s/blog_571296860100jvhz.html\" target=\"_blank\" rel=\"noopener\">[转]GIF图片的文件储存结构和动画原理</a></p>\n<p>以及已知的两种解决方案–&gt;<a href=\"http://weavora.com/blog/2012/02/07/android-how-to-use-animated-gif/\" target=\"_blank\" rel=\"noopener\">Android &amp; how to use animated GIF</a></p>\n<p>Github上还算可以的开源项目–&gt;<a href=\"https://github.com/sbakhtiarov/gif-movie-view\" target=\"_blank\" rel=\"noopener\">gif-movie-view</a></p>\n<p>但实际使用的时候,还是有些小问题,比如</p>\n<p>我们的GIF不全是本地已经存在的,可能是从文件加载,或者是网络下载的,这时候在使用Movie.decodeStream(InputStream is)时会遇到</p>\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/18307266/ioexception-on-movie-decodefile-android\" target=\"_blank\" rel=\"noopener\">IOException on Movie.decodeFile() - android</a></li>\n<li><a href=\"http://stackoverflow.com/questions/10240042/ioexception-cannot-load-file\" target=\"_blank\" rel=\"noopener\">IOException - Cannot load file</a></li>\n</ul>\n<p>我的做法是统一使用Movie.decodeByteArray(byte[] b) 类方法,可以避免很多麻烦,下载 <a href=\"https://github.com/sbakhtiarov/gif-movie-view\" target=\"_blank\" rel=\"noopener\"><strong><em>gif-movie-view</em></strong></a><br> 项目,并在GifMovieView中添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void setMovieByteArray(byte[] bb) &#123;</span><br><span class=\"line\">      mMovie = Movie.decodeByteArray(bb, 0, bb.length);</span><br><span class=\"line\">      requestLayout();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>假如我们显示GIF的时候是异步的,那么在还没有显示时,GifMovieView不占据任何空间,完成加载后整个界面会重绘,因为GifMovieView重载的onMeasure()函数是这样子的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">      if (mMovie != null) &#123;</span><br><span class=\"line\">          int movieWidth = mMovie.width();</span><br><span class=\"line\">          int movieHeight = mMovie.height();</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">           * Calculate horizontal scaling</span><br><span class=\"line\">\t */</span><br><span class=\"line\"></span><br><span class=\"line\">          float scaleH = 1f;</span><br><span class=\"line\">          int measureModeWidth = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class=\"line\">          if (measureModeWidth != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class=\"line\">              int maximumWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">              if (movieWidth &gt; maximumWidth) &#123;</span><br><span class=\"line\">                  scaleH = (float) movieWidth / (float) maximumWidth;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">           * calculate vertical scaling</span><br><span class=\"line\">\t */</span><br><span class=\"line\"></span><br><span class=\"line\">          float scaleW = 1f;</span><br><span class=\"line\">          int measureModeHeight = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">          if (measureModeHeight != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class=\"line\">              int maximumHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class=\"line\">              if (movieHeight &gt; maximumHeight) &#123;</span><br><span class=\"line\">                  scaleW = (float) movieHeight / (float) maximumHeight;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">           * calculate overall scale</span><br><span class=\"line\">\t */</span><br><span class=\"line\">          mScale = 1f / Math.max(scaleH, scaleW);</span><br><span class=\"line\"></span><br><span class=\"line\">          mMeasuredMovieWidth = (int) (movieWidth * mScale);</span><br><span class=\"line\">          mMeasuredMovieHeight = (int) (movieHeight * mScale);</span><br><span class=\"line\"></span><br><span class=\"line\">          setMeasuredDimension(mMeasuredMovieWidth, mMeasuredMovieHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">          /*</span><br><span class=\"line\">           * No movie set, just set minimum available size.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tsetMeasuredDimension(getSuggestedMinimumWidth(), getSuggestedMinimumHeight());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>我们知道setMeasuredDimension(int width,int height);将指定View在父容器里占据的width,和height,假如你们的业务逻辑在得到GIF文件的URL同时,还能获得它的width和height,并且这里你不希望调用requestLayout()函数重绘,做了如下修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setMeasuredDimension(mWidth,mHeight);  //mWidth, mHeight 是已知Gif的宽高</span><br></pre></td></tr></table></figure>\n<p>这个时候可能连显示也不正常了! 可能是因为父容器判断GifMovieView大小并没有发生改变,这样的话就不调用onLayout() 和 onDraw() 函数,也就没有开始GIF的动画循环,所以就是一片空白. 有待考证.</p>\n<p>另外还有些注意点 比如API 11 之后不能使用硬件渲染:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> /**</span><br><span class=\"line\">* Starting from HONEYCOMB have to turn off HW acceleration to draw</span><br><span class=\"line\">* Movie on Canvas.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">   \tsetLayerType(View.LAYER_TYPE_SOFTWARE, null);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>###总结:<br>Movie的坑还是很多的,不像成品类库,相对于WebView来显示GIF的优势是轻量级,更易管理.</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-02-14T20:49:39.472Z","updated":"2018-02-14T20:49:39.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdnn3tlx001crpfy8bsjwjwi","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"date":"2013-11-27T16:00:00.000Z","layout":"post","title":"Android Picasso-强大的图片下载缓存类库","_content":"\n\n[Jake Wharton](https://github.com/JakeWharton)大牛写的又一力作,链式API的优雅,类库的简洁,谁用谁喜欢.\n\nGitHub 项目地址->[https://github.com/square/picasso](https://github.com/square/picasso)\n\n###简介\n\n在你的Android应用程序如果想要显示大量图片,而且视觉效果丰富,高效稳定,需要大量的基础工作.Picasso可以帮你完成这些工作,通常只需要一行代码!\n\n```\nPicasso.with(context).load(\"http://i.imgur.com/DvpvklR.png\").into(imageView);\n```\n\nMany common pitfalls of image loading on Android are handled automatically by Picasso:\n\nHandling ImageView recycling and download cancelation in an adapter.\nComplex image transformations with minimal memory use.\nAutomatic memory and disk caching.\n\n在Android中很多图片加载时的陷阱都由Picaaso帮你自动处理:\n- 在Adapter中处理ImageView的回收和下载取消\n- 使用最小的内存完成复杂的图像变化\n- 自动完成内存和磁盘缓存\n\n###特性\n####Adapter\n\nAdapter中完成下载显示,并自动取消上一个下载请求\n\n```\n@Override public void getView(int position, View convertView, ViewGroup parent) {\n  SquaredImageView view = (SquaredImageView) convertView;\n  if (view == null) {\n    view = new SquaredImageView(context);\n  }\n  String url = getItem(position);\n\n  Picasso.with(context).load(url).into(view);\n}\n```\n\n####图像转换\n\n转换图片以更适应放入布局中,有效减少内存\n\n```\nPicasso.with(context)\n  .load(url)\n  .resize(50, 50)\n  .centerCrop()\n  .into(imageView)\n```\n\n你也可以手工处理,以实现更高级的效果\n\n```\npublic class CropSquareTransformation implements Transformation {\n  @Override public Bitmap transform(Bitmap source) {\n    int size = Math.min(source.getWidth(), source.getHeight());\n    int x = (source.getWidth() - size) / 2;\n    int y = (source.getHeight() - size) / 2;\n    Bitmap result = Bitmap.createBitmap(source, x, y, size, size);\n    if (result != source) {\n      source.recycle();\n    }\n    return result;\n  }\n\n  @Override public String key() { return \"square()\"; }\n}\n```\n\n####预留图片\n\n下载图片完成前或错误时,Picasso提供一个预留图片(placeholer)API,加载默认图片.\n\n####加载资源\n\nResources, assets, files, content providers,在Picasso中都是支持加载的.\n\n```\nPicasso.with(context).load(R.drawable.landing_screen).into(imageView1);\nPicasso.with(context).load(new File(\"/images/oprah_bees.gif\")).into(imageView2);\n```\n\n####当然也有缺点\n\n1. 我们会发现,当我们想要获取缓存Bitmap的文件时,Picasso并没有这样的API,你只有在子线程中获取bitmap后,在存储一次.原因与HttpResponseCache类有关.\n\n2. 还没有对GIF做支持,我尝试过去支持,但是发现改动实在太大,遂放弃.老老实实用原来的.\n\n3. 超长图,还是用WebView解决吧,Picasso也做不到\n\n####谁在用?\n\n豆瓣,蘑菇街,花瓣\n","source":"_posts/2013-11-28-picasso.md","raw":"---\ncategory: Android\ndate: 2013-11-28\nlayout: post\ntitle:  Android Picasso-强大的图片下载缓存类库\n---\n\n\n[Jake Wharton](https://github.com/JakeWharton)大牛写的又一力作,链式API的优雅,类库的简洁,谁用谁喜欢.\n\nGitHub 项目地址->[https://github.com/square/picasso](https://github.com/square/picasso)\n\n###简介\n\n在你的Android应用程序如果想要显示大量图片,而且视觉效果丰富,高效稳定,需要大量的基础工作.Picasso可以帮你完成这些工作,通常只需要一行代码!\n\n```\nPicasso.with(context).load(\"http://i.imgur.com/DvpvklR.png\").into(imageView);\n```\n\nMany common pitfalls of image loading on Android are handled automatically by Picasso:\n\nHandling ImageView recycling and download cancelation in an adapter.\nComplex image transformations with minimal memory use.\nAutomatic memory and disk caching.\n\n在Android中很多图片加载时的陷阱都由Picaaso帮你自动处理:\n- 在Adapter中处理ImageView的回收和下载取消\n- 使用最小的内存完成复杂的图像变化\n- 自动完成内存和磁盘缓存\n\n###特性\n####Adapter\n\nAdapter中完成下载显示,并自动取消上一个下载请求\n\n```\n@Override public void getView(int position, View convertView, ViewGroup parent) {\n  SquaredImageView view = (SquaredImageView) convertView;\n  if (view == null) {\n    view = new SquaredImageView(context);\n  }\n  String url = getItem(position);\n\n  Picasso.with(context).load(url).into(view);\n}\n```\n\n####图像转换\n\n转换图片以更适应放入布局中,有效减少内存\n\n```\nPicasso.with(context)\n  .load(url)\n  .resize(50, 50)\n  .centerCrop()\n  .into(imageView)\n```\n\n你也可以手工处理,以实现更高级的效果\n\n```\npublic class CropSquareTransformation implements Transformation {\n  @Override public Bitmap transform(Bitmap source) {\n    int size = Math.min(source.getWidth(), source.getHeight());\n    int x = (source.getWidth() - size) / 2;\n    int y = (source.getHeight() - size) / 2;\n    Bitmap result = Bitmap.createBitmap(source, x, y, size, size);\n    if (result != source) {\n      source.recycle();\n    }\n    return result;\n  }\n\n  @Override public String key() { return \"square()\"; }\n}\n```\n\n####预留图片\n\n下载图片完成前或错误时,Picasso提供一个预留图片(placeholer)API,加载默认图片.\n\n####加载资源\n\nResources, assets, files, content providers,在Picasso中都是支持加载的.\n\n```\nPicasso.with(context).load(R.drawable.landing_screen).into(imageView1);\nPicasso.with(context).load(new File(\"/images/oprah_bees.gif\")).into(imageView2);\n```\n\n####当然也有缺点\n\n1. 我们会发现,当我们想要获取缓存Bitmap的文件时,Picasso并没有这样的API,你只有在子线程中获取bitmap后,在存储一次.原因与HttpResponseCache类有关.\n\n2. 还没有对GIF做支持,我尝试过去支持,但是发现改动实在太大,遂放弃.老老实实用原来的.\n\n3. 超长图,还是用WebView解决吧,Picasso也做不到\n\n####谁在用?\n\n豆瓣,蘑菇街,花瓣\n","slug":"2013-11-28-picasso","published":1,"updated":"2018-02-14T21:36:14.838Z","comments":1,"photos":[],"link":"","_id":"cjdnn3tlz001erpfyf8bssej8","content":"<p><a href=\"https://github.com/JakeWharton\" target=\"_blank\" rel=\"noopener\">Jake Wharton</a>大牛写的又一力作,链式API的优雅,类库的简洁,谁用谁喜欢.</p>\n<p>GitHub 项目地址-&gt;<a href=\"https://github.com/square/picasso\" target=\"_blank\" rel=\"noopener\">https://github.com/square/picasso</a></p>\n<p>###简介</p>\n<p>在你的Android应用程序如果想要显示大量图片,而且视觉效果丰富,高效稳定,需要大量的基础工作.Picasso可以帮你完成这些工作,通常只需要一行代码!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.with(context).load(&quot;http://i.imgur.com/DvpvklR.png&quot;).into(imageView);</span><br></pre></td></tr></table></figure>\n<p>Many common pitfalls of image loading on Android are handled automatically by Picasso:</p>\n<p>Handling ImageView recycling and download cancelation in an adapter.<br>Complex image transformations with minimal memory use.<br>Automatic memory and disk caching.</p>\n<p>在Android中很多图片加载时的陷阱都由Picaaso帮你自动处理:</p>\n<ul>\n<li>在Adapter中处理ImageView的回收和下载取消</li>\n<li>使用最小的内存完成复杂的图像变化</li>\n<li>自动完成内存和磁盘缓存</li>\n</ul>\n<p>###特性</p>\n<p>####Adapter</p>\n<p>Adapter中完成下载显示,并自动取消上一个下载请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public void getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class=\"line\">  SquaredImageView view = (SquaredImageView) convertView;</span><br><span class=\"line\">  if (view == null) &#123;</span><br><span class=\"line\">    view = new SquaredImageView(context);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  String url = getItem(position);</span><br><span class=\"line\"></span><br><span class=\"line\">  Picasso.with(context).load(url).into(view);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####图像转换</p>\n<p>转换图片以更适应放入布局中,有效减少内存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.with(context)</span><br><span class=\"line\">  .load(url)</span><br><span class=\"line\">  .resize(50, 50)</span><br><span class=\"line\">  .centerCrop()</span><br><span class=\"line\">  .into(imageView)</span><br></pre></td></tr></table></figure>\n<p>你也可以手工处理,以实现更高级的效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CropSquareTransformation implements Transformation &#123;</span><br><span class=\"line\">  @Override public Bitmap transform(Bitmap source) &#123;</span><br><span class=\"line\">    int size = Math.min(source.getWidth(), source.getHeight());</span><br><span class=\"line\">    int x = (source.getWidth() - size) / 2;</span><br><span class=\"line\">    int y = (source.getHeight() - size) / 2;</span><br><span class=\"line\">    Bitmap result = Bitmap.createBitmap(source, x, y, size, size);</span><br><span class=\"line\">    if (result != source) &#123;</span><br><span class=\"line\">      source.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override public String key() &#123; return &quot;square()&quot;; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####预留图片</p>\n<p>下载图片完成前或错误时,Picasso提供一个预留图片(placeholer)API,加载默认图片.</p>\n<p>####加载资源</p>\n<p>Resources, assets, files, content providers,在Picasso中都是支持加载的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.with(context).load(R.drawable.landing_screen).into(imageView1);</span><br><span class=\"line\">Picasso.with(context).load(new File(&quot;/images/oprah_bees.gif&quot;)).into(imageView2);</span><br></pre></td></tr></table></figure>\n<p>####当然也有缺点</p>\n<ol>\n<li><p>我们会发现,当我们想要获取缓存Bitmap的文件时,Picasso并没有这样的API,你只有在子线程中获取bitmap后,在存储一次.原因与HttpResponseCache类有关.</p>\n</li>\n<li><p>还没有对GIF做支持,我尝试过去支持,但是发现改动实在太大,遂放弃.老老实实用原来的.</p>\n</li>\n<li><p>超长图,还是用WebView解决吧,Picasso也做不到</p>\n</li>\n</ol>\n<p>####谁在用?</p>\n<p>豆瓣,蘑菇街,花瓣</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/JakeWharton\" target=\"_blank\" rel=\"noopener\">Jake Wharton</a>大牛写的又一力作,链式API的优雅,类库的简洁,谁用谁喜欢.</p>\n<p>GitHub 项目地址-&gt;<a href=\"https://github.com/square/picasso\" target=\"_blank\" rel=\"noopener\">https://github.com/square/picasso</a></p>\n<p>###简介</p>\n<p>在你的Android应用程序如果想要显示大量图片,而且视觉效果丰富,高效稳定,需要大量的基础工作.Picasso可以帮你完成这些工作,通常只需要一行代码!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.with(context).load(&quot;http://i.imgur.com/DvpvklR.png&quot;).into(imageView);</span><br></pre></td></tr></table></figure>\n<p>Many common pitfalls of image loading on Android are handled automatically by Picasso:</p>\n<p>Handling ImageView recycling and download cancelation in an adapter.<br>Complex image transformations with minimal memory use.<br>Automatic memory and disk caching.</p>\n<p>在Android中很多图片加载时的陷阱都由Picaaso帮你自动处理:</p>\n<ul>\n<li>在Adapter中处理ImageView的回收和下载取消</li>\n<li>使用最小的内存完成复杂的图像变化</li>\n<li>自动完成内存和磁盘缓存</li>\n</ul>\n<p>###特性</p>\n<p>####Adapter</p>\n<p>Adapter中完成下载显示,并自动取消上一个下载请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override public void getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class=\"line\">  SquaredImageView view = (SquaredImageView) convertView;</span><br><span class=\"line\">  if (view == null) &#123;</span><br><span class=\"line\">    view = new SquaredImageView(context);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  String url = getItem(position);</span><br><span class=\"line\"></span><br><span class=\"line\">  Picasso.with(context).load(url).into(view);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####图像转换</p>\n<p>转换图片以更适应放入布局中,有效减少内存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.with(context)</span><br><span class=\"line\">  .load(url)</span><br><span class=\"line\">  .resize(50, 50)</span><br><span class=\"line\">  .centerCrop()</span><br><span class=\"line\">  .into(imageView)</span><br></pre></td></tr></table></figure>\n<p>你也可以手工处理,以实现更高级的效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CropSquareTransformation implements Transformation &#123;</span><br><span class=\"line\">  @Override public Bitmap transform(Bitmap source) &#123;</span><br><span class=\"line\">    int size = Math.min(source.getWidth(), source.getHeight());</span><br><span class=\"line\">    int x = (source.getWidth() - size) / 2;</span><br><span class=\"line\">    int y = (source.getHeight() - size) / 2;</span><br><span class=\"line\">    Bitmap result = Bitmap.createBitmap(source, x, y, size, size);</span><br><span class=\"line\">    if (result != source) &#123;</span><br><span class=\"line\">      source.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override public String key() &#123; return &quot;square()&quot;; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####预留图片</p>\n<p>下载图片完成前或错误时,Picasso提供一个预留图片(placeholer)API,加载默认图片.</p>\n<p>####加载资源</p>\n<p>Resources, assets, files, content providers,在Picasso中都是支持加载的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Picasso.with(context).load(R.drawable.landing_screen).into(imageView1);</span><br><span class=\"line\">Picasso.with(context).load(new File(&quot;/images/oprah_bees.gif&quot;)).into(imageView2);</span><br></pre></td></tr></table></figure>\n<p>####当然也有缺点</p>\n<ol>\n<li><p>我们会发现,当我们想要获取缓存Bitmap的文件时,Picasso并没有这样的API,你只有在子线程中获取bitmap后,在存储一次.原因与HttpResponseCache类有关.</p>\n</li>\n<li><p>还没有对GIF做支持,我尝试过去支持,但是发现改动实在太大,遂放弃.老老实实用原来的.</p>\n</li>\n<li><p>超长图,还是用WebView解决吧,Picasso也做不到</p>\n</li>\n</ol>\n<p>####谁在用?</p>\n<p>豆瓣,蘑菇街,花瓣</p>\n"},{"title":"2017年年终总结","date":"2018-02-14T21:59:27.000Z","_content":"\n## 一. 2017年工作成果概括\n2017年初转岗产品经理后，工作方式和方法的改变给我个人带来了不小的挑战，需要重新从一个新人的状态投入到工作中。克服了很多不适应，坚持做了下来。以下是今年的主要工作产出结果概括：\n\n1. TT产品迭代。\n2. 美联网盘\n3. 内网统一搜索\n4. Todo系统\n5. 美联新零售业务\n6. 其他：PMO，蘑客联盟\n\n## 二. TT产品迭代\n\n今年有一半的时候继续投入到TT产品的迭代中，经历了若干个版本的迭代，TT产品功能和稳定性较去年有了很多提升。以下是今年主要新增功能：\n\n1. 年会/春节红包\n2. 2017/2018年度数据\n3. 集成OpenVPN\n4. 截屏分享\n5. 日历同步\n6. 部门信息\n7. 休假信息\n8. 消息撤回\n9. 免密登录\n10. TT票圈优化\n\n产出:\n累计聊天数，较2016年增长412.5%，达到132,100,544条\n活跃用户数/集团人数，占比保持在97%\n\n\n\n## 三. 美联网盘产品\n目标：提供给集团内部高并发高可靠安全的文件存储产品，基于TT产品提供便捷的上传，下载，转发，搜索和在线浏览等功能。\n\n产出：\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_2cb4cbf9ji2b01g6hl80kk4ifbkej_2114x1368.png)\n\n数据统计\n\n1. 累计上传量:20万+\n2. 累计下载量:30万+\n3. 日均上传700+次\n4. 日均下载1000+次\n\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_84c697k4d675eibbf085a9i3hchck_1982x770.png)\n\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_25c7gddjlfjll900dd4j72dla9l24_1976x764.png)\n\n## 四. 内网统一搜索产品\n目标：提升工作效率，沉淀集团知识。对以下数据源进行统一收录，BBS，WIKI，Gitlab，美联网盘，员工主数据\n\n产出\n\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_65ak78hd39i9ji3j18b09ggkhec7j_2212x1104.jpg)\n\n数据统计：\n\n![](http://s11.mogucdn.com/mlcdn/c45406/180215_5gkb410c3ih7kfl89b5574ah0b429_878x204.jpg)\n\n\n## 五. Todo系统\n需求背景：目前公司已采购了JIRA作为项目管理工具，同时在JIRA上开发了一套PMO系统，来定制化项目管理系统。同时Teambition即将到期下线。而Todo系统并不是重复造轮子，而想要作为JIRA，PMO，Teambition和口头任务等 任务管理系统的补充解决方案，提供便捷的，安全性高，流程简单的任务管理系统。特点是：\n1. 便利性：用户可以在随时随地在移动端给群里的成员 布置任务，同时桌面端也会同步到。 利用TT群聊的便利性，快速创建一个群来发布任务。\n2. 安全性：仅群内成员可以查看任务，避免JIRA，Teambition等系统没有权限控制\n3. 流程简单：Todo系统仅将任务设计了两种状态，进行中和已完成。 非常适合小任务的发布。\n\n产出\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_2bcj8jkl1h3ae8bd0d56j8b44hd1i_2114x1368.png)\n\n数据统计\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_69l14h9ck6k381elik6d5gabbh4g5_1620x346.png)\n\n\n\n## 六. 美联新零售业务\nCEO提出美联新零售概念后，参与了超级小店导购，公众号管理，独立店铺小程序等项目的产品策划和执行。之后由于业务调整，暂无产出。\n\n产出：\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_4if43h69kgd108032838dlkd9f173_750x1334.jpg)\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_2hjj2k513ek3hbidh6123c3f1c249_750x1334.jpg)\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_370d5bl43i430g583gl0592c984ke_1498x1106.png)\n\n\n\n## 七. 个人成长\n思维方式\n\n* 产品思维和技术思维。产品思维，我可以理解为需要不断强调自己要站在用户的角度看问题，一秒变成傻瓜，去使用自己的产品，而不是以前的技术思维，即时非常难用的产品我也可以摸索出使用方案，并且从开发者的角度去思考为什么他这么设计，是不是因为技术原因。 比如说，微信撤回消息2分钟过期，没有查答案前，我以为是技术原因导致的，后来才知道，如果一个用户可以撤回N天前的约定或承诺，现实场景总将非常麻烦。\n* 经营思维。 根本上经营的本质是赚取利润，利润是收入减支出。经营公司，带领团队或产品决策上都不应该离开这个原则。我做这个事情是为了获取收入，还是降低成本，如果都没有，那这个事情的优先级是很低的。比如说下半年做的TT票圈优化需求，回头来看这个项目是比较失败的，商业化可能性低或没有坚决执行下去，对于集体内部效率提升不明显。\n\n读书\n\n* 感谢微信图书应用，2017年我一共看了20本书，读书时长169小时。主要图书类型是 互联网相关，其次是金融股票。甘感触比较多的是稻盛和夫的《干法》，学习了一种哲学思想，你为什么而工作。肯.布兰佳的《新版一分钟经理人》，主管和员工之间如何高效的沟通工作目标，工作反馈和奖罚。Paul Graham《黑客和画家》，影响很深的是《不能说的话》一章，跳出正常思考范畴，不要被束缚。金融类彼得林奇的《战胜华尔街》。\n","source":"_posts/2017年年终总结.md","raw":"---\ntitle: 2017年年终总结\ndate: 2018-02-15 05:59:27\ntags: work\n---\n\n## 一. 2017年工作成果概括\n2017年初转岗产品经理后，工作方式和方法的改变给我个人带来了不小的挑战，需要重新从一个新人的状态投入到工作中。克服了很多不适应，坚持做了下来。以下是今年的主要工作产出结果概括：\n\n1. TT产品迭代。\n2. 美联网盘\n3. 内网统一搜索\n4. Todo系统\n5. 美联新零售业务\n6. 其他：PMO，蘑客联盟\n\n## 二. TT产品迭代\n\n今年有一半的时候继续投入到TT产品的迭代中，经历了若干个版本的迭代，TT产品功能和稳定性较去年有了很多提升。以下是今年主要新增功能：\n\n1. 年会/春节红包\n2. 2017/2018年度数据\n3. 集成OpenVPN\n4. 截屏分享\n5. 日历同步\n6. 部门信息\n7. 休假信息\n8. 消息撤回\n9. 免密登录\n10. TT票圈优化\n\n产出:\n累计聊天数，较2016年增长412.5%，达到132,100,544条\n活跃用户数/集团人数，占比保持在97%\n\n\n\n## 三. 美联网盘产品\n目标：提供给集团内部高并发高可靠安全的文件存储产品，基于TT产品提供便捷的上传，下载，转发，搜索和在线浏览等功能。\n\n产出：\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_2cb4cbf9ji2b01g6hl80kk4ifbkej_2114x1368.png)\n\n数据统计\n\n1. 累计上传量:20万+\n2. 累计下载量:30万+\n3. 日均上传700+次\n4. 日均下载1000+次\n\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_84c697k4d675eibbf085a9i3hchck_1982x770.png)\n\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_25c7gddjlfjll900dd4j72dla9l24_1976x764.png)\n\n## 四. 内网统一搜索产品\n目标：提升工作效率，沉淀集团知识。对以下数据源进行统一收录，BBS，WIKI，Gitlab，美联网盘，员工主数据\n\n产出\n\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_65ak78hd39i9ji3j18b09ggkhec7j_2212x1104.jpg)\n\n数据统计：\n\n![](http://s11.mogucdn.com/mlcdn/c45406/180215_5gkb410c3ih7kfl89b5574ah0b429_878x204.jpg)\n\n\n## 五. Todo系统\n需求背景：目前公司已采购了JIRA作为项目管理工具，同时在JIRA上开发了一套PMO系统，来定制化项目管理系统。同时Teambition即将到期下线。而Todo系统并不是重复造轮子，而想要作为JIRA，PMO，Teambition和口头任务等 任务管理系统的补充解决方案，提供便捷的，安全性高，流程简单的任务管理系统。特点是：\n1. 便利性：用户可以在随时随地在移动端给群里的成员 布置任务，同时桌面端也会同步到。 利用TT群聊的便利性，快速创建一个群来发布任务。\n2. 安全性：仅群内成员可以查看任务，避免JIRA，Teambition等系统没有权限控制\n3. 流程简单：Todo系统仅将任务设计了两种状态，进行中和已完成。 非常适合小任务的发布。\n\n产出\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_2bcj8jkl1h3ae8bd0d56j8b44hd1i_2114x1368.png)\n\n数据统计\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_69l14h9ck6k381elik6d5gabbh4g5_1620x346.png)\n\n\n\n## 六. 美联新零售业务\nCEO提出美联新零售概念后，参与了超级小店导购，公众号管理，独立店铺小程序等项目的产品策划和执行。之后由于业务调整，暂无产出。\n\n产出：\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_4if43h69kgd108032838dlkd9f173_750x1334.jpg)\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_2hjj2k513ek3hbidh6123c3f1c249_750x1334.jpg)\n![](http://s3.mogucdn.com/mlcdn/c45406/180215_370d5bl43i430g583gl0592c984ke_1498x1106.png)\n\n\n\n## 七. 个人成长\n思维方式\n\n* 产品思维和技术思维。产品思维，我可以理解为需要不断强调自己要站在用户的角度看问题，一秒变成傻瓜，去使用自己的产品，而不是以前的技术思维，即时非常难用的产品我也可以摸索出使用方案，并且从开发者的角度去思考为什么他这么设计，是不是因为技术原因。 比如说，微信撤回消息2分钟过期，没有查答案前，我以为是技术原因导致的，后来才知道，如果一个用户可以撤回N天前的约定或承诺，现实场景总将非常麻烦。\n* 经营思维。 根本上经营的本质是赚取利润，利润是收入减支出。经营公司，带领团队或产品决策上都不应该离开这个原则。我做这个事情是为了获取收入，还是降低成本，如果都没有，那这个事情的优先级是很低的。比如说下半年做的TT票圈优化需求，回头来看这个项目是比较失败的，商业化可能性低或没有坚决执行下去，对于集体内部效率提升不明显。\n\n读书\n\n* 感谢微信图书应用，2017年我一共看了20本书，读书时长169小时。主要图书类型是 互联网相关，其次是金融股票。甘感触比较多的是稻盛和夫的《干法》，学习了一种哲学思想，你为什么而工作。肯.布兰佳的《新版一分钟经理人》，主管和员工之间如何高效的沟通工作目标，工作反馈和奖罚。Paul Graham《黑客和画家》，影响很深的是《不能说的话》一章，跳出正常思考范畴，不要被束缚。金融类彼得林奇的《战胜华尔街》。\n","slug":"2017年年终总结","published":1,"updated":"2018-02-14T22:20:10.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdnn3tm0001grpfyy9evurur","content":"<h2 id=\"一-2017年工作成果概括\"><a href=\"#一-2017年工作成果概括\" class=\"headerlink\" title=\"一. 2017年工作成果概括\"></a>一. 2017年工作成果概括</h2><p>2017年初转岗产品经理后，工作方式和方法的改变给我个人带来了不小的挑战，需要重新从一个新人的状态投入到工作中。克服了很多不适应，坚持做了下来。以下是今年的主要工作产出结果概括：</p>\n<ol>\n<li>TT产品迭代。</li>\n<li>美联网盘</li>\n<li>内网统一搜索</li>\n<li>Todo系统</li>\n<li>美联新零售业务</li>\n<li>其他：PMO，蘑客联盟</li>\n</ol>\n<h2 id=\"二-TT产品迭代\"><a href=\"#二-TT产品迭代\" class=\"headerlink\" title=\"二. TT产品迭代\"></a>二. TT产品迭代</h2><p>今年有一半的时候继续投入到TT产品的迭代中，经历了若干个版本的迭代，TT产品功能和稳定性较去年有了很多提升。以下是今年主要新增功能：</p>\n<ol>\n<li>年会/春节红包</li>\n<li>2017/2018年度数据</li>\n<li>集成OpenVPN</li>\n<li>截屏分享</li>\n<li>日历同步</li>\n<li>部门信息</li>\n<li>休假信息</li>\n<li>消息撤回</li>\n<li>免密登录</li>\n<li>TT票圈优化</li>\n</ol>\n<p>产出:<br>累计聊天数，较2016年增长412.5%，达到132,100,544条<br>活跃用户数/集团人数，占比保持在97%</p>\n<h2 id=\"三-美联网盘产品\"><a href=\"#三-美联网盘产品\" class=\"headerlink\" title=\"三. 美联网盘产品\"></a>三. 美联网盘产品</h2><p>目标：提供给集团内部高并发高可靠安全的文件存储产品，基于TT产品提供便捷的上传，下载，转发，搜索和在线浏览等功能。</p>\n<p>产出：<br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_2cb4cbf9ji2b01g6hl80kk4ifbkej_2114x1368.png\" alt=\"\"></p>\n<p>数据统计</p>\n<ol>\n<li>累计上传量:20万+</li>\n<li>累计下载量:30万+</li>\n<li>日均上传700+次</li>\n<li>日均下载1000+次</li>\n</ol>\n<p><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_84c697k4d675eibbf085a9i3hchck_1982x770.png\" alt=\"\"></p>\n<p><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_25c7gddjlfjll900dd4j72dla9l24_1976x764.png\" alt=\"\"></p>\n<h2 id=\"四-内网统一搜索产品\"><a href=\"#四-内网统一搜索产品\" class=\"headerlink\" title=\"四. 内网统一搜索产品\"></a>四. 内网统一搜索产品</h2><p>目标：提升工作效率，沉淀集团知识。对以下数据源进行统一收录，BBS，WIKI，Gitlab，美联网盘，员工主数据</p>\n<p>产出</p>\n<p><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_65ak78hd39i9ji3j18b09ggkhec7j_2212x1104.jpg\" alt=\"\"></p>\n<p>数据统计：</p>\n<p><img src=\"http://s11.mogucdn.com/mlcdn/c45406/180215_5gkb410c3ih7kfl89b5574ah0b429_878x204.jpg\" alt=\"\"></p>\n<h2 id=\"五-Todo系统\"><a href=\"#五-Todo系统\" class=\"headerlink\" title=\"五. Todo系统\"></a>五. Todo系统</h2><p>需求背景：目前公司已采购了JIRA作为项目管理工具，同时在JIRA上开发了一套PMO系统，来定制化项目管理系统。同时Teambition即将到期下线。而Todo系统并不是重复造轮子，而想要作为JIRA，PMO，Teambition和口头任务等 任务管理系统的补充解决方案，提供便捷的，安全性高，流程简单的任务管理系统。特点是：</p>\n<ol>\n<li>便利性：用户可以在随时随地在移动端给群里的成员 布置任务，同时桌面端也会同步到。 利用TT群聊的便利性，快速创建一个群来发布任务。</li>\n<li>安全性：仅群内成员可以查看任务，避免JIRA，Teambition等系统没有权限控制</li>\n<li>流程简单：Todo系统仅将任务设计了两种状态，进行中和已完成。 非常适合小任务的发布。</li>\n</ol>\n<p>产出<br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_2bcj8jkl1h3ae8bd0d56j8b44hd1i_2114x1368.png\" alt=\"\"></p>\n<p>数据统计<br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_69l14h9ck6k381elik6d5gabbh4g5_1620x346.png\" alt=\"\"></p>\n<h2 id=\"六-美联新零售业务\"><a href=\"#六-美联新零售业务\" class=\"headerlink\" title=\"六. 美联新零售业务\"></a>六. 美联新零售业务</h2><p>CEO提出美联新零售概念后，参与了超级小店导购，公众号管理，独立店铺小程序等项目的产品策划和执行。之后由于业务调整，暂无产出。</p>\n<p>产出：<br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_4if43h69kgd108032838dlkd9f173_750x1334.jpg\" alt=\"\"><br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_2hjj2k513ek3hbidh6123c3f1c249_750x1334.jpg\" alt=\"\"><br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_370d5bl43i430g583gl0592c984ke_1498x1106.png\" alt=\"\"></p>\n<h2 id=\"七-个人成长\"><a href=\"#七-个人成长\" class=\"headerlink\" title=\"七. 个人成长\"></a>七. 个人成长</h2><p>思维方式</p>\n<ul>\n<li>产品思维和技术思维。产品思维，我可以理解为需要不断强调自己要站在用户的角度看问题，一秒变成傻瓜，去使用自己的产品，而不是以前的技术思维，即时非常难用的产品我也可以摸索出使用方案，并且从开发者的角度去思考为什么他这么设计，是不是因为技术原因。 比如说，微信撤回消息2分钟过期，没有查答案前，我以为是技术原因导致的，后来才知道，如果一个用户可以撤回N天前的约定或承诺，现实场景总将非常麻烦。</li>\n<li>经营思维。 根本上经营的本质是赚取利润，利润是收入减支出。经营公司，带领团队或产品决策上都不应该离开这个原则。我做这个事情是为了获取收入，还是降低成本，如果都没有，那这个事情的优先级是很低的。比如说下半年做的TT票圈优化需求，回头来看这个项目是比较失败的，商业化可能性低或没有坚决执行下去，对于集体内部效率提升不明显。</li>\n</ul>\n<p>读书</p>\n<ul>\n<li>感谢微信图书应用，2017年我一共看了20本书，读书时长169小时。主要图书类型是 互联网相关，其次是金融股票。甘感触比较多的是稻盛和夫的《干法》，学习了一种哲学思想，你为什么而工作。肯.布兰佳的《新版一分钟经理人》，主管和员工之间如何高效的沟通工作目标，工作反馈和奖罚。Paul Graham《黑客和画家》，影响很深的是《不能说的话》一章，跳出正常思考范畴，不要被束缚。金融类彼得林奇的《战胜华尔街》。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一-2017年工作成果概括\"><a href=\"#一-2017年工作成果概括\" class=\"headerlink\" title=\"一. 2017年工作成果概括\"></a>一. 2017年工作成果概括</h2><p>2017年初转岗产品经理后，工作方式和方法的改变给我个人带来了不小的挑战，需要重新从一个新人的状态投入到工作中。克服了很多不适应，坚持做了下来。以下是今年的主要工作产出结果概括：</p>\n<ol>\n<li>TT产品迭代。</li>\n<li>美联网盘</li>\n<li>内网统一搜索</li>\n<li>Todo系统</li>\n<li>美联新零售业务</li>\n<li>其他：PMO，蘑客联盟</li>\n</ol>\n<h2 id=\"二-TT产品迭代\"><a href=\"#二-TT产品迭代\" class=\"headerlink\" title=\"二. TT产品迭代\"></a>二. TT产品迭代</h2><p>今年有一半的时候继续投入到TT产品的迭代中，经历了若干个版本的迭代，TT产品功能和稳定性较去年有了很多提升。以下是今年主要新增功能：</p>\n<ol>\n<li>年会/春节红包</li>\n<li>2017/2018年度数据</li>\n<li>集成OpenVPN</li>\n<li>截屏分享</li>\n<li>日历同步</li>\n<li>部门信息</li>\n<li>休假信息</li>\n<li>消息撤回</li>\n<li>免密登录</li>\n<li>TT票圈优化</li>\n</ol>\n<p>产出:<br>累计聊天数，较2016年增长412.5%，达到132,100,544条<br>活跃用户数/集团人数，占比保持在97%</p>\n<h2 id=\"三-美联网盘产品\"><a href=\"#三-美联网盘产品\" class=\"headerlink\" title=\"三. 美联网盘产品\"></a>三. 美联网盘产品</h2><p>目标：提供给集团内部高并发高可靠安全的文件存储产品，基于TT产品提供便捷的上传，下载，转发，搜索和在线浏览等功能。</p>\n<p>产出：<br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_2cb4cbf9ji2b01g6hl80kk4ifbkej_2114x1368.png\" alt=\"\"></p>\n<p>数据统计</p>\n<ol>\n<li>累计上传量:20万+</li>\n<li>累计下载量:30万+</li>\n<li>日均上传700+次</li>\n<li>日均下载1000+次</li>\n</ol>\n<p><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_84c697k4d675eibbf085a9i3hchck_1982x770.png\" alt=\"\"></p>\n<p><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_25c7gddjlfjll900dd4j72dla9l24_1976x764.png\" alt=\"\"></p>\n<h2 id=\"四-内网统一搜索产品\"><a href=\"#四-内网统一搜索产品\" class=\"headerlink\" title=\"四. 内网统一搜索产品\"></a>四. 内网统一搜索产品</h2><p>目标：提升工作效率，沉淀集团知识。对以下数据源进行统一收录，BBS，WIKI，Gitlab，美联网盘，员工主数据</p>\n<p>产出</p>\n<p><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_65ak78hd39i9ji3j18b09ggkhec7j_2212x1104.jpg\" alt=\"\"></p>\n<p>数据统计：</p>\n<p><img src=\"http://s11.mogucdn.com/mlcdn/c45406/180215_5gkb410c3ih7kfl89b5574ah0b429_878x204.jpg\" alt=\"\"></p>\n<h2 id=\"五-Todo系统\"><a href=\"#五-Todo系统\" class=\"headerlink\" title=\"五. Todo系统\"></a>五. Todo系统</h2><p>需求背景：目前公司已采购了JIRA作为项目管理工具，同时在JIRA上开发了一套PMO系统，来定制化项目管理系统。同时Teambition即将到期下线。而Todo系统并不是重复造轮子，而想要作为JIRA，PMO，Teambition和口头任务等 任务管理系统的补充解决方案，提供便捷的，安全性高，流程简单的任务管理系统。特点是：</p>\n<ol>\n<li>便利性：用户可以在随时随地在移动端给群里的成员 布置任务，同时桌面端也会同步到。 利用TT群聊的便利性，快速创建一个群来发布任务。</li>\n<li>安全性：仅群内成员可以查看任务，避免JIRA，Teambition等系统没有权限控制</li>\n<li>流程简单：Todo系统仅将任务设计了两种状态，进行中和已完成。 非常适合小任务的发布。</li>\n</ol>\n<p>产出<br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_2bcj8jkl1h3ae8bd0d56j8b44hd1i_2114x1368.png\" alt=\"\"></p>\n<p>数据统计<br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_69l14h9ck6k381elik6d5gabbh4g5_1620x346.png\" alt=\"\"></p>\n<h2 id=\"六-美联新零售业务\"><a href=\"#六-美联新零售业务\" class=\"headerlink\" title=\"六. 美联新零售业务\"></a>六. 美联新零售业务</h2><p>CEO提出美联新零售概念后，参与了超级小店导购，公众号管理，独立店铺小程序等项目的产品策划和执行。之后由于业务调整，暂无产出。</p>\n<p>产出：<br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_4if43h69kgd108032838dlkd9f173_750x1334.jpg\" alt=\"\"><br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_2hjj2k513ek3hbidh6123c3f1c249_750x1334.jpg\" alt=\"\"><br><img src=\"http://s3.mogucdn.com/mlcdn/c45406/180215_370d5bl43i430g583gl0592c984ke_1498x1106.png\" alt=\"\"></p>\n<h2 id=\"七-个人成长\"><a href=\"#七-个人成长\" class=\"headerlink\" title=\"七. 个人成长\"></a>七. 个人成长</h2><p>思维方式</p>\n<ul>\n<li>产品思维和技术思维。产品思维，我可以理解为需要不断强调自己要站在用户的角度看问题，一秒变成傻瓜，去使用自己的产品，而不是以前的技术思维，即时非常难用的产品我也可以摸索出使用方案，并且从开发者的角度去思考为什么他这么设计，是不是因为技术原因。 比如说，微信撤回消息2分钟过期，没有查答案前，我以为是技术原因导致的，后来才知道，如果一个用户可以撤回N天前的约定或承诺，现实场景总将非常麻烦。</li>\n<li>经营思维。 根本上经营的本质是赚取利润，利润是收入减支出。经营公司，带领团队或产品决策上都不应该离开这个原则。我做这个事情是为了获取收入，还是降低成本，如果都没有，那这个事情的优先级是很低的。比如说下半年做的TT票圈优化需求，回头来看这个项目是比较失败的，商业化可能性低或没有坚决执行下去，对于集体内部效率提升不明显。</li>\n</ul>\n<p>读书</p>\n<ul>\n<li>感谢微信图书应用，2017年我一共看了20本书，读书时长169小时。主要图书类型是 互联网相关，其次是金融股票。甘感触比较多的是稻盛和夫的《干法》，学习了一种哲学思想，你为什么而工作。肯.布兰佳的《新版一分钟经理人》，主管和员工之间如何高效的沟通工作目标，工作反馈和奖罚。Paul Graham《黑客和画家》，影响很深的是《不能说的话》一章，跳出正常思考范畴，不要被束缚。金融类彼得林奇的《战胜华尔街》。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjdnn3tkf0004rpfye0szkrdy","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tkm0009rpfyc59ed5gi"},{"post_id":"cjdnn3tk60000rpfyqw3ou5ew","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tko000crpfys1ssbe40"},{"post_id":"cjdnn3tkh0005rpfya34r51vj","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tkp000drpfy77czadpi"},{"post_id":"cjdnn3tkj0007rpfyflmzifkd","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tkp000erpfyze6djprm"},{"post_id":"cjdnn3tka0001rpfy1id25rs4","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tkq000frpfy1czqyj2x"},{"post_id":"cjdnn3tkl0008rpfydn76qa5q","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tkq000grpfy1lah5rhs"},{"post_id":"cjdnn3tkn000brpfy43twa6bl","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tkr000hrpfyalnjsckp"},{"post_id":"cjdnn3tke0003rpfy18rlefda","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tkr000irpfy1k463h9g"},{"post_id":"cjdnn3tld000jrpfysn8m3vv1","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlj000nrpfy922tuhbk"},{"post_id":"cjdnn3tle000krpfyenhqjl5u","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlk000prpfyucn6gx7h"},{"post_id":"cjdnn3tlh000lrpfyfglz1auu","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlm000rrpfy1ismce6v"},{"post_id":"cjdnn3tli000mrpfypfz1ikkv","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tln000trpfyrqgqvsag"},{"post_id":"cjdnn3tlj000orpfyarrfsn9s","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlo000vrpfyx363h03a"},{"post_id":"cjdnn3tll000qrpfyczwvp4vt","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlp000xrpfyqh1vo7yx"},{"post_id":"cjdnn3tlm000srpfy3xgm2atq","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlq000zrpfyar510a8e"},{"post_id":"cjdnn3tln000urpfygwy02tdw","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlr0011rpfy4j4f8qzr"},{"post_id":"cjdnn3tlo000wrpfy9vbv3v0g","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tls0013rpfy2s3pvbgv"},{"post_id":"cjdnn3tlp000yrpfyes06fh53","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlt0015rpfyuafnzc66"},{"post_id":"cjdnn3tlq0010rpfyngd793m2","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlu0017rpfyfvbvezch"},{"post_id":"cjdnn3tlr0012rpfyt8u0sz4d","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlw0019rpfyfwrwa5y9"},{"post_id":"cjdnn3tlt0014rpfygh59b4ud","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tlx001brpfyxs54643v"},{"post_id":"cjdnn3tlu0016rpfy62rm0gsi","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tly001drpfy9l46npfo"},{"post_id":"cjdnn3tlv0018rpfy95qkya5j","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tm0001frpfy9pahskzt"},{"post_id":"cjdnn3tlw001arpfydgcguply","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tm1001hrpfyyayvmgy6"},{"post_id":"cjdnn3tlz001erpfyf8bssej8","category_id":"cjdnn3tkc0002rpfybrh70zzf","_id":"cjdnn3tm2001jrpfyovejsluw"}],"PostTag":[{"post_id":"cjdnn3tm0001grpfyy9evurur","tag_id":"cjdnn3tm2001irpfy7q34g3d0","_id":"cjdnn3tm3001krpfyqu3ea9bx"}],"Tag":[{"name":"work","_id":"cjdnn3tm2001irpfy7q34g3d0"}]}}